/**
 * Decision Lens API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'http://localhost:9005/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AccessTokenGeneratedEvent {
    'id'?: string;
    'user'?: User;
    'grantType'?: string;
    'clientId'?: string;
    'groupId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "grantType",
            "baseName": "grantType",
            "type": "string"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "groupId",
            "baseName": "groupId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccessTokenGeneratedEvent.attributeTypeMap;
    }
}

export class ActivityType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ActivityType.attributeTypeMap;
    }
}

export class AddUserRequest {
    'user'?: User;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddUserRequest.attributeTypeMap;
    }
}

export class AddUsersRequest {
    'emailIds'?: Array<string>;
    'role'?: PortfolioPlanUserRole;
    'message'?: string;
    'doNotNotify'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailIds",
            "baseName": "emailIds",
            "type": "Array<string>"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "PortfolioPlanUserRole"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "doNotNotify",
            "baseName": "doNotNotify",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AddUsersRequest.attributeTypeMap;
    }
}

export class AddedToPortfolioMessagePayload {
    'portfolio': Portfolio;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolio",
            "baseName": "portfolio",
            "type": "Portfolio"
        }    ];

    static getAttributeTypeMap() {
        return AddedToPortfolioMessagePayload.attributeTypeMap;
    }
}

export class AddedToPortfolioPlanMessagePayload {
    'portfolioPlan': PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return AddedToPortfolioPlanMessagePayload.attributeTypeMap;
    }
}

export class AttachmentCreatedEvent {
    'portfolioId'?: string;
    'size'?: number;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return AttachmentCreatedEvent.attributeTypeMap;
    }
}

export class AttachmentDeletedEvent {
    'portfolioId'?: string;
    'size'?: number;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return AttachmentDeletedEvent.attributeTypeMap;
    }
}

export class AttachmentNameUpdatedEvent {
    'portfolioId'?: string;
    'size'?: number;
    'previousName'?: string;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "previousName",
            "baseName": "previousName",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return AttachmentNameUpdatedEvent.attributeTypeMap;
    }
}

export class AttachmentUpdatedMessagePayload {
    'attachment': Attachment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachment",
            "baseName": "attachment",
            "type": "Attachment"
        }    ];

    static getAttributeTypeMap() {
        return AttachmentUpdatedMessagePayload.attributeTypeMap;
    }
}

export class Attributes {
    'timeInterval'?: TimeInterval;
    'budgetTimePeriodType'?: TimePeriodType;
    'isMonthlySpendPlan'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "timeInterval",
            "baseName": "timeInterval",
            "type": "TimeInterval"
        },
        {
            "name": "budgetTimePeriodType",
            "baseName": "budgetTimePeriodType",
            "type": "TimePeriodType"
        },
        {
            "name": "isMonthlySpendPlan",
            "baseName": "isMonthlySpendPlan",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Attributes.attributeTypeMap;
    }
}

export class AuthorizationCodeGeneratedEvent {
    'id'?: string;
    'user'?: User;
    'redirectUri'?: string;
    'clientId'?: string;
    'groupId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "redirectUri",
            "baseName": "redirectUri",
            "type": "string"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "groupId",
            "baseName": "groupId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AuthorizationCodeGeneratedEvent.attributeTypeMap;
    }
}

export class BalanceFieldDetail {
    'categoryName'?: string;
    'actual'?: number;
    'expected'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categoryName",
            "baseName": "categoryName",
            "type": "string"
        },
        {
            "name": "actual",
            "baseName": "actual",
            "type": "number"
        },
        {
            "name": "expected",
            "baseName": "expected",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return BalanceFieldDetail.attributeTypeMap;
    }
}

export class BudgetAllocation {
    'resourcePoolName'?: string;
    'resourcePoolId'?: string;
    'yearlyBudgets'?: Array<number>;
    'yearlyAllocations'?: Array<number>;
    'yearlyTimePeriods'?: Array<number>;
    'yearlyConstrainedAllocations'?: Array<number>;
    'monthlyAllocations'?: Array<number>;
    'monthlyBudgets'?: Array<number>;
    'monthlyTimePeriods'?: Array<number>;
    'monthlyConstrainedAllocations'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resourcePoolName",
            "baseName": "resourcePoolName",
            "type": "string"
        },
        {
            "name": "resourcePoolId",
            "baseName": "resourcePoolId",
            "type": "string"
        },
        {
            "name": "yearlyBudgets",
            "baseName": "yearlyBudgets",
            "type": "Array<number>"
        },
        {
            "name": "yearlyAllocations",
            "baseName": "yearlyAllocations",
            "type": "Array<number>"
        },
        {
            "name": "yearlyTimePeriods",
            "baseName": "yearlyTimePeriods",
            "type": "Array<number>"
        },
        {
            "name": "yearlyConstrainedAllocations",
            "baseName": "yearlyConstrainedAllocations",
            "type": "Array<number>"
        },
        {
            "name": "monthlyAllocations",
            "baseName": "monthlyAllocations",
            "type": "Array<number>"
        },
        {
            "name": "monthlyBudgets",
            "baseName": "monthlyBudgets",
            "type": "Array<number>"
        },
        {
            "name": "monthlyTimePeriods",
            "baseName": "monthlyTimePeriods",
            "type": "Array<number>"
        },
        {
            "name": "monthlyConstrainedAllocations",
            "baseName": "monthlyConstrainedAllocations",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return BudgetAllocation.attributeTypeMap;
    }
}

export class CalculationType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CalculationType.attributeTypeMap;
    }
}

export class CategoryOptionAddedMessagePayload {
    'categoryOption': CategoryOption;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categoryOption",
            "baseName": "categoryOption",
            "type": "CategoryOption"
        }    ];

    static getAttributeTypeMap() {
        return CategoryOptionAddedMessagePayload.attributeTypeMap;
    }
}

export class CategoryOptionCreatedEvent {
    'portfolioId'?: string;
    'name'?: string;
    'id'?: string;
    'fieldId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CategoryOptionCreatedEvent.attributeTypeMap;
    }
}

export class CategoryOptionDeletedEvent {
    'portfolioId'?: string;
    'name'?: string;
    'id'?: string;
    'fieldId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CategoryOptionDeletedEvent.attributeTypeMap;
    }
}

export class CategoryOptionDeletedMessagePayload {
    'categoryOption': CategoryOption;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categoryOption",
            "baseName": "categoryOption",
            "type": "CategoryOption"
        }    ];

    static getAttributeTypeMap() {
        return CategoryOptionDeletedMessagePayload.attributeTypeMap;
    }
}

export class CategoryOptionNameUpdatedEvent {
    'portfolioId'?: string;
    'previousName'?: string;
    'name'?: string;
    'id'?: string;
    'fieldId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "previousName",
            "baseName": "previousName",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CategoryOptionNameUpdatedEvent.attributeTypeMap;
    }
}

export class CategoryOptionUpdatedMessagePayload {
    'categoryOption': CategoryOption;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categoryOption",
            "baseName": "categoryOption",
            "type": "CategoryOption"
        }    ];

    static getAttributeTypeMap() {
        return CategoryOptionUpdatedMessagePayload.attributeTypeMap;
    }
}

export class Classification {
    'phrase'?: string;
    'type'?: string;
    'targetType'?: string;
    'planFeature'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "phrase",
            "baseName": "phrase",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "targetType",
            "baseName": "targetType",
            "type": "string"
        },
        {
            "name": "planFeature",
            "baseName": "planFeature",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Classification.attributeTypeMap;
    }
}

export class CommentAddedEvent {
    'portfolioId'?: string;
    'id'?: string;
    'projectName'?: string;
    'userId'?: string;
    'projectId'?: string;
    'value'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "projectName",
            "baseName": "projectName",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "projectId",
            "baseName": "projectId",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return CommentAddedEvent.attributeTypeMap;
    }
}

export class CommentAddedMessagePayload {
    'comment': Comment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "Comment"
        }    ];

    static getAttributeTypeMap() {
        return CommentAddedMessagePayload.attributeTypeMap;
    }
}

export class CommentDeletedEvent {
    'portfolioId'?: string;
    'id'?: string;
    'projectName'?: string;
    'userId'?: string;
    'projectId'?: string;
    'value'?: string;
    'previousValue'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "projectName",
            "baseName": "projectName",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "projectId",
            "baseName": "projectId",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "previousValue",
            "baseName": "previousValue",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return CommentDeletedEvent.attributeTypeMap;
    }
}

export class CommentDeletedMessagePayload {
    'comment': Comment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "Comment"
        }    ];

    static getAttributeTypeMap() {
        return CommentDeletedMessagePayload.attributeTypeMap;
    }
}

export class CommentEditedEvent {
    'portfolioId'?: string;
    'id'?: string;
    'projectName'?: string;
    'userId'?: string;
    'projectId'?: string;
    'value'?: string;
    'previousValue'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "projectName",
            "baseName": "projectName",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "projectId",
            "baseName": "projectId",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "previousValue",
            "baseName": "previousValue",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return CommentEditedEvent.attributeTypeMap;
    }
}

export class CommentEditedMessagePayload {
    'comment': Comment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "Comment"
        }    ];

    static getAttributeTypeMap() {
        return CommentEditedMessagePayload.attributeTypeMap;
    }
}

export class ConstraintType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ConstraintType.attributeTypeMap;
    }
}

export class CostBudgetAllocation {
    'field'?: Field;
    'budget'?: number;
    'allocation'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "budget",
            "baseName": "budget",
            "type": "number"
        },
        {
            "name": "allocation",
            "baseName": "allocation",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CostBudgetAllocation.attributeTypeMap;
    }
}

export class CustomName {
    'type'?: CustomNameType;
    'value'?: string;
    'groupType'?: CustomNameGroupType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "CustomNameType"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "groupType",
            "baseName": "groupType",
            "type": "CustomNameGroupType"
        }    ];

    static getAttributeTypeMap() {
        return CustomName.attributeTypeMap;
    }
}

export class CustomNameAddedEvent {
    'groupType'?: string;
    'portfolioId'?: string;
    'id'?: string;
    'type'?: string;
    'value'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "groupType",
            "baseName": "groupType",
            "type": "string"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return CustomNameAddedEvent.attributeTypeMap;
    }
}

export class CustomNameDeletedEvent {
    'groupType'?: string;
    'portfolioId'?: string;
    'id'?: string;
    'type'?: string;
    'value'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "groupType",
            "baseName": "groupType",
            "type": "string"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return CustomNameDeletedEvent.attributeTypeMap;
    }
}

export class CustomNameGroupType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CustomNameGroupType.attributeTypeMap;
    }
}

export class CustomNameType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CustomNameType.attributeTypeMap;
    }
}

export class CustomNameUpdatedEvent {
    'groupType'?: string;
    'portfolioId'?: string;
    'id'?: string;
    'type'?: string;
    'previousValue'?: string;
    'value'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "groupType",
            "baseName": "groupType",
            "type": "string"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "previousValue",
            "baseName": "previousValue",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return CustomNameUpdatedEvent.attributeTypeMap;
    }
}

export class CustomNamesUpdatedMessagePayload {
    'customNames': Array<CustomName>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customNames",
            "baseName": "customNames",
            "type": "Array<CustomName>"
        }    ];

    static getAttributeTypeMap() {
        return CustomNamesUpdatedMessagePayload.attributeTypeMap;
    }
}

export class DataType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return DataType.attributeTypeMap;
    }
}

export class DataUpdatedMessagePayload {
    'message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DataUpdatedMessagePayload.attributeTypeMap;
    }
}

export class DlCollection {
    'href'?: string;
    'offset'?: number;
    'limit'?: number;
    'size'?: number;

    static discriminator: string | undefined = "href";

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DlCollection.attributeTypeMap;
    }
}

export class DlResource {
    'href'?: string;
    'id'?: string;
    'createdAt'?: string;
    'modifiedAt'?: string;

    static discriminator: string | undefined = "href";

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DlResource.attributeTypeMap;
    }
}

export class DlcPortfolio {
    'id'?: string;
    'url'?: string;
    'taskUrl'?: string;
    'lastUpdatedAt'?: number;
    'lastFetchedAt'?: number;
    'statuses'?: Array<string>;
    'defaultPriorityScenario'?: string;
    'priorityScenarios'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "taskUrl",
            "baseName": "taskUrl",
            "type": "string"
        },
        {
            "name": "lastUpdatedAt",
            "baseName": "lastUpdatedAt",
            "type": "number"
        },
        {
            "name": "lastFetchedAt",
            "baseName": "lastFetchedAt",
            "type": "number"
        },
        {
            "name": "statuses",
            "baseName": "statuses",
            "type": "Array<string>"
        },
        {
            "name": "defaultPriorityScenario",
            "baseName": "defaultPriorityScenario",
            "type": "string"
        },
        {
            "name": "priorityScenarios",
            "baseName": "priorityScenarios",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return DlcPortfolio.attributeTypeMap;
    }
}

export class DraftProjectsSubmittedMessagePayload {
    'projects': Array<Project>;
    'attachments'?: Array<Attachment>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "projects",
            "baseName": "projects",
            "type": "Array<Project>"
        },
        {
            "name": "attachments",
            "baseName": "attachments",
            "type": "Array<Attachment>"
        }    ];

    static getAttributeTypeMap() {
        return DraftProjectsSubmittedMessagePayload.attributeTypeMap;
    }
}

export class ErrorResponse {
    'code': number;
    'message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ErrorResponse.attributeTypeMap;
    }
}

export class ExpandComponent {
    /**
    * path to the collection. example - items.fieldValues
    */
    'path'?: string;
    /**
    * filter the collection. example - \"field.id:123-12321-321312-e3e21w\"
    */
    'match'?: string;
    /**
    * return all possible values in the collection even if they are not assigned to projects currently like all STATUS values.
    */
    'allPossible'?: boolean;
    /**
    * return only unique values in the collection
    */
    'unique'?: boolean;
    /**
    * pagination - limit
    */
    'limit'?: number;
    /**
    * pagination - offset
    */
    'offset'?: number;
    /**
    * order the values returned in the collection
    */
    'orderBy'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "match",
            "baseName": "match",
            "type": "string"
        },
        {
            "name": "allPossible",
            "baseName": "allPossible",
            "type": "boolean"
        },
        {
            "name": "unique",
            "baseName": "unique",
            "type": "boolean"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "orderBy",
            "baseName": "orderBy",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExpandComponent.attributeTypeMap;
    }
}

export class ExportFormatType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ExportFormatType.attributeTypeMap;
    }
}

export class ExportType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ExportType.attributeTypeMap;
    }
}

export class FieldCalculationTypeUpdatedEvent {
    'calculationType'?: CalculationType;
    'portfolioId'?: string;
    'name'?: string;
    'previousCalculationType'?: CalculationType;
    'id'?: string;
    'fieldType'?: FieldType;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "calculationType",
            "baseName": "calculationType",
            "type": "CalculationType"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "previousCalculationType",
            "baseName": "previousCalculationType",
            "type": "CalculationType"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "FieldType"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldCalculationTypeUpdatedEvent.attributeTypeMap;
    }
}

export class FieldCategoryOptionsUpdatedEvent {
    'fieldName'?: string;
    'portfolioId'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fieldName",
            "baseName": "fieldName",
            "type": "string"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldCategoryOptionsUpdatedEvent.attributeTypeMap;
    }
}

export class FieldCreatedEvent {
    'sourceId'?: string;
    'parent'?: Field;
    'isFieldTypeApproved'?: boolean;
    'isIdeaFieldRequired'?: boolean;
    'typePosition'?: number;
    'dataType'?: DataType;
    'targetType'?: TargetType;
    'isFromImport'?: boolean;
    'originalName'?: string;
    'isIdeaField'?: boolean;
    'portfolioId'?: string;
    'name'?: string;
    'id'?: string;
    'position'?: number;
    'ideaFieldPosition'?: number;
    'fieldType'?: FieldType;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sourceId",
            "baseName": "sourceId",
            "type": "string"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "Field"
        },
        {
            "name": "isFieldTypeApproved",
            "baseName": "isFieldTypeApproved",
            "type": "boolean"
        },
        {
            "name": "isIdeaFieldRequired",
            "baseName": "isIdeaFieldRequired",
            "type": "boolean"
        },
        {
            "name": "typePosition",
            "baseName": "typePosition",
            "type": "number"
        },
        {
            "name": "dataType",
            "baseName": "dataType",
            "type": "DataType"
        },
        {
            "name": "targetType",
            "baseName": "targetType",
            "type": "TargetType"
        },
        {
            "name": "isFromImport",
            "baseName": "isFromImport",
            "type": "boolean"
        },
        {
            "name": "originalName",
            "baseName": "originalName",
            "type": "string"
        },
        {
            "name": "isIdeaField",
            "baseName": "isIdeaField",
            "type": "boolean"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "ideaFieldPosition",
            "baseName": "ideaFieldPosition",
            "type": "number"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "FieldType"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldCreatedEvent.attributeTypeMap;
    }
}

export class FieldCreatedMessagePayload {
    'fields'?: Array<Field>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fields",
            "baseName": "fields",
            "type": "Array<Field>"
        }    ];

    static getAttributeTypeMap() {
        return FieldCreatedMessagePayload.attributeTypeMap;
    }
}

export class FieldDataTypeUpdatedEvent {
    'portfolioId'?: string;
    'previousDataType'?: DataType;
    'dataType'?: DataType;
    'name'?: string;
    'id'?: string;
    'fieldType'?: FieldType;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "previousDataType",
            "baseName": "previousDataType",
            "type": "DataType"
        },
        {
            "name": "dataType",
            "baseName": "dataType",
            "type": "DataType"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "FieldType"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldDataTypeUpdatedEvent.attributeTypeMap;
    }
}

export class FieldDeletedEvent {
    'portfolioId'?: string;
    'name'?: string;
    'id'?: string;
    'fieldType'?: FieldType;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "FieldType"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldDeletedEvent.attributeTypeMap;
    }
}

export class FieldDescriptionUpdatedEvent {
    'portfolioId'?: string;
    'name'?: string;
    'description'?: string;
    'id'?: string;
    'previousDescription'?: string;
    'fieldType'?: FieldType;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "previousDescription",
            "baseName": "previousDescription",
            "type": "string"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "FieldType"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldDescriptionUpdatedEvent.attributeTypeMap;
    }
}

export class FieldGrade {
    'field'?: Field;
    'grade'?: Grade;
    'min'?: number;
    'max'?: number;
    'current'?: number;
    'gradingBoundaries'?: Array<number>;
    'balanceFieldDetails'?: Array<BalanceFieldDetail>;
    'riskFieldDetails'?: Array<RiskFieldDetail>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "grade",
            "baseName": "grade",
            "type": "Grade"
        },
        {
            "name": "min",
            "baseName": "min",
            "type": "number"
        },
        {
            "name": "max",
            "baseName": "max",
            "type": "number"
        },
        {
            "name": "current",
            "baseName": "current",
            "type": "number"
        },
        {
            "name": "gradingBoundaries",
            "baseName": "gradingBoundaries",
            "type": "Array<number>"
        },
        {
            "name": "balanceFieldDetails",
            "baseName": "balanceFieldDetails",
            "type": "Array<BalanceFieldDetail>"
        },
        {
            "name": "riskFieldDetails",
            "baseName": "riskFieldDetails",
            "type": "Array<RiskFieldDetail>"
        }    ];

    static getAttributeTypeMap() {
        return FieldGrade.attributeTypeMap;
    }
}

export class FieldIdeaFieldPositionUpdatedEvent {
    'portfolioId'?: string;
    'name'?: string;
    'previousIdeaFieldPosition'?: number;
    'id'?: string;
    'ideaFieldPosition'?: number;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "previousIdeaFieldPosition",
            "baseName": "previousIdeaFieldPosition",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "ideaFieldPosition",
            "baseName": "ideaFieldPosition",
            "type": "number"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldIdeaFieldPositionUpdatedEvent.attributeTypeMap;
    }
}

export class FieldIsFieldTypeApprovedUpdatedEvent {
    'portfolioId'?: string;
    'isFieldTypeApproved'?: boolean;
    'previousIsFieldTypeApproved'?: boolean;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "isFieldTypeApproved",
            "baseName": "isFieldTypeApproved",
            "type": "boolean"
        },
        {
            "name": "previousIsFieldTypeApproved",
            "baseName": "previousIsFieldTypeApproved",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldIsFieldTypeApprovedUpdatedEvent.attributeTypeMap;
    }
}

export class FieldIsIdeaFieldRequiredUpdatedEvent {
    'portfolioId'?: string;
    'previousIsIdeaFieldRequired'?: boolean;
    'isIdeaFieldRequired'?: boolean;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "previousIsIdeaFieldRequired",
            "baseName": "previousIsIdeaFieldRequired",
            "type": "boolean"
        },
        {
            "name": "isIdeaFieldRequired",
            "baseName": "isIdeaFieldRequired",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldIsIdeaFieldRequiredUpdatedEvent.attributeTypeMap;
    }
}

export class FieldIsIdeaFieldUpdatedEvent {
    'isIdeaField'?: boolean;
    'portfolioId'?: string;
    'name'?: string;
    'id'?: string;
    'previousIsIdeaField'?: boolean;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isIdeaField",
            "baseName": "isIdeaField",
            "type": "boolean"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "previousIsIdeaField",
            "baseName": "previousIsIdeaField",
            "type": "boolean"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldIsIdeaFieldUpdatedEvent.attributeTypeMap;
    }
}

export class FieldNameUpdatedEvent {
    'portfolioId'?: string;
    'previousName'?: string;
    'name'?: string;
    'id'?: string;
    'fieldType'?: FieldType;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "previousName",
            "baseName": "previousName",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "FieldType"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldNameUpdatedEvent.attributeTypeMap;
    }
}

export class FieldPositionUpdatedEvent {
    'portfolioId'?: string;
    'name'?: string;
    'id'?: string;
    'position'?: number;
    'fieldType'?: FieldType;
    'previousPosition'?: number;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "FieldType"
        },
        {
            "name": "previousPosition",
            "baseName": "previousPosition",
            "type": "number"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldPositionUpdatedEvent.attributeTypeMap;
    }
}

export class FieldTagAddedEvent {
    'portfolioId'?: string;
    'tagParentName'?: string;
    'tagId'?: string;
    'tagColor'?: string;
    'name'?: string;
    'id'?: string;
    'tagName'?: string;
    'tagParentId'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "tagParentName",
            "baseName": "tagParentName",
            "type": "string"
        },
        {
            "name": "tagId",
            "baseName": "tagId",
            "type": "string"
        },
        {
            "name": "tagColor",
            "baseName": "tagColor",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "tagName",
            "baseName": "tagName",
            "type": "string"
        },
        {
            "name": "tagParentId",
            "baseName": "tagParentId",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldTagAddedEvent.attributeTypeMap;
    }
}

export class FieldTagRemovedEvent {
    'portfolioId'?: string;
    'tagParentName'?: string;
    'tagId'?: string;
    'tagColor'?: string;
    'name'?: string;
    'id'?: string;
    'tagName'?: string;
    'tagParentId'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "tagParentName",
            "baseName": "tagParentName",
            "type": "string"
        },
        {
            "name": "tagId",
            "baseName": "tagId",
            "type": "string"
        },
        {
            "name": "tagColor",
            "baseName": "tagColor",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "tagName",
            "baseName": "tagName",
            "type": "string"
        },
        {
            "name": "tagParentId",
            "baseName": "tagParentId",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldTagRemovedEvent.attributeTypeMap;
    }
}

export class FieldTargetTypeUpdatedEvent {
    'portfolioId'?: string;
    'name'?: string;
    'targetType'?: TargetType;
    'id'?: string;
    'previousTargetType'?: TargetType;
    'fieldType'?: FieldType;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "targetType",
            "baseName": "targetType",
            "type": "TargetType"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "previousTargetType",
            "baseName": "previousTargetType",
            "type": "TargetType"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "FieldType"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldTargetTypeUpdatedEvent.attributeTypeMap;
    }
}

export class FieldType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return FieldType.attributeTypeMap;
    }
}

export class FieldTypePositionUpdatedEvent {
    'previousTypePosition'?: number;
    'portfolioId'?: string;
    'typePosition'?: number;
    'name'?: string;
    'id'?: string;
    'fieldType'?: FieldType;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "previousTypePosition",
            "baseName": "previousTypePosition",
            "type": "number"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "typePosition",
            "baseName": "typePosition",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "FieldType"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldTypePositionUpdatedEvent.attributeTypeMap;
    }
}

export class FieldTypeUpdatedEvent {
    'portfolioId'?: string;
    'name'?: string;
    'previousFieldType'?: FieldType;
    'id'?: string;
    'fieldType'?: FieldType;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "previousFieldType",
            "baseName": "previousFieldType",
            "type": "FieldType"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "FieldType"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return FieldTypeUpdatedEvent.attributeTypeMap;
    }
}

export class FieldValue {
    'field'?: Field;
    'project'?: Project;
    'value'?: string;
    'numericValue'?: number;
    'booleanValue'?: boolean;
    'numericValues'?: Array<number>;
    'values'?: Array<string>;
    'timePeriod'?: TimePeriod;
    'details'?: FieldValues;
    'createdAt'?: string;
    'modifiedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "project",
            "baseName": "project",
            "type": "Project"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "booleanValue",
            "baseName": "booleanValue",
            "type": "boolean"
        },
        {
            "name": "numericValues",
            "baseName": "numericValues",
            "type": "Array<number>"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<string>"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "TimePeriod"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "FieldValues"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "modifiedAt",
            "baseName": "modifiedAt",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FieldValue.attributeTypeMap;
    }
}

export class FieldValuePatchItem {
    'projectId'?: string;
    'fieldId'?: string;
    'timePeriod'?: TimePeriod;
    'operations'?: Operations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "projectId",
            "baseName": "projectId",
            "type": "string"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "TimePeriod"
        },
        {
            "name": "operations",
            "baseName": "operations",
            "type": "Operations"
        }    ];

    static getAttributeTypeMap() {
        return FieldValuePatchItem.attributeTypeMap;
    }
}

export class FieldValuesCollectionInfo {
    'hasDuplicateValues'?: boolean;
    'hasBlankValues'?: boolean;
    'totalValue'?: number;
    'balanceUniquenessExceeded'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "hasDuplicateValues",
            "baseName": "hasDuplicateValues",
            "type": "boolean"
        },
        {
            "name": "hasBlankValues",
            "baseName": "hasBlankValues",
            "type": "boolean"
        },
        {
            "name": "totalValue",
            "baseName": "totalValue",
            "type": "number"
        },
        {
            "name": "balanceUniquenessExceeded",
            "baseName": "balanceUniquenessExceeded",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FieldValuesCollectionInfo.attributeTypeMap;
    }
}

export class FieldValuesUpdatedMessagePayload {
    'portfolioId'?: string;
    'portfolioPlanId'?: string;
    'fieldValues': Array<FieldValue>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "portfolioPlanId",
            "baseName": "portfolioPlanId",
            "type": "string"
        },
        {
            "name": "fieldValues",
            "baseName": "fieldValues",
            "type": "Array<FieldValue>"
        }    ];

    static getAttributeTypeMap() {
        return FieldValuesUpdatedMessagePayload.attributeTypeMap;
    }
}

export class FieldsDeletedMessagePayload {
    'portfolioId'?: string;
    'fields': Array<Field>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "fields",
            "baseName": "fields",
            "type": "Array<Field>"
        }    ];

    static getAttributeTypeMap() {
        return FieldsDeletedMessagePayload.attributeTypeMap;
    }
}

export class FieldsUpdatedMessagePayload {
    'portfolioId'?: string;
    'fields': Array<Field>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "fields",
            "baseName": "fields",
            "type": "Array<Field>"
        }    ];

    static getAttributeTypeMap() {
        return FieldsUpdatedMessagePayload.attributeTypeMap;
    }
}

export class Grade {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Grade.attributeTypeMap;
    }
}

export class GradingType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GradingType.attributeTypeMap;
    }
}

export class Header {
    'destination': string;
    'username': string;
    'firstName'?: string;
    'lastName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "destination",
            "baseName": "destination",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Header.attributeTypeMap;
    }
}

export class IdeaFormFieldRequest {
    'portfolioId'?: string;
    'fieldIds'?: Array<string>;
    'fieldTypes'?: Array<FieldType>;
    'isIncluded'?: boolean;
    'isRequired'?: boolean;
    'ideaFieldPosition'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "fieldIds",
            "baseName": "fieldIds",
            "type": "Array<string>"
        },
        {
            "name": "fieldTypes",
            "baseName": "fieldTypes",
            "type": "Array<FieldType>"
        },
        {
            "name": "isIncluded",
            "baseName": "isIncluded",
            "type": "boolean"
        },
        {
            "name": "isRequired",
            "baseName": "isRequired",
            "type": "boolean"
        },
        {
            "name": "ideaFieldPosition",
            "baseName": "ideaFieldPosition",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return IdeaFormFieldRequest.attributeTypeMap;
    }
}

export class ImportType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ImportType.attributeTypeMap;
    }
}

export class KloudlessFile {
    'token'?: string;
    'accountId'?: string;
    'fileId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "fileId",
            "baseName": "fileId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KloudlessFile.attributeTypeMap;
    }
}

export class LikertScaleFieldInsight {
    'fieldId'?: string;
    'likertScaleInsights'?: Array<LikertScaleInsight>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        },
        {
            "name": "likertScaleInsights",
            "baseName": "likertScaleInsights",
            "type": "Array<LikertScaleInsight>"
        }    ];

    static getAttributeTypeMap() {
        return LikertScaleFieldInsight.attributeTypeMap;
    }
}

export class LikertScaleInsight {
    'type': LikertScaleType;
    'projectIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "LikertScaleType"
        },
        {
            "name": "projectIds",
            "baseName": "projectIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return LikertScaleInsight.attributeTypeMap;
    }
}

export class LikertScaleType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LikertScaleType.attributeTypeMap;
    }
}

export class Mail {
    'from'?: string;
    'replyTo'?: string;
    'replyToDisplayName'?: string;
    'to'?: Array<string>;
    'cc'?: Array<string>;
    'bcc'?: Array<string>;
    'subject'?: string;
    'message'?: string;
    'templateName'?: string;
    'templateProperties'?: Array<TemplateProperty>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "replyTo",
            "baseName": "replyTo",
            "type": "string"
        },
        {
            "name": "replyToDisplayName",
            "baseName": "replyToDisplayName",
            "type": "string"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "Array<string>"
        },
        {
            "name": "cc",
            "baseName": "cc",
            "type": "Array<string>"
        },
        {
            "name": "bcc",
            "baseName": "bcc",
            "type": "Array<string>"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "templateName",
            "baseName": "templateName",
            "type": "string"
        },
        {
            "name": "templateProperties",
            "baseName": "templateProperties",
            "type": "Array<TemplateProperty>"
        }    ];

    static getAttributeTypeMap() {
        return Mail.attributeTypeMap;
    }
}

export class Mappings {
    'size'?: number;
    'items'?: Array<Mapping>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Mapping>"
        }    ];

    static getAttributeTypeMap() {
        return Mappings.attributeTypeMap;
    }
}

export class Message {
    'type': MessageType;
    'header': Header;
    'payload': any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "MessageType"
        },
        {
            "name": "header",
            "baseName": "header",
            "type": "Header"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Message.attributeTypeMap;
    }
}

export class MessageDestinationType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MessageDestinationType.attributeTypeMap;
    }
}

export class MessageToken {
    'token': string;
    'expirationInMillis': number;
    'destination': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "expirationInMillis",
            "baseName": "expirationInMillis",
            "type": "number"
        },
        {
            "name": "destination",
            "baseName": "destination",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MessageToken.attributeTypeMap;
    }
}

export class MessageType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MessageType.attributeTypeMap;
    }
}

export class MinifiedFieldValue {
    /**
    * Text value
    */
    'v'?: string;
    /**
    * Numeric Value
    */
    'nv'?: number;
    /**
    * Boolean Value
    */
    'bv'?: boolean;
    /**
    * Yearly cost/allocate data
    */
    'yrs'?: { [key: string]: MinifiedYearlyFieldValue; };
    /**
    * Monthly cost/allocate data
    */
    'mns'?: { [key: string]: number; };
    'vs'?: Array<string>;
    'nvs'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "v",
            "baseName": "v",
            "type": "string"
        },
        {
            "name": "nv",
            "baseName": "nv",
            "type": "number"
        },
        {
            "name": "bv",
            "baseName": "bv",
            "type": "boolean"
        },
        {
            "name": "yrs",
            "baseName": "yrs",
            "type": "{ [key: string]: MinifiedYearlyFieldValue; }"
        },
        {
            "name": "mns",
            "baseName": "mns",
            "type": "{ [key: string]: number; }"
        },
        {
            "name": "vs",
            "baseName": "vs",
            "type": "Array<string>"
        },
        {
            "name": "nvs",
            "baseName": "nvs",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return MinifiedFieldValue.attributeTypeMap;
    }
}

export class MinifiedProject {
    /**
    * project id
    */
    'id'?: string;
    /**
    * Project name
    */
    'n'?: string;
    /**
    * Project position
    */
    'pos'?: number;
    /**
    * Project modified time in epoch millis
    */
    'mt'?: number;
    /**
    * Minified field values. Key is field index.
    */
    'fvs'?: { [key: string]: MinifiedFieldValue; };
    /**
    * Contibuting user indices.
    */
    'cus'?: Array<string>;
    /**
    * Has Dependent Ids
    */
    'hdi'?: Array<string>;
    /**
    * Depends on project ids
    */
    'doi'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "n",
            "baseName": "n",
            "type": "string"
        },
        {
            "name": "pos",
            "baseName": "pos",
            "type": "number"
        },
        {
            "name": "mt",
            "baseName": "mt",
            "type": "number"
        },
        {
            "name": "fvs",
            "baseName": "fvs",
            "type": "{ [key: string]: MinifiedFieldValue; }"
        },
        {
            "name": "cus",
            "baseName": "cus",
            "type": "Array<string>"
        },
        {
            "name": "hdi",
            "baseName": "hdi",
            "type": "Array<string>"
        },
        {
            "name": "doi",
            "baseName": "doi",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return MinifiedProject.attributeTypeMap;
    }
}

/**
* Optimized object with minified project data
*/
export class MinifiedProjects {
    /**
    * Field index
    */
    'fidx'?: { [key: string]: string; };
    /**
    * TimePeriod index
    */
    'tidx'?: { [key: string]: number; };
    /**
    * User index
    */
    'uidx'?: { [key: string]: string; };
    /**
    * Minified projects.
    */
    'prs'?: Array<MinifiedProject>;
    /**
    * Total projects count
    */
    'tot'?: number;
    /**
    * pagination limit
    */
    'lim'?: number;
    /**
    * pagination offset
    */
    'ofs'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fidx",
            "baseName": "fidx",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "tidx",
            "baseName": "tidx",
            "type": "{ [key: string]: number; }"
        },
        {
            "name": "uidx",
            "baseName": "uidx",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "prs",
            "baseName": "prs",
            "type": "Array<MinifiedProject>"
        },
        {
            "name": "tot",
            "baseName": "tot",
            "type": "number"
        },
        {
            "name": "lim",
            "baseName": "lim",
            "type": "number"
        },
        {
            "name": "ofs",
            "baseName": "ofs",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MinifiedProjects.attributeTypeMap;
    }
}

/**
* Minified yearly cost/allocate data
*/
export class MinifiedYearlyFieldValue {
    /**
    * Yearly aggregate numeric Value
    */
    'nv'?: number;
    /**
    * Number of monthly values in the year
    */
    'ct'?: number;
    /**
    * TimePeriod index of the first month in the year
    */
    'fmn'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "nv",
            "baseName": "nv",
            "type": "number"
        },
        {
            "name": "ct",
            "baseName": "ct",
            "type": "number"
        },
        {
            "name": "fmn",
            "baseName": "fmn",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MinifiedYearlyFieldValue.attributeTypeMap;
    }
}

export class NotificationsMessagePayload {
    'activities'?: Array<Activity>;
    'portfolioId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activities",
            "baseName": "activities",
            "type": "Array<Activity>"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NotificationsMessagePayload.attributeTypeMap;
    }
}

export class Operation {
    'op': OperationType;
    'from'?: string;
    'path': string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "op",
            "baseName": "op",
            "type": "OperationType"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Operation.attributeTypeMap;
    }
}

export class OperationType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return OperationType.attributeTypeMap;
    }
}

export class Operations extends Array<Operation> {

    static discriminator: string | undefined = undefined;

}

export class PatchItem {
    'id'?: string;
    'operations'?: Operations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "operations",
            "baseName": "operations",
            "type": "Operations"
        }    ];

    static getAttributeTypeMap() {
        return PatchItem.attributeTypeMap;
    }
}

export class Permission {
    'type': PermissionType;
    'fieldIds'?: Array<string>;
    'projectIds'?: Array<string>;
    'enabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "PermissionType"
        },
        {
            "name": "fieldIds",
            "baseName": "fieldIds",
            "type": "Array<string>"
        },
        {
            "name": "projectIds",
            "baseName": "projectIds",
            "type": "Array<string>"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Permission.attributeTypeMap;
    }
}

export class PermissionType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return PermissionType.attributeTypeMap;
    }
}

export class PlanType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return PlanType.attributeTypeMap;
    }
}

export class PortfolioArchivedEvent {
    'portfolioId'?: string;
    'isArchived'?: boolean;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "isArchived",
            "baseName": "isArchived",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioArchivedEvent.attributeTypeMap;
    }
}

export class PortfolioArchivedMessagePayload {
    'portfolio': Portfolio;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolio",
            "baseName": "portfolio",
            "type": "Portfolio"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioArchivedMessagePayload.attributeTypeMap;
    }
}

export class PortfolioBudgetTimePeriodTypeUpdatedEvent {
    'budgetTimePeriodType'?: TimePeriodType;
    'portfolioId'?: string;
    'name'?: string;
    'previousTimePeriodType'?: TimePeriodType;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "budgetTimePeriodType",
            "baseName": "budgetTimePeriodType",
            "type": "TimePeriodType"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "previousTimePeriodType",
            "baseName": "previousTimePeriodType",
            "type": "TimePeriodType"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioBudgetTimePeriodTypeUpdatedEvent.attributeTypeMap;
    }
}

export class PortfolioCreatedEvent {
    'portfolioId'?: string;
    'userRegistrationToken'?: string;
    'isArchived'?: boolean;
    'groupId'?: string;
    'name'?: string;
    'description'?: string;
    'isCombined'?: boolean;
    'attributes'?: Attributes;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "userRegistrationToken",
            "baseName": "userRegistrationToken",
            "type": "string"
        },
        {
            "name": "isArchived",
            "baseName": "isArchived",
            "type": "boolean"
        },
        {
            "name": "groupId",
            "baseName": "groupId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "isCombined",
            "baseName": "isCombined",
            "type": "boolean"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Attributes"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioCreatedEvent.attributeTypeMap;
    }
}

export class PortfolioIsMonthlySpendPlanUpdatedEvent {
    'isMonthlySpendPlan'?: boolean;
    'portfolioId'?: string;
    'name'?: string;
    'id'?: string;
    'previousIsMonthlySpendPlan'?: boolean;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isMonthlySpendPlan",
            "baseName": "isMonthlySpendPlan",
            "type": "boolean"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "previousIsMonthlySpendPlan",
            "baseName": "previousIsMonthlySpendPlan",
            "type": "boolean"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioIsMonthlySpendPlanUpdatedEvent.attributeTypeMap;
    }
}

export class PortfolioNameUpdatedEvent {
    'portfolioId'?: string;
    'previousName'?: string;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "previousName",
            "baseName": "previousName",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioNameUpdatedEvent.attributeTypeMap;
    }
}

export class PortfolioPlanCreatedEvent {
    'portfolioId'?: string;
    'name'?: string;
    'description'?: string;
    'isBaseline'?: boolean;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;
    'parentPortfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "isBaseline",
            "baseName": "isBaseline",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        },
        {
            "name": "parentPortfolioPlan",
            "baseName": "parentPortfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanCreatedEvent.attributeTypeMap;
    }
}

export class PortfolioPlanDataImportedEvent {
    'fileName'?: string;
    'portfolioId'?: string;
    'sheetName'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fileName",
            "baseName": "fileName",
            "type": "string"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "sheetName",
            "baseName": "sheetName",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanDataImportedEvent.attributeTypeMap;
    }
}

export class PortfolioPlanDeletedEvent {
    'portfolioId'?: string;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanDeletedEvent.attributeTypeMap;
    }
}

export class PortfolioPlanDescriptionUpdatedEvent {
    'portfolioId'?: string;
    'description'?: string;
    'id'?: string;
    'previousDescription'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "previousDescription",
            "baseName": "previousDescription",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanDescriptionUpdatedEvent.attributeTypeMap;
    }
}

export class PortfolioPlanGrade {
    'type'?: PlanType;
    'grade'?: Grade;
    'fieldGrades'?: FieldGrades;
    'score'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "PlanType"
        },
        {
            "name": "grade",
            "baseName": "grade",
            "type": "Grade"
        },
        {
            "name": "fieldGrades",
            "baseName": "fieldGrades",
            "type": "FieldGrades"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanGrade.attributeTypeMap;
    }
}

export class PortfolioPlanNameUpdatedEvent {
    'portfolioId'?: string;
    'previousName'?: string;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "previousName",
            "baseName": "previousName",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanNameUpdatedEvent.attributeTypeMap;
    }
}

export class PortfolioPlanRebaselinedEvent {
    'portfolioId'?: string;
    'baselinePortfolioPlanName'?: string;
    'whatIfPortfolioPlan'?: PortfolioPlan;
    'id'?: string;
    'whatIfPortfolioPlanName'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "baselinePortfolioPlanName",
            "baseName": "baselinePortfolioPlanName",
            "type": "string"
        },
        {
            "name": "whatIfPortfolioPlan",
            "baseName": "whatIfPortfolioPlan",
            "type": "PortfolioPlan"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "whatIfPortfolioPlanName",
            "baseName": "whatIfPortfolioPlanName",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanRebaselinedEvent.attributeTypeMap;
    }
}

export class PortfolioPlanUserCreatedMessagePayload {
    'portfolioPlanUser': PortfolioPlanUser;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioPlanUser",
            "baseName": "portfolioPlanUser",
            "type": "PortfolioPlanUser"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanUserCreatedMessagePayload.attributeTypeMap;
    }
}

export class PortfolioPlanUserCreatedV2Event {
    'portfolioPlanUserRoleList'?: Array<PortfolioPlanUserRole>;
    'portfolioId'?: string;
    'permissions'?: Array<Permission>;
    'id'?: string;
    'contributingProjectIds'?: Array<string>;
    'user'?: User;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioPlanUserRoleList",
            "baseName": "portfolioPlanUserRoleList",
            "type": "Array<PortfolioPlanUserRole>"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "permissions",
            "baseName": "permissions",
            "type": "Array<Permission>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "contributingProjectIds",
            "baseName": "contributingProjectIds",
            "type": "Array<string>"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanUserCreatedV2Event.attributeTypeMap;
    }
}

export class PortfolioPlanUserDeletedEvent {
    'portfolioId'?: string;
    'id'?: string;
    'user'?: User;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanUserDeletedEvent.attributeTypeMap;
    }
}

export class PortfolioPlanUserDeletedMessagePayload {
    'portfolioPlanUser': PortfolioPlanUser;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioPlanUser",
            "baseName": "portfolioPlanUser",
            "type": "PortfolioPlanUser"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanUserDeletedMessagePayload.attributeTypeMap;
    }
}

export class PortfolioPlanUserDraftProjectIdsUpdatedEvent {
    'portfolioId'?: string;
    'previousDraftProjectIds'?: Array<string>;
    'id'?: string;
    'user'?: User;
    'draftProjectIds'?: Array<string>;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "previousDraftProjectIds",
            "baseName": "previousDraftProjectIds",
            "type": "Array<string>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "draftProjectIds",
            "baseName": "draftProjectIds",
            "type": "Array<string>"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanUserDraftProjectIdsUpdatedEvent.attributeTypeMap;
    }
}

export class PortfolioPlanUserFieldPermissionsUpdatedEvent {
    'portfolioPlanUserRoleList'?: Array<PortfolioPlanUserRole>;
    'portfolioId'?: string;
    'previousPermissions'?: Array<Permission>;
    'id'?: string;
    'user'?: User;
    'portfolioPlan'?: PortfolioPlan;
    'fieldPermissions'?: Array<Permission>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioPlanUserRoleList",
            "baseName": "portfolioPlanUserRoleList",
            "type": "Array<PortfolioPlanUserRole>"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "previousPermissions",
            "baseName": "previousPermissions",
            "type": "Array<Permission>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        },
        {
            "name": "fieldPermissions",
            "baseName": "fieldPermissions",
            "type": "Array<Permission>"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanUserFieldPermissionsUpdatedEvent.attributeTypeMap;
    }
}

export class PortfolioPlanUserProjectPermissionsUpdatedEvent {
    'portfolioPlanUserRoleList'?: Array<PortfolioPlanUserRole>;
    'projectPermissions'?: Array<Permission>;
    'portfolioId'?: string;
    'previousPermissions'?: Array<Permission>;
    'id'?: string;
    'user'?: User;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioPlanUserRoleList",
            "baseName": "portfolioPlanUserRoleList",
            "type": "Array<PortfolioPlanUserRole>"
        },
        {
            "name": "projectPermissions",
            "baseName": "projectPermissions",
            "type": "Array<Permission>"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "previousPermissions",
            "baseName": "previousPermissions",
            "type": "Array<Permission>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanUserProjectPermissionsUpdatedEvent.attributeTypeMap;
    }
}

export class PortfolioPlanUserRole {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return PortfolioPlanUserRole.attributeTypeMap;
    }
}

export class PortfolioPlanUserRolesUpdatedNewEvent {
    'previousPortfolioPlanUserRoleList'?: Array<PortfolioPlanUserRole>;
    'portfolioPlanUserRoleList'?: Array<PortfolioPlanUserRole>;
    'portfolioId'?: string;
    'id'?: string;
    'user'?: User;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "previousPortfolioPlanUserRoleList",
            "baseName": "previousPortfolioPlanUserRoleList",
            "type": "Array<PortfolioPlanUserRole>"
        },
        {
            "name": "portfolioPlanUserRoleList",
            "baseName": "portfolioPlanUserRoleList",
            "type": "Array<PortfolioPlanUserRole>"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanUserRolesUpdatedNewEvent.attributeTypeMap;
    }
}

export class PortfolioPlanUserUpdatedMessagePayload {
    'portfolioPlanUser': PortfolioPlanUser;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioPlanUser",
            "baseName": "portfolioPlanUser",
            "type": "PortfolioPlanUser"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlanUserUpdatedMessagePayload.attributeTypeMap;
    }
}

export class PortfolioPlanWithProjects extends Array<string> {

    static discriminator: string | undefined = undefined;

}

export class PortfolioPlansUpdatedMessagePayload {
    'portfolioPlans': Array<PortfolioPlan>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioPlans",
            "baseName": "portfolioPlans",
            "type": "Array<PortfolioPlan>"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlansUpdatedMessagePayload.attributeTypeMap;
    }
}

export class PortfolioPlansWithProjects {
    'id'?: string;
    'projects'?: Array<PortfolioPlanWithProjects>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "projects",
            "baseName": "projects",
            "type": "Array<PortfolioPlanWithProjects>"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioPlansWithProjects.attributeTypeMap;
    }
}

export class PortfolioTimeIntervalUpdatedEvent {
    'portfolioId'?: string;
    'previousTimeInterval'?: TimeInterval;
    'name'?: string;
    'timeInterval'?: TimeInterval;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "previousTimeInterval",
            "baseName": "previousTimeInterval",
            "type": "TimeInterval"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "timeInterval",
            "baseName": "timeInterval",
            "type": "TimeInterval"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioTimeIntervalUpdatedEvent.attributeTypeMap;
    }
}

export class PortfolioUpdatedMessagePayload {
    'portfolio': Portfolio;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolio",
            "baseName": "portfolio",
            "type": "Portfolio"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioUpdatedMessagePayload.attributeTypeMap;
    }
}

export class PortfolioUserRegistrationTokenUpdatedEvent {
    'portfolioId'?: string;
    'previousUserRegistrationToken'?: string;
    'userRegistrationToken'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "previousUserRegistrationToken",
            "baseName": "previousUserRegistrationToken",
            "type": "string"
        },
        {
            "name": "userRegistrationToken",
            "baseName": "userRegistrationToken",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return PortfolioUserRegistrationTokenUpdatedEvent.attributeTypeMap;
    }
}

export class ProjectAccessGrantedMessagePayload {
    'projects': Array<Project>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "projects",
            "baseName": "projects",
            "type": "Array<Project>"
        }    ];

    static getAttributeTypeMap() {
        return ProjectAccessGrantedMessagePayload.attributeTypeMap;
    }
}

export class ProjectAccessRevokedMessagePayload {
    'projects': Array<Project>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "projects",
            "baseName": "projects",
            "type": "Array<Project>"
        }    ];

    static getAttributeTypeMap() {
        return ProjectAccessRevokedMessagePayload.attributeTypeMap;
    }
}

export class ProjectAttachmentAddedEvent {
    'attachmentSize'?: number;
    'portfolioId'?: string;
    'name'?: string;
    'attachmentName'?: string;
    'id'?: string;
    'attachmentId'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentSize",
            "baseName": "attachmentSize",
            "type": "number"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "attachmentName",
            "baseName": "attachmentName",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "attachmentId",
            "baseName": "attachmentId",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectAttachmentAddedEvent.attributeTypeMap;
    }
}

export class ProjectAttachmentAddedMessagePayload {
    'attachment': Attachment;
    'portfolioId': string;
    'projectId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachment",
            "baseName": "attachment",
            "type": "Attachment"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "projectId",
            "baseName": "projectId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProjectAttachmentAddedMessagePayload.attributeTypeMap;
    }
}

export class ProjectAttachmentRemovedEvent {
    'attachmentSize'?: number;
    'portfolioId'?: string;
    'name'?: string;
    'attachmentName'?: string;
    'id'?: string;
    'attachmentId'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentSize",
            "baseName": "attachmentSize",
            "type": "number"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "attachmentName",
            "baseName": "attachmentName",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "attachmentId",
            "baseName": "attachmentId",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectAttachmentRemovedEvent.attributeTypeMap;
    }
}

export class ProjectAttachmentRemovedMessagePayload {
    'attachmentId': string;
    'portfolioId': string;
    'projectId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attachmentId",
            "baseName": "attachmentId",
            "type": "string"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "projectId",
            "baseName": "projectId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProjectAttachmentRemovedMessagePayload.attributeTypeMap;
    }
}

export class ProjectContributingUserAddedEvent {
    'portfolioId'?: string;
    'contributingUser'?: User;
    'id'?: string;
    'projectName'?: string;
    'userId'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "contributingUser",
            "baseName": "contributingUser",
            "type": "User"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "projectName",
            "baseName": "projectName",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectContributingUserAddedEvent.attributeTypeMap;
    }
}

export class ProjectContributingUserDeletedEvent {
    'portfolioId'?: string;
    'contributingUser'?: User;
    'id'?: string;
    'projectName'?: string;
    'userId'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "contributingUser",
            "baseName": "contributingUser",
            "type": "User"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "projectName",
            "baseName": "projectName",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectContributingUserDeletedEvent.attributeTypeMap;
    }
}

export class ProjectContributorsUpdatedMessagePayload {
    'projects': Array<Project>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "projects",
            "baseName": "projects",
            "type": "Array<Project>"
        }    ];

    static getAttributeTypeMap() {
        return ProjectContributorsUpdatedMessagePayload.attributeTypeMap;
    }
}

export class ProjectCreatedEvent {
    'portfolioId'?: string;
    'contributingUserIds'?: Array<string>;
    'name'?: string;
    'isDraft'?: boolean;
    'id'?: string;
    'position'?: number;
    'fieldValues'?: Array<ProjectFieldValue>;
    'userId'?: string;
    'portfolioPlan'?: PortfolioPlan;
    'isFromImport'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "contributingUserIds",
            "baseName": "contributingUserIds",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "isDraft",
            "baseName": "isDraft",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "fieldValues",
            "baseName": "fieldValues",
            "type": "Array<ProjectFieldValue>"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        },
        {
            "name": "isFromImport",
            "baseName": "isFromImport",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ProjectCreatedEvent.attributeTypeMap;
    }
}

export class ProjectDeletedEvent {
    'portfolioId'?: string;
    'contributingUserIds'?: Array<string>;
    'name'?: string;
    'isDraft'?: boolean;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "contributingUserIds",
            "baseName": "contributingUserIds",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "isDraft",
            "baseName": "isDraft",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectDeletedEvent.attributeTypeMap;
    }
}

export class ProjectDependenciesUpdatedMessagePayload {
    'projects': Projects;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "projects",
            "baseName": "projects",
            "type": "Projects"
        }    ];

    static getAttributeTypeMap() {
        return ProjectDependenciesUpdatedMessagePayload.attributeTypeMap;
    }
}

export class ProjectDependsOnAddedEvent {
    'portfolioId'?: string;
    'dependsOnProject'?: Project;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "dependsOnProject",
            "baseName": "dependsOnProject",
            "type": "Project"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectDependsOnAddedEvent.attributeTypeMap;
    }
}

export class ProjectDependsOnRemovedEvent {
    'portfolioId'?: string;
    'dependsOnProject'?: Project;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "dependsOnProject",
            "baseName": "dependsOnProject",
            "type": "Project"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectDependsOnRemovedEvent.attributeTypeMap;
    }
}

export class ProjectFieldValue {
    'field'?: Field;
    'value'?: string;
    'numericValue'?: number;
    'timePeriod'?: TimePeriod;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "TimePeriod"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectFieldValue.attributeTypeMap;
    }
}

export class ProjectFieldValueDeletedEvent {
    'portfolioId'?: string;
    'field'?: Field;
    'name'?: string;
    'timePeriod'?: TimePeriod;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "TimePeriod"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectFieldValueDeletedEvent.attributeTypeMap;
    }
}

export class ProjectFieldValueUpdatedEvent {
    'portfolioId'?: string;
    'field'?: Field;
    'name'?: string;
    'timePeriod'?: TimePeriod;
    'numericValue'?: number;
    'id'?: string;
    'previousNumericValue'?: number;
    'isRebaseline'?: boolean;
    'value'?: string;
    'previousValue'?: string;
    'portfolioPlan'?: PortfolioPlan;
    'isFromImport'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "TimePeriod"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "previousNumericValue",
            "baseName": "previousNumericValue",
            "type": "number"
        },
        {
            "name": "isRebaseline",
            "baseName": "isRebaseline",
            "type": "boolean"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "previousValue",
            "baseName": "previousValue",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        },
        {
            "name": "isFromImport",
            "baseName": "isFromImport",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ProjectFieldValueUpdatedEvent.attributeTypeMap;
    }
}

export class ProjectPortfolioPlanDeletedEvent {
    'portfolioId'?: string;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectPortfolioPlanDeletedEvent.attributeTypeMap;
    }
}

export class ProjectPortfolioPlanFieldValueDeletedEvent {
    'portfolioId'?: string;
    'field'?: Field;
    'name'?: string;
    'timePeriod'?: TimePeriod;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "TimePeriod"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectPortfolioPlanFieldValueDeletedEvent.attributeTypeMap;
    }
}

export class ProjectPortfolioPlanFieldValueUpdatedEvent {
    'portfolioId'?: string;
    'field'?: Field;
    'name'?: string;
    'timePeriod'?: TimePeriod;
    'numericValue'?: number;
    'id'?: string;
    'previousNumericValue'?: number;
    'isRebaseline'?: boolean;
    'value'?: string;
    'previousValue'?: string;
    'portfolioPlan'?: PortfolioPlan;
    'isFromImport'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "TimePeriod"
        },
        {
            "name": "numericValue",
            "baseName": "numericValue",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "previousNumericValue",
            "baseName": "previousNumericValue",
            "type": "number"
        },
        {
            "name": "isRebaseline",
            "baseName": "isRebaseline",
            "type": "boolean"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "previousValue",
            "baseName": "previousValue",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        },
        {
            "name": "isFromImport",
            "baseName": "isFromImport",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ProjectPortfolioPlanFieldValueUpdatedEvent.attributeTypeMap;
    }
}

export class ProjectPortfolioPlanFieldValuesCopiedEvent {
    'portfolioId'?: string;
    'fromPortfolioPlan'?: PortfolioPlan;
    'name'?: string;
    'id'?: string;
    'fieldValues'?: Array<ProjectFieldValue>;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "fromPortfolioPlan",
            "baseName": "fromPortfolioPlan",
            "type": "PortfolioPlan"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "fieldValues",
            "baseName": "fieldValues",
            "type": "Array<ProjectFieldValue>"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectPortfolioPlanFieldValuesCopiedEvent.attributeTypeMap;
    }
}

export class ProjectPortfolioPlanIsDraftUpdatedEvent {
    'previousIsDraft'?: boolean;
    'portfolioId'?: string;
    'name'?: string;
    'isDraft'?: boolean;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "previousIsDraft",
            "baseName": "previousIsDraft",
            "type": "boolean"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "isDraft",
            "baseName": "isDraft",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectPortfolioPlanIsDraftUpdatedEvent.attributeTypeMap;
    }
}

export class ProjectSummary {
    'id'?: string;
    'name'?: string;
    'request'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "request",
            "baseName": "request",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ProjectSummary.attributeTypeMap;
    }
}

export class ProjectTagAddedEvent {
    'portfolioId'?: string;
    'tagParentName'?: string;
    'tagId'?: string;
    'tagColor'?: string;
    'name'?: string;
    'id'?: string;
    'tagName'?: string;
    'tagParentId'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "tagParentName",
            "baseName": "tagParentName",
            "type": "string"
        },
        {
            "name": "tagId",
            "baseName": "tagId",
            "type": "string"
        },
        {
            "name": "tagColor",
            "baseName": "tagColor",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "tagName",
            "baseName": "tagName",
            "type": "string"
        },
        {
            "name": "tagParentId",
            "baseName": "tagParentId",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectTagAddedEvent.attributeTypeMap;
    }
}

export class ProjectTagRemovedEvent {
    'portfolioId'?: string;
    'tagParentName'?: string;
    'tagId'?: string;
    'tagColor'?: string;
    'name'?: string;
    'id'?: string;
    'tagName'?: string;
    'tagParentId'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "tagParentName",
            "baseName": "tagParentName",
            "type": "string"
        },
        {
            "name": "tagId",
            "baseName": "tagId",
            "type": "string"
        },
        {
            "name": "tagColor",
            "baseName": "tagColor",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "tagName",
            "baseName": "tagName",
            "type": "string"
        },
        {
            "name": "tagParentId",
            "baseName": "tagParentId",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ProjectTagRemovedEvent.attributeTypeMap;
    }
}

export class ProjectsCreatedMessagePayload {
    'projects': Array<Project>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "projects",
            "baseName": "projects",
            "type": "Array<Project>"
        }    ];

    static getAttributeTypeMap() {
        return ProjectsCreatedMessagePayload.attributeTypeMap;
    }
}

export class ProjectsDeletedMessagePayload {
    'projects': Array<Project>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "projects",
            "baseName": "projects",
            "type": "Array<Project>"
        }    ];

    static getAttributeTypeMap() {
        return ProjectsDeletedMessagePayload.attributeTypeMap;
    }
}

export class Property {
    'name'?: PropertyName;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "PropertyName"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Property.attributeTypeMap;
    }
}

export class PropertyName {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return PropertyName.attributeTypeMap;
    }
}

export class Recommendation {
    'type'?: RecommendationType;
    'fieldValues'?: FieldValues;
    'portfolioPlanGrades'?: PortfolioPlanGrades;
    'project'?: Project;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "RecommendationType"
        },
        {
            "name": "fieldValues",
            "baseName": "fieldValues",
            "type": "FieldValues"
        },
        {
            "name": "portfolioPlanGrades",
            "baseName": "portfolioPlanGrades",
            "type": "PortfolioPlanGrades"
        },
        {
            "name": "project",
            "baseName": "project",
            "type": "Project"
        }    ];

    static getAttributeTypeMap() {
        return Recommendation.attributeTypeMap;
    }
}

export class RecommendationType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RecommendationType.attributeTypeMap;
    }
}

export class RegisterUserRequest {
    'userRegistrationToken': string;
    'emailId'?: string;
    'landingPage'?: string;
    'doNotNotify'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userRegistrationToken",
            "baseName": "userRegistrationToken",
            "type": "string"
        },
        {
            "name": "emailId",
            "baseName": "emailId",
            "type": "string"
        },
        {
            "name": "landingPage",
            "baseName": "landingPage",
            "type": "string"
        },
        {
            "name": "doNotNotify",
            "baseName": "doNotNotify",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RegisterUserRequest.attributeTypeMap;
    }
}

export class RemoveContributingUsersRequest {
    'contributingUserIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contributingUserIds",
            "baseName": "contributingUserIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return RemoveContributingUsersRequest.attributeTypeMap;
    }
}

export class RemovedFromPortfolioMessagePayload {
    'portfolio': Portfolio;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolio",
            "baseName": "portfolio",
            "type": "Portfolio"
        }    ];

    static getAttributeTypeMap() {
        return RemovedFromPortfolioMessagePayload.attributeTypeMap;
    }
}

export class RemovedFromPortfolioPlanMessagePayload {
    'portfolioPlan': PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return RemovedFromPortfolioPlanMessagePayload.attributeTypeMap;
    }
}

export class ResourcePoolBudgetAmount {
    'resourcePool'?: ResourcePool;
    'timePeriod'?: TimePeriod;
    'amount'?: number;
    'baselineAmount'?: number;
    'details'?: ResourcePoolBudgetAmounts;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resourcePool",
            "baseName": "resourcePool",
            "type": "ResourcePool"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "TimePeriod"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "baselineAmount",
            "baseName": "baselineAmount",
            "type": "number"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "ResourcePoolBudgetAmounts"
        }    ];

    static getAttributeTypeMap() {
        return ResourcePoolBudgetAmount.attributeTypeMap;
    }
}

export class ResourcePoolBudgetAmountPatchItem {
    'resourcePoolId'?: string;
    'timePeriod'?: TimePeriod;
    'operations'?: Operations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resourcePoolId",
            "baseName": "resourcePoolId",
            "type": "string"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "TimePeriod"
        },
        {
            "name": "operations",
            "baseName": "operations",
            "type": "Operations"
        }    ];

    static getAttributeTypeMap() {
        return ResourcePoolBudgetAmountPatchItem.attributeTypeMap;
    }
}

export class ResourcePoolBudgetAmountUpdatedEvent {
    'portfolioId'?: string;
    'budgetAmount'?: number;
    'name'?: string;
    'timePeriod'?: TimePeriod;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;
    'previousBudgetAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "budgetAmount",
            "baseName": "budgetAmount",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "TimePeriod"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        },
        {
            "name": "previousBudgetAmount",
            "baseName": "previousBudgetAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResourcePoolBudgetAmountUpdatedEvent.attributeTypeMap;
    }
}

export class ResourcePoolCreatedEvent {
    'portfolioId'?: string;
    'field'?: Field;
    'name'?: string;
    'id'?: string;
    'budgetAmounts'?: Array<ResourcePoolBudgetAmount>;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "budgetAmounts",
            "baseName": "budgetAmounts",
            "type": "Array<ResourcePoolBudgetAmount>"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ResourcePoolCreatedEvent.attributeTypeMap;
    }
}

export class ResourcePoolDeletedEvent {
    'portfolioId'?: string;
    'field'?: Field;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ResourcePoolDeletedEvent.attributeTypeMap;
    }
}

export class ResourcePoolNameUpdatedEvent {
    'portfolioId'?: string;
    'previousName'?: string;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "previousName",
            "baseName": "previousName",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ResourcePoolNameUpdatedEvent.attributeTypeMap;
    }
}

export class ResourcePoolPlanBudgetAmountUpdatedEvent {
    'portfolioId'?: string;
    'budgetAmount'?: number;
    'name'?: string;
    'timePeriod'?: TimePeriod;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;
    'previousBudgetAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "budgetAmount",
            "baseName": "budgetAmount",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "TimePeriod"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        },
        {
            "name": "previousBudgetAmount",
            "baseName": "previousBudgetAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResourcePoolPlanBudgetAmountUpdatedEvent.attributeTypeMap;
    }
}

export class ResourcePoolPlanBudgetCopiedEvent {
    'portfolioId'?: string;
    'fromPortfolioPlan'?: PortfolioPlan;
    'name'?: string;
    'id'?: string;
    'budgetAmounts'?: Array<ResourcePoolBudgetAmount>;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "fromPortfolioPlan",
            "baseName": "fromPortfolioPlan",
            "type": "PortfolioPlan"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "budgetAmounts",
            "baseName": "budgetAmounts",
            "type": "Array<ResourcePoolBudgetAmount>"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return ResourcePoolPlanBudgetCopiedEvent.attributeTypeMap;
    }
}

export class ResourcePoolsCreatedMessagePayload {
    'resourcePools': Array<ResourcePool>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resourcePools",
            "baseName": "resourcePools",
            "type": "Array<ResourcePool>"
        }    ];

    static getAttributeTypeMap() {
        return ResourcePoolsCreatedMessagePayload.attributeTypeMap;
    }
}

export class ResourcePoolsDeletedMessagePayload {
    'resourcePools': Array<ResourcePool>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resourcePools",
            "baseName": "resourcePools",
            "type": "Array<ResourcePool>"
        }    ];

    static getAttributeTypeMap() {
        return ResourcePoolsDeletedMessagePayload.attributeTypeMap;
    }
}

export class ResourcePoolsUpdatedMessagePayload {
    'resourcePools': Array<ResourcePool>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resourcePools",
            "baseName": "resourcePools",
            "type": "Array<ResourcePool>"
        }    ];

    static getAttributeTypeMap() {
        return ResourcePoolsUpdatedMessagePayload.attributeTypeMap;
    }
}

export class RiskFieldDetail {
    'type'?: RiskType;
    'projectCount'?: number;
    'allocation'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "RiskType"
        },
        {
            "name": "projectCount",
            "baseName": "projectCount",
            "type": "number"
        },
        {
            "name": "allocation",
            "baseName": "allocation",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RiskFieldDetail.attributeTypeMap;
    }
}

export class RiskType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RiskType.attributeTypeMap;
    }
}

export class RoleType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RoleType.attributeTypeMap;
    }
}

export class Row {
    'size'?: number;
    'columns'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "columns",
            "baseName": "columns",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Row.attributeTypeMap;
    }
}

export class SchedulingCriteria {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SchedulingCriteria.attributeTypeMap;
    }
}

export class SetDependenciesRequest {
    'dependsOnProjectIds'?: Array<string>;
    'hasDependentProjectIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dependsOnProjectIds",
            "baseName": "dependsOnProjectIds",
            "type": "Array<string>"
        },
        {
            "name": "hasDependentProjectIds",
            "baseName": "hasDependentProjectIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return SetDependenciesRequest.attributeTypeMap;
    }
}

export class Sheet {
    'name'?: string;
    'rows'?: Array<Row>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "rows",
            "baseName": "rows",
            "type": "Array<Row>"
        }    ];

    static getAttributeTypeMap() {
        return Sheet.attributeTypeMap;
    }
}

export class SourceCreatedEvent {
    'sourceType'?: SourceType;
    'name'?: string;
    'dlcPortfolio'?: DlcPortfolio;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sourceType",
            "baseName": "sourceType",
            "type": "SourceType"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "dlcPortfolio",
            "baseName": "dlcPortfolio",
            "type": "DlcPortfolio"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return SourceCreatedEvent.attributeTypeMap;
    }
}

export class SourceDeletedEvent {
    'sourceType'?: SourceType;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sourceType",
            "baseName": "sourceType",
            "type": "SourceType"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return SourceDeletedEvent.attributeTypeMap;
    }
}

export class SourceNameUpdatedEvent {
    'sourceType'?: SourceType;
    'previousName'?: string;
    'name'?: string;
    'id'?: string;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sourceType",
            "baseName": "sourceType",
            "type": "SourceType"
        },
        {
            "name": "previousName",
            "baseName": "previousName",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return SourceNameUpdatedEvent.attributeTypeMap;
    }
}

export class SourceType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SourceType.attributeTypeMap;
    }
}

export class SpreadsheetReport {
    'portfolioId'?: string;
    'spreadsheetId'?: string;
    'sheetName'?: string;
    'newProjects'?: Projects;
    'newFields'?: Fields;
    'updateProjectFieldValuesCount'?: number;
    'updateProjects'?: Projects;
    'warnings'?: Warnings;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "spreadsheetId",
            "baseName": "spreadsheetId",
            "type": "string"
        },
        {
            "name": "sheetName",
            "baseName": "sheetName",
            "type": "string"
        },
        {
            "name": "newProjects",
            "baseName": "newProjects",
            "type": "Projects"
        },
        {
            "name": "newFields",
            "baseName": "newFields",
            "type": "Fields"
        },
        {
            "name": "updateProjectFieldValuesCount",
            "baseName": "updateProjectFieldValuesCount",
            "type": "number"
        },
        {
            "name": "updateProjects",
            "baseName": "updateProjects",
            "type": "Projects"
        },
        {
            "name": "warnings",
            "baseName": "warnings",
            "type": "Warnings"
        }    ];

    static getAttributeTypeMap() {
        return SpreadsheetReport.attributeTypeMap;
    }
}

export class SpreadsheetReportProgress {
    'status'?: SpreadsheetReportProgressStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "SpreadsheetReportProgressStatus"
        }    ];

    static getAttributeTypeMap() {
        return SpreadsheetReportProgress.attributeTypeMap;
    }
}

export class SpreadsheetReportProgressMessagePayload {
    'portfolioId'?: string;
    'spreadsheetId'?: string;
    'sheetName'?: string;
    'newFields'?: SpreadsheetReportProgress;
    'newProjects'?: SpreadsheetReportProgress;
    'updateProjects'?: SpreadsheetReportProgress;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "spreadsheetId",
            "baseName": "spreadsheetId",
            "type": "string"
        },
        {
            "name": "sheetName",
            "baseName": "sheetName",
            "type": "string"
        },
        {
            "name": "newFields",
            "baseName": "newFields",
            "type": "SpreadsheetReportProgress"
        },
        {
            "name": "newProjects",
            "baseName": "newProjects",
            "type": "SpreadsheetReportProgress"
        },
        {
            "name": "updateProjects",
            "baseName": "updateProjects",
            "type": "SpreadsheetReportProgress"
        }    ];

    static getAttributeTypeMap() {
        return SpreadsheetReportProgressMessagePayload.attributeTypeMap;
    }
}

export class SpreadsheetReportProgressStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SpreadsheetReportProgressStatus.attributeTypeMap;
    }
}

export class SubPortfolioAddedEvent {
    'portfolioId'?: string;
    'subPortfolio'?: Portfolio;
    'name'?: string;
    'id'?: string;
    'position'?: number;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "subPortfolio",
            "baseName": "subPortfolio",
            "type": "Portfolio"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return SubPortfolioAddedEvent.attributeTypeMap;
    }
}

export class SubPortfolioRemovedEvent {
    'portfolioId'?: string;
    'subPortfolio'?: Portfolio;
    'name'?: string;
    'id'?: string;
    'position'?: number;
    'portfolioPlan'?: PortfolioPlan;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "subPortfolio",
            "baseName": "subPortfolio",
            "type": "Portfolio"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        }    ];

    static getAttributeTypeMap() {
        return SubPortfolioRemovedEvent.attributeTypeMap;
    }
}

export class TagAddedMessagePayload {
    'tag': Tag;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tag",
            "baseName": "tag",
            "type": "Tag"
        }    ];

    static getAttributeTypeMap() {
        return TagAddedMessagePayload.attributeTypeMap;
    }
}

export class TagColorUpdatedEvent {
    'portfolioId'?: string;
    'color'?: string;
    'name'?: string;
    'id'?: string;
    'previousColor'?: string;
    'parentId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "previousColor",
            "baseName": "previousColor",
            "type": "string"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TagColorUpdatedEvent.attributeTypeMap;
    }
}

export class TagCreatedEvent {
    'portfolioId'?: string;
    'color'?: string;
    'name'?: string;
    'id'?: string;
    'parentId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TagCreatedEvent.attributeTypeMap;
    }
}

export class TagDeletedEvent {
    'portfolioId'?: string;
    'color'?: string;
    'name'?: string;
    'id'?: string;
    'parentId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TagDeletedEvent.attributeTypeMap;
    }
}

export class TagDeletedMessagePayload {
    'tag': Tag;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tag",
            "baseName": "tag",
            "type": "Tag"
        }    ];

    static getAttributeTypeMap() {
        return TagDeletedMessagePayload.attributeTypeMap;
    }
}

export class TagNameUpdatedEvent {
    'portfolioId'?: string;
    'color'?: string;
    'previousName'?: string;
    'name'?: string;
    'id'?: string;
    'parentId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "previousName",
            "baseName": "previousName",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TagNameUpdatedEvent.attributeTypeMap;
    }
}

export class TagParentUpdatedEvent {
    'portfolioId'?: string;
    'color'?: string;
    'name'?: string;
    'previousParentId'?: string;
    'id'?: string;
    'parentId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "previousParentId",
            "baseName": "previousParentId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TagParentUpdatedEvent.attributeTypeMap;
    }
}

export class TagUpdatedMessagePayload {
    'tag': Tag;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tag",
            "baseName": "tag",
            "type": "Tag"
        }    ];

    static getAttributeTypeMap() {
        return TagUpdatedMessagePayload.attributeTypeMap;
    }
}

export class TargetType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TargetType.attributeTypeMap;
    }
}

export class TemplateProperty {
    'name'?: string;
    'value'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return TemplateProperty.attributeTypeMap;
    }
}

export class TimeInterval {
    'startMonth'?: number;
    'type'?: TimePeriodType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startMonth",
            "baseName": "startMonth",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "TimePeriodType"
        }    ];

    static getAttributeTypeMap() {
        return TimeInterval.attributeTypeMap;
    }
}

export class TimePeriod {
    'startDate'?: number;
    'type'?: TimePeriodType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "TimePeriodType"
        }    ];

    static getAttributeTypeMap() {
        return TimePeriod.attributeTypeMap;
    }
}

export class TimePeriodType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TimePeriodType.attributeTypeMap;
    }
}

export class ToastMessagePayload {
    'message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ToastMessagePayload.attributeTypeMap;
    }
}

export class UserAddedEvent {
    'id'?: string;
    'username'?: string;
    'addedByUser'?: User;
    'groupId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "addedByUser",
            "baseName": "addedByUser",
            "type": "User"
        },
        {
            "name": "groupId",
            "baseName": "groupId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserAddedEvent.attributeTypeMap;
    }
}

export class UserApprovalAddedEvent {
    'id'?: string;
    'user'?: User;
    'clientId'?: string;
    'groupId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "groupId",
            "baseName": "groupId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserApprovalAddedEvent.attributeTypeMap;
    }
}

export class UserAuthenticatedEvent {
    'id'?: string;
    'user'?: User;
    'clientId'?: string;
    'groupId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "groupId",
            "baseName": "groupId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserAuthenticatedEvent.attributeTypeMap;
    }
}

export class UserGroupAddedEvent {
    'id'?: string;
    'user'?: User;
    'addedByUser'?: User;
    'groupId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "addedByUser",
            "baseName": "addedByUser",
            "type": "User"
        },
        {
            "name": "groupId",
            "baseName": "groupId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserGroupAddedEvent.attributeTypeMap;
    }
}

export class UserRegistrationToken {
    /**
    * portfolio id
    */
    'portfolioId'?: string;
    'group'?: Group;
    /**
    * portfolio plan user role
    */
    'role'?: PortfolioPlanUserRole;
    'expiresAt'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "Group"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "PortfolioPlanUserRole"
        },
        {
            "name": "expiresAt",
            "baseName": "expiresAt",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UserRegistrationToken.attributeTypeMap;
    }
}

export class UserStatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return UserStatus.attributeTypeMap;
    }
}

export class ValidConstraintValue {
    'field'?: Field;
    'minCost'?: number;
    'maxCost'?: number;
    'totalCost'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "minCost",
            "baseName": "minCost",
            "type": "number"
        },
        {
            "name": "maxCost",
            "baseName": "maxCost",
            "type": "number"
        },
        {
            "name": "totalCost",
            "baseName": "totalCost",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ValidConstraintValue.attributeTypeMap;
    }
}

export class ValueCount {
    'value'?: string;
    'count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ValueCount.attributeTypeMap;
    }
}

export class ValueInsights {
    'likertScaleFieldInsights'?: Array<LikertScaleFieldInsight>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "likertScaleFieldInsights",
            "baseName": "likertScaleFieldInsights",
            "type": "Array<LikertScaleFieldInsight>"
        }    ];

    static getAttributeTypeMap() {
        return ValueInsights.attributeTypeMap;
    }
}

export class Warnings {
    'size'?: number;
    'messages'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "messages",
            "baseName": "messages",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Warnings.attributeTypeMap;
    }
}

export class WhatsIn {
    'projectSummaries'?: Array<ProjectSummary>;
    'portfolioPlansWithProjects'?: Array<PortfolioPlansWithProjects>;
    'maxSize'?: number;
    'maxLimit'?: number;
    'offset'?: number;
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "projectSummaries",
            "baseName": "projectSummaries",
            "type": "Array<ProjectSummary>"
        },
        {
            "name": "portfolioPlansWithProjects",
            "baseName": "portfolioPlansWithProjects",
            "type": "Array<PortfolioPlansWithProjects>"
        },
        {
            "name": "maxSize",
            "baseName": "maxSize",
            "type": "number"
        },
        {
            "name": "maxLimit",
            "baseName": "maxLimit",
            "type": "number"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WhatsIn.attributeTypeMap;
    }
}

export class Wiwo {
    'inProjects'?: Projects;
    'outProjects'?: Projects;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "inProjects",
            "baseName": "inProjects",
            "type": "Projects"
        },
        {
            "name": "outProjects",
            "baseName": "outProjects",
            "type": "Projects"
        }    ];

    static getAttributeTypeMap() {
        return Wiwo.attributeTypeMap;
    }
}

export class Activities extends DlCollection {
    'items'?: Array<Activity>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Activity>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Activities.attributeTypeMap);
    }
}

export class Activity extends DlResource {
    'type'?: ActivityType;
    'user'?: User;
    'data'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "ActivityType"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Activity.attributeTypeMap);
    }
}

export class Attachment extends DlResource {
    'name'?: string;
    'size'?: number;
    'user'?: User;
    'portfolioId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Attachment.attributeTypeMap);
    }
}

export class Attachments extends DlCollection {
    'items'?: Array<Attachment>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Attachment>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Attachments.attributeTypeMap);
    }
}

export class BudgetAllocations extends DlCollection {
    'portfolioPlan'?: PortfolioPlan;
    'timePeriodType'?: TimePeriodType;
    'yearlyStartTime'?: number;
    'monthlyStartTime'?: number;
    'items'?: Array<BudgetAllocation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        },
        {
            "name": "timePeriodType",
            "baseName": "timePeriodType",
            "type": "TimePeriodType"
        },
        {
            "name": "yearlyStartTime",
            "baseName": "yearlyStartTime",
            "type": "number"
        },
        {
            "name": "monthlyStartTime",
            "baseName": "monthlyStartTime",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<BudgetAllocation>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BudgetAllocations.attributeTypeMap);
    }
}

export class CategoryOption extends DlResource {
    'name'?: string;
    'portfolioId'?: string;
    'fieldId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CategoryOption.attributeTypeMap);
    }
}

export class CategoryOptions extends DlCollection {
    'items'?: Array<CategoryOption>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<CategoryOption>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CategoryOptions.attributeTypeMap);
    }
}

export class Classifications extends DlCollection {
    'items'?: Array<Classification>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Classification>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Classifications.attributeTypeMap);
    }
}

export class Comment extends DlResource {
    'portfolioId'?: string;
    'projectId'?: string;
    'user'?: User;
    'value'?: string;
    'contributorsAdded'?: Array<PortfolioPlanUser>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        },
        {
            "name": "projectId",
            "baseName": "projectId",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "contributorsAdded",
            "baseName": "contributorsAdded",
            "type": "Array<PortfolioPlanUser>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Comment.attributeTypeMap);
    }
}

export class Comments extends DlCollection {
    'items'?: Array<Comment>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Comment>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Comments.attributeTypeMap);
    }
}

export class Constraint extends DlResource {
    'type'?: ConstraintType;
    'isActive'?: boolean;
    'percentage'?: number;
    'fixedCost'?: number;
    'field'?: Field;
    'projects'?: Projects;
    'portfolio'?: Portfolio;
    'validValues'?: Array<ValidConstraintValue>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "ConstraintType"
        },
        {
            "name": "isActive",
            "baseName": "isActive",
            "type": "boolean"
        },
        {
            "name": "percentage",
            "baseName": "percentage",
            "type": "number"
        },
        {
            "name": "fixedCost",
            "baseName": "fixedCost",
            "type": "number"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        },
        {
            "name": "projects",
            "baseName": "projects",
            "type": "Projects"
        },
        {
            "name": "portfolio",
            "baseName": "portfolio",
            "type": "Portfolio"
        },
        {
            "name": "validValues",
            "baseName": "validValues",
            "type": "Array<ValidConstraintValue>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Constraint.attributeTypeMap);
    }
}

export class Constraints extends DlCollection {
    'items'?: Array<Constraint>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Constraint>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Constraints.attributeTypeMap);
    }
}

export class CustomNames extends DlCollection {
    'items'?: Array<CustomName>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<CustomName>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CustomNames.attributeTypeMap);
    }
}

export class Field extends DlResource {
    'name'?: string;
    'description'?: string;
    'type'?: FieldType;
    'source'?: Source;
    'portfolio'?: Portfolio;
    'parent'?: Field;
    'position'?: number;
    'typePosition'?: number;
    'fieldValues'?: FieldValues;
    'targetType'?: TargetType;
    'dataType'?: DataType;
    'calculationType'?: CalculationType;
    'isFieldTypeApproved'?: boolean;
    'tagIds'?: Array<string>;
    'categoryOptions'?: CategoryOptions;
    'isIdeaField'?: boolean;
    'ideaFieldPosition'?: number;
    'isIdeaFieldRequired'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "FieldType"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "Source"
        },
        {
            "name": "portfolio",
            "baseName": "portfolio",
            "type": "Portfolio"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "Field"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "typePosition",
            "baseName": "typePosition",
            "type": "number"
        },
        {
            "name": "fieldValues",
            "baseName": "fieldValues",
            "type": "FieldValues"
        },
        {
            "name": "targetType",
            "baseName": "targetType",
            "type": "TargetType"
        },
        {
            "name": "dataType",
            "baseName": "dataType",
            "type": "DataType"
        },
        {
            "name": "calculationType",
            "baseName": "calculationType",
            "type": "CalculationType"
        },
        {
            "name": "isFieldTypeApproved",
            "baseName": "isFieldTypeApproved",
            "type": "boolean"
        },
        {
            "name": "tagIds",
            "baseName": "tagIds",
            "type": "Array<string>"
        },
        {
            "name": "categoryOptions",
            "baseName": "categoryOptions",
            "type": "CategoryOptions"
        },
        {
            "name": "isIdeaField",
            "baseName": "isIdeaField",
            "type": "boolean"
        },
        {
            "name": "ideaFieldPosition",
            "baseName": "ideaFieldPosition",
            "type": "number"
        },
        {
            "name": "isIdeaFieldRequired",
            "baseName": "isIdeaFieldRequired",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Field.attributeTypeMap);
    }
}

export class FieldGrades extends DlCollection {
    'items'?: Array<FieldGrade>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<FieldGrade>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FieldGrades.attributeTypeMap);
    }
}

export class FieldValues extends DlCollection {
    'items'?: Array<FieldValue>;
    'collectionInfo'?: FieldValuesCollectionInfo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<FieldValue>"
        },
        {
            "name": "collectionInfo",
            "baseName": "collectionInfo",
            "type": "FieldValuesCollectionInfo"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FieldValues.attributeTypeMap);
    }
}

export class Fields extends DlCollection {
    'items'?: Array<Field>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Field>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Fields.attributeTypeMap);
    }
}

export class FileAttachment extends DlResource {
    'fileContent'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fileContent",
            "baseName": "fileContent",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FileAttachment.attributeTypeMap);
    }
}

export class Group extends DlResource {
    'name'?: string;
    'domain'?: string;
    'isActive'?: boolean;
    'users'?: Users;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "isActive",
            "baseName": "isActive",
            "type": "boolean"
        },
        {
            "name": "users",
            "baseName": "users",
            "type": "Users"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Group.attributeTypeMap);
    }
}

export class Groups extends DlCollection {
    'items'?: Array<Group>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Group>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Groups.attributeTypeMap);
    }
}

export class Mapping extends DlResource {
    'name'?: string;
    'originalName'?: string;
    'type'?: FieldType;
    'targetType'?: TargetType;
    'dataType'?: DataType;
    'position'?: number;
    'values'?: Array<string>;
    'numericValues'?: Array<number>;
    'booleanValues'?: Array<boolean>;
    'timePeriod'?: TimePeriod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "originalName",
            "baseName": "originalName",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "FieldType"
        },
        {
            "name": "targetType",
            "baseName": "targetType",
            "type": "TargetType"
        },
        {
            "name": "dataType",
            "baseName": "dataType",
            "type": "DataType"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<string>"
        },
        {
            "name": "numericValues",
            "baseName": "numericValues",
            "type": "Array<number>"
        },
        {
            "name": "booleanValues",
            "baseName": "booleanValues",
            "type": "Array<boolean>"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "TimePeriod"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Mapping.attributeTypeMap);
    }
}

export class Permissions extends DlCollection {
    'items'?: Array<Permission>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Permission>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Permissions.attributeTypeMap);
    }
}

export class PlanGrade extends DlResource {
    'type'?: PlanType;
    'grade'?: Grade;
    'fieldGrades'?: FieldGrades;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "PlanType"
        },
        {
            "name": "grade",
            "baseName": "grade",
            "type": "Grade"
        },
        {
            "name": "fieldGrades",
            "baseName": "fieldGrades",
            "type": "FieldGrades"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PlanGrade.attributeTypeMap);
    }
}

export class Portfolio extends DlResource {
    'name'?: string;
    'description'?: string;
    'isArchived'?: boolean;
    'baselinePortfolioPlanUser'?: PortfolioPlanUser;
    'fields'?: Fields;
    'projects'?: Projects;
    'portfolioPlans'?: PortfolioPlans;
    'portfolioPlanUsers'?: PortfolioPlanUsers;
    'attributes'?: Attributes;
    'isCombined'?: boolean;
    /**
    * user registration token string
    */
    'userRegistrationToken'?: string;
    'subPortfolios'?: Array<Portfolio>;
    'combinedPortfolios'?: Array<Portfolio>;
    'resourcePools'?: ResourcePools;
    'totalBudget'?: number;
    'newNotificationsCount'?: number;
    'customNames'?: CustomNames;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "isArchived",
            "baseName": "isArchived",
            "type": "boolean"
        },
        {
            "name": "baselinePortfolioPlanUser",
            "baseName": "baselinePortfolioPlanUser",
            "type": "PortfolioPlanUser"
        },
        {
            "name": "fields",
            "baseName": "fields",
            "type": "Fields"
        },
        {
            "name": "projects",
            "baseName": "projects",
            "type": "Projects"
        },
        {
            "name": "portfolioPlans",
            "baseName": "portfolioPlans",
            "type": "PortfolioPlans"
        },
        {
            "name": "portfolioPlanUsers",
            "baseName": "portfolioPlanUsers",
            "type": "PortfolioPlanUsers"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Attributes"
        },
        {
            "name": "isCombined",
            "baseName": "isCombined",
            "type": "boolean"
        },
        {
            "name": "userRegistrationToken",
            "baseName": "userRegistrationToken",
            "type": "string"
        },
        {
            "name": "subPortfolios",
            "baseName": "subPortfolios",
            "type": "Array<Portfolio>"
        },
        {
            "name": "combinedPortfolios",
            "baseName": "combinedPortfolios",
            "type": "Array<Portfolio>"
        },
        {
            "name": "resourcePools",
            "baseName": "resourcePools",
            "type": "ResourcePools"
        },
        {
            "name": "totalBudget",
            "baseName": "totalBudget",
            "type": "number"
        },
        {
            "name": "newNotificationsCount",
            "baseName": "newNotificationsCount",
            "type": "number"
        },
        {
            "name": "customNames",
            "baseName": "customNames",
            "type": "CustomNames"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Portfolio.attributeTypeMap);
    }
}

export class PortfolioPlan extends DlResource {
    'name'?: string;
    'isBaseline'?: boolean;
    'portfolio'?: Portfolio;
    'parentPortfolioPlan'?: PortfolioPlan;
    'portfolioPlanUsers'?: PortfolioPlanUsers;
    'currentPortfolioPlanUser'?: PortfolioPlanUser;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "isBaseline",
            "baseName": "isBaseline",
            "type": "boolean"
        },
        {
            "name": "portfolio",
            "baseName": "portfolio",
            "type": "Portfolio"
        },
        {
            "name": "parentPortfolioPlan",
            "baseName": "parentPortfolioPlan",
            "type": "PortfolioPlan"
        },
        {
            "name": "portfolioPlanUsers",
            "baseName": "portfolioPlanUsers",
            "type": "PortfolioPlanUsers"
        },
        {
            "name": "currentPortfolioPlanUser",
            "baseName": "currentPortfolioPlanUser",
            "type": "PortfolioPlanUser"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PortfolioPlan.attributeTypeMap);
    }
}

export class PortfolioPlanGrades extends DlCollection {
    'items'?: Array<PortfolioPlanGrade>;
    'portfolio'?: Portfolio;
    'details'?: Array<PortfolioPlanGrades>;
    'gradingType'?: GradingType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<PortfolioPlanGrade>"
        },
        {
            "name": "portfolio",
            "baseName": "portfolio",
            "type": "Portfolio"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PortfolioPlanGrades>"
        },
        {
            "name": "gradingType",
            "baseName": "gradingType",
            "type": "GradingType"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PortfolioPlanGrades.attributeTypeMap);
    }
}

export class PortfolioPlanInsights extends DlResource {
    'statusCounts'?: Array<ValueCount>;
    'budget'?: number;
    'allocation'?: number;
    'portfolio'?: Portfolio;
    'details'?: Array<PortfolioPlanInsights>;
    'costBudgetAllocation'?: Array<CostBudgetAllocation>;
    'valueInsights'?: ValueInsights;
    'wiwo'?: Wiwo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "statusCounts",
            "baseName": "statusCounts",
            "type": "Array<ValueCount>"
        },
        {
            "name": "budget",
            "baseName": "budget",
            "type": "number"
        },
        {
            "name": "allocation",
            "baseName": "allocation",
            "type": "number"
        },
        {
            "name": "portfolio",
            "baseName": "portfolio",
            "type": "Portfolio"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PortfolioPlanInsights>"
        },
        {
            "name": "costBudgetAllocation",
            "baseName": "costBudgetAllocation",
            "type": "Array<CostBudgetAllocation>"
        },
        {
            "name": "valueInsights",
            "baseName": "valueInsights",
            "type": "ValueInsights"
        },
        {
            "name": "wiwo",
            "baseName": "wiwo",
            "type": "Wiwo"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PortfolioPlanInsights.attributeTypeMap);
    }
}

export class PortfolioPlanUser extends DlResource {
    'user': User;
    'portfolioPlan'?: PortfolioPlan;
    'roles'?: Array<PortfolioPlanUserRole>;
    'fieldPermissions'?: Permissions;
    'projectPermissions'?: Permissions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "portfolioPlan",
            "baseName": "portfolioPlan",
            "type": "PortfolioPlan"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "Array<PortfolioPlanUserRole>"
        },
        {
            "name": "fieldPermissions",
            "baseName": "fieldPermissions",
            "type": "Permissions"
        },
        {
            "name": "projectPermissions",
            "baseName": "projectPermissions",
            "type": "Permissions"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PortfolioPlanUser.attributeTypeMap);
    }
}

export class PortfolioPlanUsers extends DlCollection {
    'items'?: Array<PortfolioPlanUser>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<PortfolioPlanUser>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PortfolioPlanUsers.attributeTypeMap);
    }
}

export class PortfolioPlans extends DlCollection {
    'items'?: Array<PortfolioPlan>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<PortfolioPlan>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PortfolioPlans.attributeTypeMap);
    }
}

export class Portfolios extends DlCollection {
    'items'?: Array<Portfolio>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Portfolio>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Portfolios.attributeTypeMap);
    }
}

export class Project extends DlResource {
    'name'?: string;
    'position'?: number;
    'fieldValues'?: FieldValues;
    'dependsOnProjectIds'?: Array<string>;
    'hasDependentProjectIds'?: Array<string>;
    'contributingUserIds'?: Array<string>;
    'isDraft'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "fieldValues",
            "baseName": "fieldValues",
            "type": "FieldValues"
        },
        {
            "name": "dependsOnProjectIds",
            "baseName": "dependsOnProjectIds",
            "type": "Array<string>"
        },
        {
            "name": "hasDependentProjectIds",
            "baseName": "hasDependentProjectIds",
            "type": "Array<string>"
        },
        {
            "name": "contributingUserIds",
            "baseName": "contributingUserIds",
            "type": "Array<string>"
        },
        {
            "name": "isDraft",
            "baseName": "isDraft",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Project.attributeTypeMap);
    }
}

export class Projects extends DlCollection {
    'items'?: Array<Project>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Project>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Projects.attributeTypeMap);
    }
}

export class Properties extends DlCollection {
    'items'?: Array<Property>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Property>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Properties.attributeTypeMap);
    }
}

export class Recommendations extends DlCollection {
    'portfolioPlanId'?: string;
    'items'?: Array<Recommendation>;
    'initialPortfolioPlanGrades'?: PortfolioPlanGrades;
    'scheduleResultInfo'?: string;
    'overconstrainedMessage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "portfolioPlanId",
            "baseName": "portfolioPlanId",
            "type": "string"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Recommendation>"
        },
        {
            "name": "initialPortfolioPlanGrades",
            "baseName": "initialPortfolioPlanGrades",
            "type": "PortfolioPlanGrades"
        },
        {
            "name": "scheduleResultInfo",
            "baseName": "scheduleResultInfo",
            "type": "string"
        },
        {
            "name": "overconstrainedMessage",
            "baseName": "overconstrainedMessage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Recommendations.attributeTypeMap);
    }
}

export class ResourcePool extends DlResource {
    'name'?: string;
    'budgetAmounts'?: ResourcePoolBudgetAmounts;
    'field'?: Field;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "budgetAmounts",
            "baseName": "budgetAmounts",
            "type": "ResourcePoolBudgetAmounts"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "Field"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ResourcePool.attributeTypeMap);
    }
}

export class ResourcePoolBudgetAmounts extends DlCollection {
    'items'?: Array<ResourcePoolBudgetAmount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<ResourcePoolBudgetAmount>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ResourcePoolBudgetAmounts.attributeTypeMap);
    }
}

export class ResourcePools extends DlCollection {
    'items'?: Array<ResourcePool>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<ResourcePool>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ResourcePools.attributeTypeMap);
    }
}

export class Sheets extends DlCollection {
    'items'?: Array<Sheet>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Sheet>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Sheets.attributeTypeMap);
    }
}

export class Source extends DlResource {
    'name'?: string;
    'type': SourceType;
    'portfolio'?: Portfolio;
    'fields'?: Fields;
    'projects'?: Projects;
    'dlcPortfolio'?: DlcPortfolio;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "SourceType"
        },
        {
            "name": "portfolio",
            "baseName": "portfolio",
            "type": "Portfolio"
        },
        {
            "name": "fields",
            "baseName": "fields",
            "type": "Fields"
        },
        {
            "name": "projects",
            "baseName": "projects",
            "type": "Projects"
        },
        {
            "name": "dlcPortfolio",
            "baseName": "dlcPortfolio",
            "type": "DlcPortfolio"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Source.attributeTypeMap);
    }
}

export class Spreadsheet extends DlResource {
    'name'?: string;
    'sheets'?: Sheets;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "sheets",
            "baseName": "sheets",
            "type": "Sheets"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Spreadsheet.attributeTypeMap);
    }
}

export class Tag extends DlResource {
    'name'?: string;
    'color'?: string;
    'parentId'?: string;
    'isDefault'?: boolean;
    'portfolioId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        },
        {
            "name": "isDefault",
            "baseName": "isDefault",
            "type": "boolean"
        },
        {
            "name": "portfolioId",
            "baseName": "portfolioId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Tag.attributeTypeMap);
    }
}

export class Tags extends DlCollection {
    'items'?: Array<Tag>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Tag>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Tags.attributeTypeMap);
    }
}

export class User extends DlResource {
    'username'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'status'?: UserStatus;
    'isLocked'?: boolean;
    'invitationUrl'?: string;
    'invitationUrlExpiration'?: number;
    'role'?: RoleType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "UserStatus"
        },
        {
            "name": "isLocked",
            "baseName": "isLocked",
            "type": "boolean"
        },
        {
            "name": "invitationUrl",
            "baseName": "invitationUrl",
            "type": "string"
        },
        {
            "name": "invitationUrlExpiration",
            "baseName": "invitationUrlExpiration",
            "type": "number"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "RoleType"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(User.attributeTypeMap);
    }
}

export class Users extends DlCollection {
    'items'?: Array<User>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<User>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Users.attributeTypeMap);
    }
}

export class ValueCounts extends DlCollection {
    'items'?: Array<ValueCount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<ValueCount>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ValueCounts.attributeTypeMap);
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "AccessTokenGeneratedEvent": AccessTokenGeneratedEvent,
    "ActivityType": ActivityType,
    "AddUserRequest": AddUserRequest,
    "AddUsersRequest": AddUsersRequest,
    "AddedToPortfolioMessagePayload": AddedToPortfolioMessagePayload,
    "AddedToPortfolioPlanMessagePayload": AddedToPortfolioPlanMessagePayload,
    "AttachmentCreatedEvent": AttachmentCreatedEvent,
    "AttachmentDeletedEvent": AttachmentDeletedEvent,
    "AttachmentNameUpdatedEvent": AttachmentNameUpdatedEvent,
    "AttachmentUpdatedMessagePayload": AttachmentUpdatedMessagePayload,
    "Attributes": Attributes,
    "AuthorizationCodeGeneratedEvent": AuthorizationCodeGeneratedEvent,
    "BalanceFieldDetail": BalanceFieldDetail,
    "BudgetAllocation": BudgetAllocation,
    "CalculationType": CalculationType,
    "CategoryOptionAddedMessagePayload": CategoryOptionAddedMessagePayload,
    "CategoryOptionCreatedEvent": CategoryOptionCreatedEvent,
    "CategoryOptionDeletedEvent": CategoryOptionDeletedEvent,
    "CategoryOptionDeletedMessagePayload": CategoryOptionDeletedMessagePayload,
    "CategoryOptionNameUpdatedEvent": CategoryOptionNameUpdatedEvent,
    "CategoryOptionUpdatedMessagePayload": CategoryOptionUpdatedMessagePayload,
    "Classification": Classification,
    "CommentAddedEvent": CommentAddedEvent,
    "CommentAddedMessagePayload": CommentAddedMessagePayload,
    "CommentDeletedEvent": CommentDeletedEvent,
    "CommentDeletedMessagePayload": CommentDeletedMessagePayload,
    "CommentEditedEvent": CommentEditedEvent,
    "CommentEditedMessagePayload": CommentEditedMessagePayload,
    "ConstraintType": ConstraintType,
    "CostBudgetAllocation": CostBudgetAllocation,
    "CustomName": CustomName,
    "CustomNameAddedEvent": CustomNameAddedEvent,
    "CustomNameDeletedEvent": CustomNameDeletedEvent,
    "CustomNameGroupType": CustomNameGroupType,
    "CustomNameType": CustomNameType,
    "CustomNameUpdatedEvent": CustomNameUpdatedEvent,
    "CustomNamesUpdatedMessagePayload": CustomNamesUpdatedMessagePayload,
    "DataType": DataType,
    "DataUpdatedMessagePayload": DataUpdatedMessagePayload,
    "DlCollection": DlCollection,
    "DlResource": DlResource,
    "DlcPortfolio": DlcPortfolio,
    "DraftProjectsSubmittedMessagePayload": DraftProjectsSubmittedMessagePayload,
    "ErrorResponse": ErrorResponse,
    "ExpandComponent": ExpandComponent,
    "ExportFormatType": ExportFormatType,
    "ExportType": ExportType,
    "FieldCalculationTypeUpdatedEvent": FieldCalculationTypeUpdatedEvent,
    "FieldCategoryOptionsUpdatedEvent": FieldCategoryOptionsUpdatedEvent,
    "FieldCreatedEvent": FieldCreatedEvent,
    "FieldCreatedMessagePayload": FieldCreatedMessagePayload,
    "FieldDataTypeUpdatedEvent": FieldDataTypeUpdatedEvent,
    "FieldDeletedEvent": FieldDeletedEvent,
    "FieldDescriptionUpdatedEvent": FieldDescriptionUpdatedEvent,
    "FieldGrade": FieldGrade,
    "FieldIdeaFieldPositionUpdatedEvent": FieldIdeaFieldPositionUpdatedEvent,
    "FieldIsFieldTypeApprovedUpdatedEvent": FieldIsFieldTypeApprovedUpdatedEvent,
    "FieldIsIdeaFieldRequiredUpdatedEvent": FieldIsIdeaFieldRequiredUpdatedEvent,
    "FieldIsIdeaFieldUpdatedEvent": FieldIsIdeaFieldUpdatedEvent,
    "FieldNameUpdatedEvent": FieldNameUpdatedEvent,
    "FieldPositionUpdatedEvent": FieldPositionUpdatedEvent,
    "FieldTagAddedEvent": FieldTagAddedEvent,
    "FieldTagRemovedEvent": FieldTagRemovedEvent,
    "FieldTargetTypeUpdatedEvent": FieldTargetTypeUpdatedEvent,
    "FieldType": FieldType,
    "FieldTypePositionUpdatedEvent": FieldTypePositionUpdatedEvent,
    "FieldTypeUpdatedEvent": FieldTypeUpdatedEvent,
    "FieldValue": FieldValue,
    "FieldValuePatchItem": FieldValuePatchItem,
    "FieldValuesCollectionInfo": FieldValuesCollectionInfo,
    "FieldValuesUpdatedMessagePayload": FieldValuesUpdatedMessagePayload,
    "FieldsDeletedMessagePayload": FieldsDeletedMessagePayload,
    "FieldsUpdatedMessagePayload": FieldsUpdatedMessagePayload,
    "Grade": Grade,
    "GradingType": GradingType,
    "Header": Header,
    "IdeaFormFieldRequest": IdeaFormFieldRequest,
    "ImportType": ImportType,
    "KloudlessFile": KloudlessFile,
    "LikertScaleFieldInsight": LikertScaleFieldInsight,
    "LikertScaleInsight": LikertScaleInsight,
    "LikertScaleType": LikertScaleType,
    "Mail": Mail,
    "Mappings": Mappings,
    "Message": Message,
    "MessageDestinationType": MessageDestinationType,
    "MessageToken": MessageToken,
    "MessageType": MessageType,
    "MinifiedFieldValue": MinifiedFieldValue,
    "MinifiedProject": MinifiedProject,
    "MinifiedProjects": MinifiedProjects,
    "MinifiedYearlyFieldValue": MinifiedYearlyFieldValue,
    "NotificationsMessagePayload": NotificationsMessagePayload,
    "Operation": Operation,
    "OperationType": OperationType,
    "Operations": Operations,
    "PatchItem": PatchItem,
    "Permission": Permission,
    "PermissionType": PermissionType,
    "PlanType": PlanType,
    "PortfolioArchivedEvent": PortfolioArchivedEvent,
    "PortfolioArchivedMessagePayload": PortfolioArchivedMessagePayload,
    "PortfolioBudgetTimePeriodTypeUpdatedEvent": PortfolioBudgetTimePeriodTypeUpdatedEvent,
    "PortfolioCreatedEvent": PortfolioCreatedEvent,
    "PortfolioIsMonthlySpendPlanUpdatedEvent": PortfolioIsMonthlySpendPlanUpdatedEvent,
    "PortfolioNameUpdatedEvent": PortfolioNameUpdatedEvent,
    "PortfolioPlanCreatedEvent": PortfolioPlanCreatedEvent,
    "PortfolioPlanDataImportedEvent": PortfolioPlanDataImportedEvent,
    "PortfolioPlanDeletedEvent": PortfolioPlanDeletedEvent,
    "PortfolioPlanDescriptionUpdatedEvent": PortfolioPlanDescriptionUpdatedEvent,
    "PortfolioPlanGrade": PortfolioPlanGrade,
    "PortfolioPlanNameUpdatedEvent": PortfolioPlanNameUpdatedEvent,
    "PortfolioPlanRebaselinedEvent": PortfolioPlanRebaselinedEvent,
    "PortfolioPlanUserCreatedMessagePayload": PortfolioPlanUserCreatedMessagePayload,
    "PortfolioPlanUserCreatedV2Event": PortfolioPlanUserCreatedV2Event,
    "PortfolioPlanUserDeletedEvent": PortfolioPlanUserDeletedEvent,
    "PortfolioPlanUserDeletedMessagePayload": PortfolioPlanUserDeletedMessagePayload,
    "PortfolioPlanUserDraftProjectIdsUpdatedEvent": PortfolioPlanUserDraftProjectIdsUpdatedEvent,
    "PortfolioPlanUserFieldPermissionsUpdatedEvent": PortfolioPlanUserFieldPermissionsUpdatedEvent,
    "PortfolioPlanUserProjectPermissionsUpdatedEvent": PortfolioPlanUserProjectPermissionsUpdatedEvent,
    "PortfolioPlanUserRole": PortfolioPlanUserRole,
    "PortfolioPlanUserRolesUpdatedNewEvent": PortfolioPlanUserRolesUpdatedNewEvent,
    "PortfolioPlanUserUpdatedMessagePayload": PortfolioPlanUserUpdatedMessagePayload,
    "PortfolioPlanWithProjects": PortfolioPlanWithProjects,
    "PortfolioPlansUpdatedMessagePayload": PortfolioPlansUpdatedMessagePayload,
    "PortfolioPlansWithProjects": PortfolioPlansWithProjects,
    "PortfolioTimeIntervalUpdatedEvent": PortfolioTimeIntervalUpdatedEvent,
    "PortfolioUpdatedMessagePayload": PortfolioUpdatedMessagePayload,
    "PortfolioUserRegistrationTokenUpdatedEvent": PortfolioUserRegistrationTokenUpdatedEvent,
    "ProjectAccessGrantedMessagePayload": ProjectAccessGrantedMessagePayload,
    "ProjectAccessRevokedMessagePayload": ProjectAccessRevokedMessagePayload,
    "ProjectAttachmentAddedEvent": ProjectAttachmentAddedEvent,
    "ProjectAttachmentAddedMessagePayload": ProjectAttachmentAddedMessagePayload,
    "ProjectAttachmentRemovedEvent": ProjectAttachmentRemovedEvent,
    "ProjectAttachmentRemovedMessagePayload": ProjectAttachmentRemovedMessagePayload,
    "ProjectContributingUserAddedEvent": ProjectContributingUserAddedEvent,
    "ProjectContributingUserDeletedEvent": ProjectContributingUserDeletedEvent,
    "ProjectContributorsUpdatedMessagePayload": ProjectContributorsUpdatedMessagePayload,
    "ProjectCreatedEvent": ProjectCreatedEvent,
    "ProjectDeletedEvent": ProjectDeletedEvent,
    "ProjectDependenciesUpdatedMessagePayload": ProjectDependenciesUpdatedMessagePayload,
    "ProjectDependsOnAddedEvent": ProjectDependsOnAddedEvent,
    "ProjectDependsOnRemovedEvent": ProjectDependsOnRemovedEvent,
    "ProjectFieldValue": ProjectFieldValue,
    "ProjectFieldValueDeletedEvent": ProjectFieldValueDeletedEvent,
    "ProjectFieldValueUpdatedEvent": ProjectFieldValueUpdatedEvent,
    "ProjectPortfolioPlanDeletedEvent": ProjectPortfolioPlanDeletedEvent,
    "ProjectPortfolioPlanFieldValueDeletedEvent": ProjectPortfolioPlanFieldValueDeletedEvent,
    "ProjectPortfolioPlanFieldValueUpdatedEvent": ProjectPortfolioPlanFieldValueUpdatedEvent,
    "ProjectPortfolioPlanFieldValuesCopiedEvent": ProjectPortfolioPlanFieldValuesCopiedEvent,
    "ProjectPortfolioPlanIsDraftUpdatedEvent": ProjectPortfolioPlanIsDraftUpdatedEvent,
    "ProjectSummary": ProjectSummary,
    "ProjectTagAddedEvent": ProjectTagAddedEvent,
    "ProjectTagRemovedEvent": ProjectTagRemovedEvent,
    "ProjectsCreatedMessagePayload": ProjectsCreatedMessagePayload,
    "ProjectsDeletedMessagePayload": ProjectsDeletedMessagePayload,
    "Property": Property,
    "PropertyName": PropertyName,
    "Recommendation": Recommendation,
    "RecommendationType": RecommendationType,
    "RegisterUserRequest": RegisterUserRequest,
    "RemoveContributingUsersRequest": RemoveContributingUsersRequest,
    "RemovedFromPortfolioMessagePayload": RemovedFromPortfolioMessagePayload,
    "RemovedFromPortfolioPlanMessagePayload": RemovedFromPortfolioPlanMessagePayload,
    "ResourcePoolBudgetAmount": ResourcePoolBudgetAmount,
    "ResourcePoolBudgetAmountPatchItem": ResourcePoolBudgetAmountPatchItem,
    "ResourcePoolBudgetAmountUpdatedEvent": ResourcePoolBudgetAmountUpdatedEvent,
    "ResourcePoolCreatedEvent": ResourcePoolCreatedEvent,
    "ResourcePoolDeletedEvent": ResourcePoolDeletedEvent,
    "ResourcePoolNameUpdatedEvent": ResourcePoolNameUpdatedEvent,
    "ResourcePoolPlanBudgetAmountUpdatedEvent": ResourcePoolPlanBudgetAmountUpdatedEvent,
    "ResourcePoolPlanBudgetCopiedEvent": ResourcePoolPlanBudgetCopiedEvent,
    "ResourcePoolsCreatedMessagePayload": ResourcePoolsCreatedMessagePayload,
    "ResourcePoolsDeletedMessagePayload": ResourcePoolsDeletedMessagePayload,
    "ResourcePoolsUpdatedMessagePayload": ResourcePoolsUpdatedMessagePayload,
    "RiskFieldDetail": RiskFieldDetail,
    "RiskType": RiskType,
    "RoleType": RoleType,
    "Row": Row,
    "SchedulingCriteria": SchedulingCriteria,
    "SetDependenciesRequest": SetDependenciesRequest,
    "Sheet": Sheet,
    "SourceCreatedEvent": SourceCreatedEvent,
    "SourceDeletedEvent": SourceDeletedEvent,
    "SourceNameUpdatedEvent": SourceNameUpdatedEvent,
    "SourceType": SourceType,
    "SpreadsheetReport": SpreadsheetReport,
    "SpreadsheetReportProgress": SpreadsheetReportProgress,
    "SpreadsheetReportProgressMessagePayload": SpreadsheetReportProgressMessagePayload,
    "SpreadsheetReportProgressStatus": SpreadsheetReportProgressStatus,
    "SubPortfolioAddedEvent": SubPortfolioAddedEvent,
    "SubPortfolioRemovedEvent": SubPortfolioRemovedEvent,
    "TagAddedMessagePayload": TagAddedMessagePayload,
    "TagColorUpdatedEvent": TagColorUpdatedEvent,
    "TagCreatedEvent": TagCreatedEvent,
    "TagDeletedEvent": TagDeletedEvent,
    "TagDeletedMessagePayload": TagDeletedMessagePayload,
    "TagNameUpdatedEvent": TagNameUpdatedEvent,
    "TagParentUpdatedEvent": TagParentUpdatedEvent,
    "TagUpdatedMessagePayload": TagUpdatedMessagePayload,
    "TargetType": TargetType,
    "TemplateProperty": TemplateProperty,
    "TimeInterval": TimeInterval,
    "TimePeriod": TimePeriod,
    "TimePeriodType": TimePeriodType,
    "ToastMessagePayload": ToastMessagePayload,
    "UserAddedEvent": UserAddedEvent,
    "UserApprovalAddedEvent": UserApprovalAddedEvent,
    "UserAuthenticatedEvent": UserAuthenticatedEvent,
    "UserGroupAddedEvent": UserGroupAddedEvent,
    "UserRegistrationToken": UserRegistrationToken,
    "UserStatus": UserStatus,
    "ValidConstraintValue": ValidConstraintValue,
    "ValueCount": ValueCount,
    "ValueInsights": ValueInsights,
    "Warnings": Warnings,
    "WhatsIn": WhatsIn,
    "Wiwo": Wiwo,
    "Activities": Activities,
    "Activity": Activity,
    "Attachment": Attachment,
    "Attachments": Attachments,
    "BudgetAllocations": BudgetAllocations,
    "CategoryOption": CategoryOption,
    "CategoryOptions": CategoryOptions,
    "Classifications": Classifications,
    "Comment": Comment,
    "Comments": Comments,
    "Constraint": Constraint,
    "Constraints": Constraints,
    "CustomNames": CustomNames,
    "Field": Field,
    "FieldGrades": FieldGrades,
    "FieldValues": FieldValues,
    "Fields": Fields,
    "FileAttachment": FileAttachment,
    "Group": Group,
    "Groups": Groups,
    "Mapping": Mapping,
    "Permissions": Permissions,
    "PlanGrade": PlanGrade,
    "Portfolio": Portfolio,
    "PortfolioPlan": PortfolioPlan,
    "PortfolioPlanGrades": PortfolioPlanGrades,
    "PortfolioPlanInsights": PortfolioPlanInsights,
    "PortfolioPlanUser": PortfolioPlanUser,
    "PortfolioPlanUsers": PortfolioPlanUsers,
    "PortfolioPlans": PortfolioPlans,
    "Portfolios": Portfolios,
    "Project": Project,
    "Projects": Projects,
    "Properties": Properties,
    "Recommendations": Recommendations,
    "ResourcePool": ResourcePool,
    "ResourcePoolBudgetAmounts": ResourcePoolBudgetAmounts,
    "ResourcePools": ResourcePools,
    "Sheets": Sheets,
    "Source": Source,
    "Spreadsheet": Spreadsheet,
    "Tag": Tag,
    "Tags": Tags,
    "User": User,
    "Users": Users,
    "ValueCounts": ValueCounts,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum ActivitiesApiApiKeys {
}

export class ActivitiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ActivitiesApiApiKeys, value: string) {
        (this.authentications as any)[ActivitiesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Reindex activities. System Administator operation.
     * @param domains List of domains for where activities need to be reindexed, if not provided reindex will be done for all domains
     * @param {*} [options] Override http request options.
     */
    public reindexActivities (domains?: Array<string>, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/reindex/activities';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (domains !== undefined) {
            localVarQueryParameters['domains'] = ObjectSerializer.serialize(domains, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApiActivityApiApiKeys {
}

export class ApiActivityApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApiActivityApiApiKeys, value: string) {
        (this.authentications as any)[ApiActivityApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Reset last API Acitivity time
     * @param {*} [options] Override http request options.
     */
    public resetApiActivityTime (options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/apiActivity/reset';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AttachmentsApiApiKeys {
}

export class AttachmentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AttachmentsApiApiKeys, value: string) {
        (this.authentications as any)[AttachmentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Creates a new attachment from a file upload
     * @param file File to be uploaded
     * @param portfolioId the portfolio id that the attachment belongs to
     * @param {*} [options] Override http request options.
     */
    public createAttachment (file: Buffer, portfolioId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Attachment;  }> {
        const localVarPath = this.basePath + '/attachments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling createAttachment.');
        }

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling createAttachment.');
        }

        if (portfolioId !== undefined) {
            localVarQueryParameters['portfolioId'] = ObjectSerializer.serialize(portfolioId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Attachment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Attachment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Downloads the file content of an Attachment
     * @param id Attachment id
     * @param {*} [options] Override http request options.
     */
    public downloadAttachment (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/attachments/{id}/download'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling downloadAttachment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Attachment by id
     * @param id Attachment id
     * @param {*} [options] Override http request options.
     */
    public getAttachment (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Attachment;  }> {
        const localVarPath = this.basePath + '/attachments/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAttachment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Attachment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Attachment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get Attachment by portfolio id
     * @param portfolioId Portfolio id
     * @param offset Pagination offset
     * @param limit Pagination limit
     * @param orderBy Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getAttachments (portfolioId: string, offset?: number, limit?: number, orderBy?: string, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/attachments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling getAttachments.');
        }

        if (portfolioId !== undefined) {
            localVarQueryParameters['portfolioId'] = ObjectSerializer.serialize(portfolioId, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Attachments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Attachments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a single attachment
     * @param id Attachment ID
     * @param body JSON Patch operations to update value field.
     * @param {*} [options] Override http request options.
     */
    public updateAttachment (id: string, body: Operations, options: any = {}) : Promise<{ response: http.ClientResponse; body: Attachment;  }> {
        const localVarPath = this.basePath + '/attachments/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateAttachment.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateAttachment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Operations")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Attachment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Attachment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ClassificationApiApiKeys {
}

export class ClassificationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ClassificationApiApiKeys, value: string) {
        (this.authentications as any)[ClassificationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Fetch classification training or testing data.
     * @param dataType dataType can be either training or testing
     * @param {*} [options] Override http request options.
     */
    public getClassificationData (dataType: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Classifications;  }> {
        const localVarPath = this.basePath + '/classification/{dataType}'
            .replace('{' + 'dataType' + '}', encodeURIComponent(String(dataType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'dataType' is not null or undefined
        if (dataType === null || dataType === undefined) {
            throw new Error('Required parameter dataType was null or undefined when calling getClassificationData.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Classifications;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Classifications");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CommentsApiApiKeys {
}

export class CommentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CommentsApiApiKeys, value: string) {
        (this.authentications as any)[CommentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Creates a new comment
     * @param body Comment to create
     * @param {*} [options] Override http request options.
     */
    public createComment (body: Comment, options: any = {}) : Promise<{ response: http.ClientResponse; body: Comment;  }> {
        const localVarPath = this.basePath + '/comments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Comment")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Comment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Comment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a single comment
     * @param id Comment ID
     * @param {*} [options] Override http request options.
     */
    public deleteComment (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/comments/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves comments based on params
     * @param portfolioId Use when you want all comments from all projects inside this portfolio
     * @param projectId Use when you want comments for a specific project
     * @param offset The page number from where the search will be done
     * @param limit Max number of comments which will be returned
     * @param orderBy Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {*} [options] Override http request options.
     */
    public getComments (portfolioId?: string, projectId?: string, offset?: number, limit?: number, orderBy?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Comments;  }> {
        const localVarPath = this.basePath + '/comments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (portfolioId !== undefined) {
            localVarQueryParameters['portfolioId'] = ObjectSerializer.serialize(portfolioId, "string");
        }

        if (projectId !== undefined) {
            localVarQueryParameters['projectId'] = ObjectSerializer.serialize(projectId, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Comments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Comments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a single comment
     * @param id Comment ID
     * @param body JSON Patch operations to update value field.
     * @param {*} [options] Override http request options.
     */
    public updateComment (id: string, body: Operations, options: any = {}) : Promise<{ response: http.ClientResponse; body: Comment;  }> {
        const localVarPath = this.basePath + '/comments/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateComment.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Operations")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Comment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Comment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DefaultApiApiKeys {
}

export class DefaultApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        (this.authentications as any)[DefaultApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Creates a new category
     * @param body Category option to create
     * @param {*} [options] Override http request options.
     */
    public createCategoryOption (body: CategoryOption, options: any = {}) : Promise<{ response: http.ClientResponse; body: CategoryOption;  }> {
        const localVarPath = this.basePath + '/fields/{fieldId}/categoryOption';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCategoryOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CategoryOption")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CategoryOption;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CategoryOption");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates new category options
     * @param body Category options to create
     * @param {*} [options] Override http request options.
     */
    public createCategoryOptions (body: CategoryOptions, options: any = {}) : Promise<{ response: http.ClientResponse; body: CategoryOptions;  }> {
        const localVarPath = this.basePath + '/fields/{fieldId}/categoryOptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCategoryOptions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CategoryOptions")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CategoryOptions;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CategoryOptions");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a single category option
     * @param fieldId Field id
     * @param categoryOptionId Category Option ID
     * @param {*} [options] Override http request options.
     */
    public deleteCategoryOption (fieldId: string, categoryOptionId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fields/{fieldId}/categoryOptions/{categoryOptionId}'
            .replace('{' + 'fieldId' + '}', encodeURIComponent(String(fieldId)))
            .replace('{' + 'categoryOptionId' + '}', encodeURIComponent(String(categoryOptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fieldId' is not null or undefined
        if (fieldId === null || fieldId === undefined) {
            throw new Error('Required parameter fieldId was null or undefined when calling deleteCategoryOption.');
        }

        // verify required parameter 'categoryOptionId' is not null or undefined
        if (categoryOptionId === null || categoryOptionId === undefined) {
            throw new Error('Required parameter categoryOptionId was null or undefined when calling deleteCategoryOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a category
     * @param fieldId Field id
     * @param categoryOptionId Category Option id
     * @param {*} [options] Override http request options.
     */
    public getCategoryOption (fieldId: string, categoryOptionId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CategoryOption;  }> {
        const localVarPath = this.basePath + '/fields/{fieldId}/categoryOptions/{categoryOptionId}'
            .replace('{' + 'fieldId' + '}', encodeURIComponent(String(fieldId)))
            .replace('{' + 'categoryOptionId' + '}', encodeURIComponent(String(categoryOptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fieldId' is not null or undefined
        if (fieldId === null || fieldId === undefined) {
            throw new Error('Required parameter fieldId was null or undefined when calling getCategoryOption.');
        }

        // verify required parameter 'categoryOptionId' is not null or undefined
        if (categoryOptionId === null || categoryOptionId === undefined) {
            throw new Error('Required parameter categoryOptionId was null or undefined when calling getCategoryOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CategoryOption;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CategoryOption");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves categories for a field
     * @param fieldId Field id
     * @param {*} [options] Override http request options.
     */
    public getCategoryOptionsForField (fieldId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CategoryOptions;  }> {
        const localVarPath = this.basePath + '/fields/{fieldId}/categoryOptions'
            .replace('{' + 'fieldId' + '}', encodeURIComponent(String(fieldId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fieldId' is not null or undefined
        if (fieldId === null || fieldId === undefined) {
            throw new Error('Required parameter fieldId was null or undefined when calling getCategoryOptionsForField.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CategoryOptions;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CategoryOptions");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a single category
     * @param fieldId Field id
     * @param categoryOptionId Category Option id
     * @param body JSON Patch operations to update value field.
     * @param {*} [options] Override http request options.
     */
    public updateCategoryOption (fieldId: string, categoryOptionId: string, body: CategoryOption, options: any = {}) : Promise<{ response: http.ClientResponse; body: CategoryOption;  }> {
        const localVarPath = this.basePath + '/fields/{fieldId}/categoryOptions/{categoryOptionId}'
            .replace('{' + 'fieldId' + '}', encodeURIComponent(String(fieldId)))
            .replace('{' + 'categoryOptionId' + '}', encodeURIComponent(String(categoryOptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fieldId' is not null or undefined
        if (fieldId === null || fieldId === undefined) {
            throw new Error('Required parameter fieldId was null or undefined when calling updateCategoryOption.');
        }

        // verify required parameter 'categoryOptionId' is not null or undefined
        if (categoryOptionId === null || categoryOptionId === undefined) {
            throw new Error('Required parameter categoryOptionId was null or undefined when calling updateCategoryOption.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCategoryOption.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CategoryOption")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CategoryOption;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CategoryOption");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FieldsApiApiKeys {
}

export class FieldsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FieldsApiApiKeys, value: string) {
        (this.authentications as any)[FieldsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Creates a new field in a portfolio.
     * @param body Field to create
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public createField (body: Field, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Field>;  }> {
        const localVarPath = this.basePath + '/fields';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createField.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Field")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Field>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Field>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a field. Also deletes the values for every project.
     * @param id Field id
     * @param {*} [options] Override http request options.
     */
    public deleteField (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fields/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteField.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a field.
     * @param id Field id
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public getField (id: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Field;  }> {
        const localVarPath = this.basePath + '/fields/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getField.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Field;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Field");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves fields for a portfolio.
     * @param portfolioId Portfolio id
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param orderBy Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getFieldsForPortfolio (portfolioId: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Fields;  }> {
        const localVarPath = this.basePath + '/fields';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling getFieldsForPortfolio.');
        }

        if (portfolioId !== undefined) {
            localVarQueryParameters['portfolioId'] = ObjectSerializer.serialize(portfolioId, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Fields;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Fields");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set idea form fields for a portfolio.
     * @param body Idea form field request
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public setIdeaFormFields (body: IdeaFormFieldRequest, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Field>;  }> {
        const localVarPath = this.basePath + '/fields/ideaForm';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setIdeaFormFields.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "IdeaFormFieldRequest")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Field>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Field>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a field utilizing JSON Patch Operations. If the update logic makes changes to other fields, all updated fields will be returned in the response. 
     * @param id Field id
     * @param body JSON Patch Operations to update field.
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public updateField (id: string, body: Operations, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Field>;  }> {
        const localVarPath = this.basePath + '/fields/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateField.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateField.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Operations")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Field>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Field>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update fields associated with a portfolio.
     * @param body JSON Patch Operations to update multiple fields.
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public updateFields (body: Array<PatchItem>, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Field>;  }> {
        const localVarPath = this.basePath + '/fields';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateFields.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<PatchItem>")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Field>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Field>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GroupsApiApiKeys {
}

export class GroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GroupsApiApiKeys, value: string) {
        (this.authentications as any)[GroupsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Creates a new group. System Administator operation.
     * @param group Group to create
     * @param {*} [options] Override http request options.
     */
    public createGroup (group: Group, options: any = {}) : Promise<{ response: http.ClientResponse; body: Group;  }> {
        const localVarPath = this.basePath + '/groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling createGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(group, "Group")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get activities for group. System Administator operation.
     * @param id Group id
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getActivitiesForGroup (id: string, limit?: number, offset?: number, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Activities;  }> {
        const localVarPath = this.basePath + '/groups/{id}/activities'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getActivitiesForGroup.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Activities;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Activities");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get groups. System Administator operation.
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getGroups (expand?: string, limit?: number, offset?: number, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Groups;  }> {
        const localVarPath = this.basePath + '/groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Groups;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Groups");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get users for group. System Administator operation.
     * @param id Group id
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getUsersForGroup (id: string, expand?: string, limit?: number, offset?: number, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Users;  }> {
        const localVarPath = this.basePath + '/groups/{id}/users'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUsersForGroup.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LogoutApiApiKeys {
}

export class LogoutApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LogoutApiApiKeys, value: string) {
        (this.authentications as any)[LogoutApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Logout
     * @param targetUrl Target url to redirect after login
     * @param {*} [options] Override http request options.
     */
    public logout (targetUrl: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/oauth/logout';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'targetUrl' is not null or undefined
        if (targetUrl === null || targetUrl === undefined) {
            throw new Error('Required parameter targetUrl was null or undefined when calling logout.');
        }

        if (targetUrl !== undefined) {
            localVarQueryParameters['targetUrl'] = ObjectSerializer.serialize(targetUrl, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MailApiApiKeys {
}

export class MailApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MailApiApiKeys, value: string) {
        (this.authentications as any)[MailApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Send mail
     * @param mail mail request
     * @param {*} [options] Override http request options.
     */
    public sendMail (mail: Mail, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/mail';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mail' is not null or undefined
        if (mail === null || mail === undefined) {
            throw new Error('Required parameter mail was null or undefined when calling sendMail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(mail, "Mail")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send registration mail
     * @param mail mail request
     * @param accessToken access token
     * @param {*} [options] Override http request options.
     */
    public sendRegistrationMail (mail: Mail, accessToken?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/registrationMail';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mail' is not null or undefined
        if (mail === null || mail === undefined) {
            throw new Error('Required parameter mail was null or undefined when calling sendRegistrationMail.');
        }

        if (accessToken !== undefined) {
            localVarQueryParameters['accessToken'] = ObjectSerializer.serialize(accessToken, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(mail, "Mail")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MappingsApiApiKeys {
}

export class MappingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MappingsApiApiKeys, value: string) {
        (this.authentications as any)[MappingsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Maps the fields in the spreadsheet to appropriate buckets
     * @summary Accepts upload of spreadsheet and converts data into mappings.
     * @param file maybe put supported file types here?
     * @param {*} [options] Override http request options.
     */
    public spreadsheetToMappings (file: Buffer, options: any = {}) : Promise<{ response: http.ClientResponse; body: Mappings;  }> {
        const localVarPath = this.basePath + '/mappings/spreadsheet';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling spreadsheetToMappings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Mappings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mappings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update mapping
     * @param id Mapping id
     * @param body JSON Patch Operations to update mapping.
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public updateMapping (id: string, body: Operations, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Mapping>;  }> {
        const localVarPath = this.basePath + '/mappings/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateMapping.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateMapping.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Operations")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Mapping>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Mapping>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MessageTokensApiApiKeys {
}

export class MessageTokensApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MessageTokensApiApiKeys, value: string) {
        (this.authentications as any)[MessageTokensApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Get message authorization token for a destination
     * @param destinationType Message destination type
     * @param portfolioId Portfolio id for PORTFOLIO destination type
     * @param portfolioPlanId Portfolio plan id for PORTFOLIOPLAN destination type
     * @param {*} [options] Override http request options.
     */
    public getMessageToken (destinationType: any, portfolioId?: string, portfolioPlanId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: MessageToken;  }> {
        const localVarPath = this.basePath + '/messageTokens';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'destinationType' is not null or undefined
        if (destinationType === null || destinationType === undefined) {
            throw new Error('Required parameter destinationType was null or undefined when calling getMessageToken.');
        }

        if (destinationType !== undefined) {
            localVarQueryParameters['destinationType'] = ObjectSerializer.serialize(destinationType, "any");
        }

        if (portfolioId !== undefined) {
            localVarQueryParameters['portfolioId'] = ObjectSerializer.serialize(portfolioId, "string");
        }

        if (portfolioPlanId !== undefined) {
            localVarQueryParameters['portfolioPlanId'] = ObjectSerializer.serialize(portfolioPlanId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MessageToken;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MessageToken");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MessagesApiApiKeys {
}

export class MessagesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MessagesApiApiKeys, value: string) {
        (this.authentications as any)[MessagesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Send Message(s)
     * @param messages 
     * @param {*} [options] Override http request options.
     */
    public sendMessages (messages: Array<Message>, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/messages';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'messages' is not null or undefined
        if (messages === null || messages === undefined) {
            throw new Error('Required parameter messages was null or undefined when calling sendMessages.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(messages, "Array<Message>")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NotificationsApiApiKeys {
}

export class NotificationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NotificationsApiApiKeys, value: string) {
        (this.authentications as any)[NotificationsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Retrieves portfolio notifications log.
     * @param portfolioId Portfolio id
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param {*} [options] Override http request options.
     */
    public getNotifications (portfolioId: string, limit?: number, offset?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Activities;  }> {
        const localVarPath = this.basePath + '/notifications';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling getNotifications.');
        }

        if (portfolioId !== undefined) {
            localVarQueryParameters['portfolioId'] = ObjectSerializer.serialize(portfolioId, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Activities;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Activities");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reindex notifications. System Administator operation.
     * @param domains List of domains for where notifications need to be reindexed, if not provided reindex will be done for all domains
     * @param {*} [options] Override http request options.
     */
    public reindexNotifications (domains?: Array<string>, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/reindex/notifications';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (domains !== undefined) {
            localVarQueryParameters['domains'] = ObjectSerializer.serialize(domains, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PlansApiApiKeys {
}

export class PlansApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PlansApiApiKeys, value: string) {
        (this.authentications as any)[PlansApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Export Whats In Comparison
     * @param portfolioId portfolioId
     * @param portfolioPlanIds portfolioPlanIds to be exported
     * @param exportFormat export format type (XLSX)
     * @param startDate Start time period for which the grades are computed for.
     * @param endDate End time period for which the grades are computed for.
     * @param {*} [options] Override http request options.
     */
    public exportWhatsIn (portfolioId: string, portfolioPlanIds: string, exportFormat: any, startDate: number, endDate: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/whatsin/export';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling exportWhatsIn.');
        }

        // verify required parameter 'portfolioPlanIds' is not null or undefined
        if (portfolioPlanIds === null || portfolioPlanIds === undefined) {
            throw new Error('Required parameter portfolioPlanIds was null or undefined when calling exportWhatsIn.');
        }

        // verify required parameter 'exportFormat' is not null or undefined
        if (exportFormat === null || exportFormat === undefined) {
            throw new Error('Required parameter exportFormat was null or undefined when calling exportWhatsIn.');
        }

        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling exportWhatsIn.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling exportWhatsIn.');
        }

        if (portfolioId !== undefined) {
            localVarQueryParameters['portfolioId'] = ObjectSerializer.serialize(portfolioId, "string");
        }

        if (portfolioPlanIds !== undefined) {
            localVarQueryParameters['portfolioPlanIds'] = ObjectSerializer.serialize(portfolioPlanIds, "string");
        }

        if (exportFormat !== undefined) {
            localVarQueryParameters['exportFormat'] = ObjectSerializer.serialize(exportFormat, "any");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves grades for portfolio plan.
     * @param id Portfolio Plan id
     * @param startDate Start time period for which the grades are computed for.
     * @param endDate End time period for which the grades are computed for.
     * @param generateReport Generates grades report. Default is false.
     * @param {*} [options] Override http request options.
     */
    public getGradesForPortfolioPlan (id: string, startDate?: number, endDate?: number, generateReport?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: PortfolioPlanGrades;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/grades'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getGradesForPortfolioPlan.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "number");
        }

        if (generateReport !== undefined) {
            localVarQueryParameters['generateReport'] = ObjectSerializer.serialize(generateReport, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PortfolioPlanGrades;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PortfolioPlanGrades");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves insights for portfolio plan.
     * @param id Portfolio Plan id
     * @param startDate Start time period for which the grades are computed for.
     * @param endDate End time period for which the grades are computed for.
     * @param {*} [options] Override http request options.
     */
    public getInsightsForPortfolioPlan (id: string, startDate: number, endDate: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: PortfolioPlanInsights;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/insights'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getInsightsForPortfolioPlan.');
        }

        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getInsightsForPortfolioPlan.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getInsightsForPortfolioPlan.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PortfolioPlanInsights;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PortfolioPlanInsights");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves value insights for portfolio plan.
     * @param id Portfolio Plan id
     * @param startDate Start time period for which the grades are computed for.
     * @param endDate End time period for which the grades are computed for.
     * @param {*} [options] Override http request options.
     */
    public getValueInsightsForPortfolioPlan (id: string, startDate: number, endDate: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: PortfolioPlanInsights;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/insights/value'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getValueInsightsForPortfolioPlan.');
        }

        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getValueInsightsForPortfolioPlan.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getValueInsightsForPortfolioPlan.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PortfolioPlanInsights;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PortfolioPlanInsights");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves portfolioPlans with projects for WhatsIn
     * @param portfolioId portfolioId
     * @param portfolioPlanIds portfolioPlanIds for which projects are returned
     * @param startDate Start time period for which the grades are computed for.
     * @param endDate End time period for which the grades are computed for.
     * @param maxLimit Maximum limit for project; 0 &lt; number of returned project(is variable, NOT fixed) &lt; maxLimit
     * @param offset Pagination offset
     * @param {*} [options] Override http request options.
     */
    public getWhatsIn (portfolioId: string, portfolioPlanIds: string, startDate: number, endDate: number, maxLimit: number, offset?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: WhatsIn;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/whatsin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling getWhatsIn.');
        }

        // verify required parameter 'portfolioPlanIds' is not null or undefined
        if (portfolioPlanIds === null || portfolioPlanIds === undefined) {
            throw new Error('Required parameter portfolioPlanIds was null or undefined when calling getWhatsIn.');
        }

        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getWhatsIn.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getWhatsIn.');
        }

        // verify required parameter 'maxLimit' is not null or undefined
        if (maxLimit === null || maxLimit === undefined) {
            throw new Error('Required parameter maxLimit was null or undefined when calling getWhatsIn.');
        }

        if (portfolioId !== undefined) {
            localVarQueryParameters['portfolioId'] = ObjectSerializer.serialize(portfolioId, "string");
        }

        if (portfolioPlanIds !== undefined) {
            localVarQueryParameters['portfolioPlanIds'] = ObjectSerializer.serialize(portfolioPlanIds, "string");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "number");
        }

        if (maxLimit !== undefined) {
            localVarQueryParameters['maxLimit'] = ObjectSerializer.serialize(maxLimit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WhatsIn;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WhatsIn");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PodsApiApiKeys {
}

export class PodsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PodsApiApiKeys, value: string) {
        (this.authentications as any)[PodsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Import pod template in JSON format
     * @param podFile The pod file to upload.
     * @param templateName pod template name
     * @param {*} [options] Override http request options.
     */
    public importPodTemplate (podFile: Buffer, templateName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/pods/template';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'podFile' is not null or undefined
        if (podFile === null || podFile === undefined) {
            throw new Error('Required parameter podFile was null or undefined when calling importPodTemplate.');
        }

        // verify required parameter 'templateName' is not null or undefined
        if (templateName === null || templateName === undefined) {
            throw new Error('Required parameter templateName was null or undefined when calling importPodTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (podFile !== undefined) {
            localVarFormParams['podFile'] = podFile;
        }
        localVarUseFormData = true;

        if (templateName !== undefined) {
            localVarFormParams['templateName'] = ObjectSerializer.serialize(templateName, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PortfolioPlanUsersApiApiKeys {
}

export class PortfolioPlanUsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PortfolioPlanUsersApiApiKeys, value: string) {
        (this.authentications as any)[PortfolioPlanUsersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Delete a portfolio plan user
     * @param id Portfolio plan user id
     * @param {*} [options] Override http request options.
     */
    public deletePortfolioPlanUser (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/portfolioPlanUsers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deletePortfolioPlanUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update portfolio plan users
     * @param body JSON Patch Operations to update multiple portfolio plan users.
     * @param {*} [options] Override http request options.
     */
    public updatePortfolioPlanUsers (body: Array<PatchItem>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PortfolioPlanUser>;  }> {
        const localVarPath = this.basePath + '/portfolioPlanUsers/{id}';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updatePortfolioPlanUsers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<PatchItem>")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PortfolioPlanUser>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PortfolioPlanUser>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PortfolioPlansApiApiKeys {
}

export class PortfolioPlansApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PortfolioPlansApiApiKeys, value: string) {
        (this.authentications as any)[PortfolioPlansApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Add users to a portfolio plan.
     * @param id Portfolio plan id
     * @param body Email ids and personal message
     * @param {*} [options] Override http request options.
     */
    public addPortfolioPlanUsers (id: string, body?: AddUsersRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PortfolioPlanUser>;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/users'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addPortfolioPlanUsers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AddUsersRequest")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PortfolioPlanUser>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PortfolioPlanUser>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Apply recommendations of a portfolio plan.
     * @param id Portfolio plan id
     * @param body JSON Recommendation Objects to apply to a portfolio plan.
     * @param {*} [options] Override http request options.
     */
    public applyRecommendationsForPortfolioPlan (id: string, body: Array<Recommendation>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<FieldValue>;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/recommendations'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling applyRecommendationsForPortfolioPlan.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling applyRecommendationsForPortfolioPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<Recommendation>")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<FieldValue>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<FieldValue>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a portfolio plan
     * @param body portfolio plan
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public createPortfolioPlan (body: PortfolioPlan, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PortfolioPlan;  }> {
        const localVarPath = this.basePath + '/portfolioPlans';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createPortfolioPlan.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PortfolioPlan")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PortfolioPlan;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PortfolioPlan");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new projects
     * @param id Portfolio plan id
     * @param body Projects to create
     * @param doNotExpand Whether to return collections for each project in the response. Default is to return saved field values.
     * @param {*} [options] Override http request options.
     */
    public createProjectsInPortfolioPlan (id: string, body: Array<Project>, doNotExpand?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Project>;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/projects'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling createProjectsInPortfolioPlan.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createProjectsInPortfolioPlan.');
        }

        if (doNotExpand !== undefined) {
            localVarQueryParameters['doNotExpand'] = ObjectSerializer.serialize(doNotExpand, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<Project>")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Project>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Project>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes portfolio plan
     * @param id portfolio plan id
     * @param {*} [options] Override http request options.
     */
    public deletePortfolioPlan (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deletePortfolioPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Export portfolio plan
     * @param id portfolio plan id
     * @param exportType export type (PROJECT, SCHEDULE)
     * @param exportFormat export format type (XLSX)
     * @param {*} [options] Override http request options.
     */
    public exportPortfolioPlan (id: string, exportType: any, exportFormat: any, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/export'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling exportPortfolioPlan.');
        }

        // verify required parameter 'exportType' is not null or undefined
        if (exportType === null || exportType === undefined) {
            throw new Error('Required parameter exportType was null or undefined when calling exportPortfolioPlan.');
        }

        // verify required parameter 'exportFormat' is not null or undefined
        if (exportFormat === null || exportFormat === undefined) {
            throw new Error('Required parameter exportFormat was null or undefined when calling exportPortfolioPlan.');
        }

        if (exportType !== undefined) {
            localVarQueryParameters['exportType'] = ObjectSerializer.serialize(exportType, "any");
        }

        if (exportFormat !== undefined) {
            localVarQueryParameters['exportFormat'] = ObjectSerializer.serialize(exportFormat, "any");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves budget allocations for a portfolio plan.
     * @param id Portfolio plan id
     * @param startTime Start time for the requested data
     * @param endTime End time for the requested data
     * @param {*} [options] Override http request options.
     */
    public getBudgetAllocationsForPortfolioPlan (id: string, startTime?: number, endTime?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: BudgetAllocations;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/budgetAllocations'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBudgetAllocationsForPortfolioPlan.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(startTime, "number");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(endTime, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BudgetAllocations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BudgetAllocations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves minified projects contained within a portfolio plan.
     * @param id Portfolio plan id
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param orderBy Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getMinifiedProjectsForPortfolioPlan (id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: MinifiedProjects;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/projects/minify'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getMinifiedProjectsForPortfolioPlan.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MinifiedProjects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MinifiedProjects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves portfolio plan
     * @param id portfolio plan id
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public getPortfolioPlan (id: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PortfolioPlan;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPortfolioPlan.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PortfolioPlan;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PortfolioPlan");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves portfolio plan activities log.
     * @param id Portfolio plan id
     * @param projectId Use when you want to filter activities for a specific project
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getPortfolioPlanActivities (id: string, projectId?: string, limit?: number, offset?: number, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Activities;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/activities'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPortfolioPlanActivities.');
        }

        if (projectId !== undefined) {
            localVarQueryParameters['projectId'] = ObjectSerializer.serialize(projectId, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Activities;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Activities");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves users in a portfolio plan.
     * @param id Portfolio plan id
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param orderBy Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getPortfolioPlanUsers (id: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PortfolioPlanUsers;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/users'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPortfolioPlanUsers.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PortfolioPlanUsers;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PortfolioPlanUsers");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves portfolio plans
     * @param portfolioId portfolio id
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param orderBy Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getPortfolioPlans (portfolioId: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PortfolioPlans;  }> {
        const localVarPath = this.basePath + '/portfolioPlans';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling getPortfolioPlans.');
        }

        if (portfolioId !== undefined) {
            localVarQueryParameters['portfolioId'] = ObjectSerializer.serialize(portfolioId, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PortfolioPlans;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PortfolioPlans");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves project contained within a portfolio plan.
     * @param portfolioPlanId Portfolio plan id
     * @param projectId project id
     * @param {*} [options] Override http request options.
     */
    public getProjectForPortfolioPlan (portfolioPlanId: string, projectId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Project;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{portfolioPlanId}/projects/{projectId}'
            .replace('{' + 'portfolioPlanId' + '}', encodeURIComponent(String(portfolioPlanId)))
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioPlanId' is not null or undefined
        if (portfolioPlanId === null || portfolioPlanId === undefined) {
            throw new Error('Required parameter portfolioPlanId was null or undefined when calling getProjectForPortfolioPlan.');
        }

        // verify required parameter 'projectId' is not null or undefined
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProjectForPortfolioPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Project;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves projects for portfolio plan
     * @param portfolioId Portfolio id
     * @param portfolioPlanId Portfolio Plan id
     * @param positionFrom positionFrom for projects
     * @param positionTo positionTo for projects
     * @param {*} [options] Override http request options.
     */
    public getProjectPortfolioPlansForPortfolioPlanAndPortfolio (portfolioId: string, portfolioPlanId: string, positionFrom: number, positionTo: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Projects;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{portfolioPlanId}/portfolios/{portfolioId}/projectPortfolioPlans'
            .replace('{' + 'portfolioId' + '}', encodeURIComponent(String(portfolioId)))
            .replace('{' + 'portfolioPlanId' + '}', encodeURIComponent(String(portfolioPlanId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling getProjectPortfolioPlansForPortfolioPlanAndPortfolio.');
        }

        // verify required parameter 'portfolioPlanId' is not null or undefined
        if (portfolioPlanId === null || portfolioPlanId === undefined) {
            throw new Error('Required parameter portfolioPlanId was null or undefined when calling getProjectPortfolioPlansForPortfolioPlanAndPortfolio.');
        }

        // verify required parameter 'positionFrom' is not null or undefined
        if (positionFrom === null || positionFrom === undefined) {
            throw new Error('Required parameter positionFrom was null or undefined when calling getProjectPortfolioPlansForPortfolioPlanAndPortfolio.');
        }

        // verify required parameter 'positionTo' is not null or undefined
        if (positionTo === null || positionTo === undefined) {
            throw new Error('Required parameter positionTo was null or undefined when calling getProjectPortfolioPlansForPortfolioPlanAndPortfolio.');
        }

        if (positionFrom !== undefined) {
            localVarQueryParameters['positionFrom'] = ObjectSerializer.serialize(positionFrom, "number");
        }

        if (positionTo !== undefined) {
            localVarQueryParameters['positionTo'] = ObjectSerializer.serialize(positionTo, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Projects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Projects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves projects contained within a portfolio plan. Possible expand paths - (items.fieldValues, contributingUserIds)
     * @param id Portfolio plan id
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param orderBy Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getProjectsForPortfolioPlan (id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Projects;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/projects'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProjectsForPortfolioPlan.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Projects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Projects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves recommendations for a portfolio plan.
     * @param id Portfolio plan id
     * @param startDate Start time period for the time horizon.
     * @param endDate End time period for the time horizon.
     * @param planType Plan type
     * @param {*} [options] Override http request options.
     */
    public getRecommendationsForPortfolioPlan (id: string, startDate?: number, endDate?: number, planType?: any, options: any = {}) : Promise<{ response: http.ClientResponse; body: Recommendations;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/recommendations'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRecommendationsForPortfolioPlan.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "number");
        }

        if (planType !== undefined) {
            localVarQueryParameters['planType'] = ObjectSerializer.serialize(planType, "any");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Recommendations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Recommendations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves schedule for portfolio plan. The schedule is stored in a new portfolio plan.
     * @param id Portfolio Plan id
     * @param startDate Start time period for the time horizon.
     * @param endDate End time period for the time horizon.
     * @param toleranceLevelPercentage Percentage parameter to allow scheduling values within a deviation, defined by [target*(1 - tolerance), target*(1 + tolerance] bounds. Value should be between 0 and 1. Defaults to 0.1
     * @param schedulingCriteria Criteria used to function to evaluate different schedules. Defaults to TimePeriodOverBudgetPercent
     * @param {*} [options] Override http request options.
     */
    public getScheduleForPortfolioPlan (id: string, startDate?: number, endDate?: number, toleranceLevelPercentage?: number, schedulingCriteria?: any, options: any = {}) : Promise<{ response: http.ClientResponse; body: Recommendations;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/schedule'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getScheduleForPortfolioPlan.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "number");
        }

        if (toleranceLevelPercentage !== undefined) {
            localVarQueryParameters['toleranceLevelPercentage'] = ObjectSerializer.serialize(toleranceLevelPercentage, "number");
        }

        if (schedulingCriteria !== undefined) {
            localVarQueryParameters['schedulingCriteria'] = ObjectSerializer.serialize(schedulingCriteria, "any");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Recommendations;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Recommendations");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Rebaseline a portfolio plan.
     * @param id Portfolio plan id
     * @param {*} [options] Override http request options.
     */
    public rebaselinePortfolioPlan (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PortfolioPlan;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/rebaseline'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling rebaselinePortfolioPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PortfolioPlan;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PortfolioPlan");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a portfolio plan utilizing JSON Patch Operations. 
     * @param id PortfolioPlan id
     * @param body JSON Patch Operations to update portfolio plan.
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public updatePortfolioPlan (id: string, body: Operations, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PortfolioPlan;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePortfolioPlan.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updatePortfolioPlan.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Operations")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PortfolioPlan;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PortfolioPlan");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update field values in a portfolio plan
     * @param id Portfolio plan id
     * @param body JSON Patch Operations to update multiple field values.
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public updatePortfolioPlanFieldValues (id: any, body: Array<FieldValuePatchItem>, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<FieldValue>;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/fieldValues'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePortfolioPlanFieldValues.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updatePortfolioPlanFieldValues.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<FieldValuePatchItem>")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<FieldValue>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<FieldValue>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update users in a portfolio plan
     * @param id Portfolio plan id
     * @param body JSON Patch Operations to update multiple portfolio plan users.
     * @param {*} [options] Override http request options.
     */
    public updatePortfolioPlanUsers (id: any, body: Array<PatchItem>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PortfolioPlanUser>;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/users'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePortfolioPlanUsers.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updatePortfolioPlanUsers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<PatchItem>")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PortfolioPlanUser>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PortfolioPlanUser>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PortfoliosApiApiKeys {
}

export class PortfoliosApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PortfoliosApiApiKeys, value: string) {
        (this.authentications as any)[PortfoliosApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Archive a portfolio.
     * @param id Portfolio id
     * @param {*} [options] Override http request options.
     */
    public archivePortfolio (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Portfolio;  }> {
        const localVarPath = this.basePath + '/portfolios/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling archivePortfolio.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Portfolio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Portfolio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new portfolio.
     * @param body Portfolio to create
     * @param {*} [options] Override http request options.
     */
    public createPortfolio (body: Portfolio, options: any = {}) : Promise<{ response: http.ClientResponse; body: Portfolio;  }> {
        const localVarPath = this.basePath + '/portfolios';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createPortfolio.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Portfolio")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Portfolio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Portfolio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Export portfolio data in JSON format
     * @param id Portfolio id
     * @param {*} [options] Override http request options.
     */
    public exportPortfolioData (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/portfolios/{id}/pod'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling exportPortfolioData.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a portfolio.
     * @param id Portfolio id
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public getPortfolio (id: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Portfolio;  }> {
        const localVarPath = this.basePath + '/portfolios/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPortfolio.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Portfolio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Portfolio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves portfolio activities log.
     * @param id Portfolio id
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getPortfolioActivities (id: string, limit?: number, offset?: number, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Activities;  }> {
        const localVarPath = this.basePath + '/portfolios/{id}/activities'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPortfolioActivities.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Activities;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Activities");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary (Deprecated. Use getResourcePoolsForPortfolioPlan) Retrieves resource pools in a portfolio.
     * @param id Portfolio id
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param orderBy Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getPortfolioResourcePools (id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResourcePools;  }> {
        const localVarPath = this.basePath + '/portfolios/{id}/resourcePools'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPortfolioResourcePools.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResourcePools;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResourcePools");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get portfolios.
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param orderBy Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getPortfolios (expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Portfolios;  }> {
        const localVarPath = this.basePath + '/portfolios';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Portfolios;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Portfolios");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves projects for portfolio
     * @param portfolioId Portfolio id
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param {*} [options] Override http request options.
     */
    public getProjectsForPortfolio (portfolioId: string, limit?: number, offset?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Projects;  }> {
        const localVarPath = this.basePath + '/portfolios/{portfolioId}/projects'
            .replace('{' + 'portfolioId' + '}', encodeURIComponent(String(portfolioId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling getProjectsForPortfolio.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Projects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Projects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves spreadsheet report for portfolio
     * @param portfolioId Portfolio id
     * @param spreadsheetId Spreadsheet id
     * @param sheetName Spreadsheet name
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public getSpreadsheetReportForPortfolio (portfolioId: string, spreadsheetId: string, sheetName: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SpreadsheetReport;  }> {
        const localVarPath = this.basePath + '/portfolios/{portfolioId}/spreadsheet/{spreadsheetId}/report'
            .replace('{' + 'portfolioId' + '}', encodeURIComponent(String(portfolioId)))
            .replace('{' + 'spreadsheetId' + '}', encodeURIComponent(String(spreadsheetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling getSpreadsheetReportForPortfolio.');
        }

        // verify required parameter 'spreadsheetId' is not null or undefined
        if (spreadsheetId === null || spreadsheetId === undefined) {
            throw new Error('Required parameter spreadsheetId was null or undefined when calling getSpreadsheetReportForPortfolio.');
        }

        // verify required parameter 'sheetName' is not null or undefined
        if (sheetName === null || sheetName === undefined) {
            throw new Error('Required parameter sheetName was null or undefined when calling getSpreadsheetReportForPortfolio.');
        }

        if (sheetName !== undefined) {
            localVarQueryParameters['sheetName'] = ObjectSerializer.serialize(sheetName, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SpreadsheetReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SpreadsheetReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Import portfolio data in JSON format
     * @param id Portfolio id
     * @param podFile The pod file to upload.
     * @param templateName pod template name to load
     * @param {*} [options] Override http request options.
     */
    public importPortfolioData (id: string, podFile?: Buffer, templateName?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Portfolio;  }> {
        const localVarPath = this.basePath + '/portfolios/{id}/pod'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling importPortfolioData.');
        }

        if (templateName !== undefined) {
            localVarQueryParameters['templateName'] = ObjectSerializer.serialize(templateName, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (podFile !== undefined) {
            localVarFormParams['podFile'] = podFile;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Portfolio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Portfolio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Generates a new registration token
     * @param id Portfolio id
     * @param {*} [options] Override http request options.
     */
    public regenerateUserRegistrationToken (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Portfolio;  }> {
        const localVarPath = this.basePath + '/portfolios/{id}/regenerateUserRegistrationToken'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling regenerateUserRegistrationToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Portfolio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Portfolio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Saves spreadsheet for portfolio
     * @param portfolioId Portfolio id
     * @param spreadsheetId Spreadsheet id
     * @param sheetName Spreadsheet name
     * @param {*} [options] Override http request options.
     */
    public saveSpreadsheetForPortfolio (portfolioId: string, spreadsheetId: string, sheetName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SpreadsheetReport;  }> {
        const localVarPath = this.basePath + '/portfolios/{portfolioId}/spreadsheet/{spreadsheetId}'
            .replace('{' + 'portfolioId' + '}', encodeURIComponent(String(portfolioId)))
            .replace('{' + 'spreadsheetId' + '}', encodeURIComponent(String(spreadsheetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling saveSpreadsheetForPortfolio.');
        }

        // verify required parameter 'spreadsheetId' is not null or undefined
        if (spreadsheetId === null || spreadsheetId === undefined) {
            throw new Error('Required parameter spreadsheetId was null or undefined when calling saveSpreadsheetForPortfolio.');
        }

        // verify required parameter 'sheetName' is not null or undefined
        if (sheetName === null || sheetName === undefined) {
            throw new Error('Required parameter sheetName was null or undefined when calling saveSpreadsheetForPortfolio.');
        }

        if (sheetName !== undefined) {
            localVarQueryParameters['sheetName'] = ObjectSerializer.serialize(sheetName, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SpreadsheetReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SpreadsheetReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Save spreadsheet source for a portfolio
     * @param id Portfolio id
     * @param file 
     * @param saveZeroAsBlank 
     * @param {*} [options] Override http request options.
     */
    public saveSpreadsheetSourceForPortfolio (id: string, file: Buffer, saveZeroAsBlank?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: Source;  }> {
        const localVarPath = this.basePath + '/portfolios/{id}/sources/spreadsheet'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling saveSpreadsheetSourceForPortfolio.');
        }

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling saveSpreadsheetSourceForPortfolio.');
        }

        if (saveZeroAsBlank !== undefined) {
            localVarQueryParameters['saveZeroAsBlank'] = ObjectSerializer.serialize(saveZeroAsBlank, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Source;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Source");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates custom names for portfolio
     * @param portfolioId Portfolio id
     * @param customNames Custom names
     * @param {*} [options] Override http request options.
     */
    public setCustomNames (portfolioId: string, customNames: Array<CustomName>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<CustomName>;  }> {
        const localVarPath = this.basePath + '/portfolios/{portfolioId}/customNames'
            .replace('{' + 'portfolioId' + '}', encodeURIComponent(String(portfolioId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling setCustomNames.');
        }

        // verify required parameter 'customNames' is not null or undefined
        if (customNames === null || customNames === undefined) {
            throw new Error('Required parameter customNames was null or undefined when calling setCustomNames.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(customNames, "Array<CustomName>")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CustomName>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CustomName>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a portfolio.
     * @param id Portfolio id
     * @param body JSON Patch Operations to update a portfolio.
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public updatePortfolio (id: string, body: Operations, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Portfolio;  }> {
        const localVarPath = this.basePath + '/portfolios/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePortfolio.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updatePortfolio.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Operations")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Portfolio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Portfolio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update field values in a portfolio
     * @param id Portfolio id
     * @param body JSON Patch Operations to update multiple field values.
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public updatePortfolioFieldValues (id: any, body: Array<FieldValuePatchItem>, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<FieldValue>;  }> {
        const localVarPath = this.basePath + '/portfolios/{id}/fieldValues'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePortfolioFieldValues.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updatePortfolioFieldValues.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<FieldValuePatchItem>")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<FieldValue>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<FieldValue>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary (Deprecated. Use updateResourcePoolBudgetAmountsForPortfolioPlan) Update resource pool budget amounts in a portfolio
     * @param id Portfolio id
     * @param body JSON Patch Operations to update multiple resource pool budget amounts
     * @param {*} [options] Override http request options.
     */
    public updatePortfolioResourcePoolBudgetAmounts (id: any, body: Array<ResourcePoolBudgetAmountPatchItem>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<ResourcePool>;  }> {
        const localVarPath = this.basePath + '/portfolios/{id}/resourcePoolBudgetAmounts'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePortfolioResourcePoolBudgetAmounts.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updatePortfolioResourcePoolBudgetAmounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<ResourcePoolBudgetAmountPatchItem>")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ResourcePool>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ResourcePool>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProjectsApiApiKeys {
}

export class ProjectsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProjectsApiApiKeys, value: string) {
        (this.authentications as any)[ProjectsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Add users to a project.
     * @param id project id
     * @param body Email ids and personal message
     * @param {*} [options] Override http request options.
     */
    public addContributingUsersForProject (id: string, body?: AddUsersRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PortfolioPlanUser>;  }> {
        const localVarPath = this.basePath + '/projects/{id}/users'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addContributingUsersForProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AddUsersRequest")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PortfolioPlanUser>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PortfolioPlanUser>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new project.
     * @param portfolioId Portfolio id
     * @param project Project to create
     * @param {*} [options] Override http request options.
     */
    public createProject (portfolioId: string, project: Project, options: any = {}) : Promise<{ response: http.ClientResponse; body: Project;  }> {
        const localVarPath = this.basePath + '/projects';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling createProject.');
        }

        // verify required parameter 'project' is not null or undefined
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling createProject.');
        }

        if (portfolioId !== undefined) {
            localVarQueryParameters['portfolioId'] = ObjectSerializer.serialize(portfolioId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(project, "Project")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Project;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a project.
     * @param id Project id
     * @param {*} [options] Override http request options.
     */
    public deleteProject (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/projects/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete projects.
     * @param projectIds Project ids
     * @param {*} [options] Override http request options.
     */
    public deleteProjects (projectIds: Array<string>, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/projects/delete';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectIds' is not null or undefined
        if (projectIds === null || projectIds === undefined) {
            throw new Error('Required parameter projectIds was null or undefined when calling deleteProjects.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(projectIds, "Array<string>")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a project.
     * @param id Project id
     * @param {*} [options] Override http request options.
     */
    public getProject (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Project;  }> {
        const localVarPath = this.basePath + '/projects/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Project;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a project for a portfolioPlan.
     * @param projectId Project id
     * @param portfolioPlanId PortfolioPlan id
     * @param {*} [options] Override http request options.
     */
    public getProjectForPortfolioPlan (projectId: string, portfolioPlanId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Project;  }> {
        const localVarPath = this.basePath + '/projects/{projectId}/portfolioPlan/{portfolioPlanId}'
            .replace('{' + 'projectId' + '}', encodeURIComponent(String(projectId)))
            .replace('{' + 'portfolioPlanId' + '}', encodeURIComponent(String(portfolioPlanId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'projectId' is not null or undefined
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProjectForPortfolioPlan.');
        }

        // verify required parameter 'portfolioPlanId' is not null or undefined
        if (portfolioPlanId === null || portfolioPlanId === undefined) {
            throw new Error('Required parameter portfolioPlanId was null or undefined when calling getProjectForPortfolioPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Project;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Project");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves projects contained within a portfolio. Possible expand paths are - (items.fieldValues, contributingUserIds)
     * @param portfolioId Portfolio id
     * @param portfolioPlanId Portfolio plan id. If not specified the portfolio plan will default to current baseline
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param orderBy Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getProjectsForPortfolio (portfolioId: string, portfolioPlanId?: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Projects;  }> {
        const localVarPath = this.basePath + '/projects';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling getProjectsForPortfolio.');
        }

        if (portfolioId !== undefined) {
            localVarQueryParameters['portfolioId'] = ObjectSerializer.serialize(portfolioId, "string");
        }

        if (portfolioPlanId !== undefined) {
            localVarQueryParameters['portfolioPlanId'] = ObjectSerializer.serialize(portfolioPlanId, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Projects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Projects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove contributing users from a project.
     * @param id project id
     * @param body contributing user ids
     * @param {*} [options] Override http request options.
     */
    public removeContributingUsersFromProject (id: string, body: RemoveContributingUsersRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/projects/{id}/users'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeContributingUsersFromProject.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling removeContributingUsersFromProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RemoveContributingUsersRequest")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds or removes dependsOn and/or dependant linked projects to a project.
     * @param id project id
     * @param body dependsOn and hasDependent project Ids
     * @param {*} [options] Override http request options.
     */
    public setProjectDependencies (id: string, body?: SetDependenciesRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: Projects;  }> {
        const localVarPath = this.basePath + '/projects/{id}/dependencies'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setProjectDependencies.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SetDependenciesRequest")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Projects;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Projects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PropertiesApiApiKeys {
}

export class PropertiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PropertiesApiApiKeys, value: string) {
        (this.authentications as any)[PropertiesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Get configuration properties for user if userId and groupId are present, otherwise properties for authenticated user will be returned
     * @param userId User id
     * @param {*} [options] Override http request options.
     */
    public getProperties (userId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Properties;  }> {
        const localVarPath = this.basePath + '/properties';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Properties;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Properties");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set configuration properties
     * @param body Properties that needed to be created/updated for the current user.
     * @param {*} [options] Override http request options.
     */
    public setProperties (body: Array<Property>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Property>;  }> {
        const localVarPath = this.basePath + '/properties';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setProperties.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<Property>")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Property>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Property>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RegistrationApiApiKeys {
}

export class RegistrationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RegistrationApiApiKeys, value: string) {
        (this.authentications as any)[RegistrationApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Register Portfolio User
     * @param registerUserRequest Register user request
     * @param {*} [options] Override http request options.
     */
    public registerPortfolioUser (registerUserRequest: RegisterUserRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PortfolioPlanUser;  }> {
        const localVarPath = this.basePath + '/registerPortfolioUser';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'registerUserRequest' is not null or undefined
        if (registerUserRequest === null || registerUserRequest === undefined) {
            throw new Error('Required parameter registerUserRequest was null or undefined when calling registerPortfolioUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(registerUserRequest, "RegisterUserRequest")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PortfolioPlanUser;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PortfolioPlanUser");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Register User
     * @param registerUserRequest Register user request
     * @param {*} [options] Override http request options.
     */
    public registerUser (registerUserRequest: RegisterUserRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/registerUser';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'registerUserRequest' is not null or undefined
        if (registerUserRequest === null || registerUserRequest === undefined) {
            throw new Error('Required parameter registerUserRequest was null or undefined when calling registerUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(registerUserRequest, "RegisterUserRequest")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportsApiApiKeys {
}

export class ReportsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportsApiApiKeys, value: string) {
        (this.authentications as any)[ReportsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Downloads the grades report for a portfolio plan
     * @param id Portfolio Plan id
     * @param startDate Start time period for which the grades are computed for.
     * @param endDate End time period for which the grades are computed for.
     * @param {*} [options] Override http request options.
     */
    public getPortfolioPlanGradesReport (id: string, startDate?: number, endDate?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/portfolioPlans/{id}/grades/report'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPortfolioPlanGradesReport.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "number");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ResourcePoolsApiApiKeys {
}

export class ResourcePoolsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ResourcePoolsApiApiKeys, value: string) {
        (this.authentications as any)[ResourcePoolsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Retrieves a resource pool.
     * @param id Resource Pool id
     * @param portfolioPlanId Portfolio Plan id
     * @param {*} [options] Override http request options.
     */
    public getResourcePool (id: string, portfolioPlanId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResourcePool;  }> {
        const localVarPath = this.basePath + '/resourcePools/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getResourcePool.');
        }

        if (portfolioPlanId !== undefined) {
            localVarQueryParameters['portfolioPlanId'] = ObjectSerializer.serialize(portfolioPlanId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResourcePool;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResourcePool");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch resource pools for portfolio plan
     * @param portfolioPlanId Portfolio Plan id
     * @param planOverridesOnly Returns only plan overrides. default is false.
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param orderBy Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getResourcePoolsForPortfolioPlan (portfolioPlanId: string, planOverridesOnly?: boolean, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResourcePools;  }> {
        const localVarPath = this.basePath + '/resourcePools';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioPlanId' is not null or undefined
        if (portfolioPlanId === null || portfolioPlanId === undefined) {
            throw new Error('Required parameter portfolioPlanId was null or undefined when calling getResourcePoolsForPortfolioPlan.');
        }

        if (portfolioPlanId !== undefined) {
            localVarQueryParameters['portfolioPlanId'] = ObjectSerializer.serialize(portfolioPlanId, "string");
        }

        if (planOverridesOnly !== undefined) {
            localVarQueryParameters['planOverridesOnly'] = ObjectSerializer.serialize(planOverridesOnly, "boolean");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['orderBy'] = ObjectSerializer.serialize(orderBy, "string");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResourcePools;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResourcePools");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update resource pool budget amounts in a portfolio plan
     * @param portfolioPlanId Portfolio Plan id
     * @param body JSON Patch Operations to update multiple resource pool budget amounts
     * @param {*} [options] Override http request options.
     */
    public updateResourcePoolBudgetAmountsForPortfolioPlan (portfolioPlanId: string, body: Array<ResourcePoolBudgetAmountPatchItem>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<ResourcePool>;  }> {
        const localVarPath = this.basePath + '/resourcePools';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioPlanId' is not null or undefined
        if (portfolioPlanId === null || portfolioPlanId === undefined) {
            throw new Error('Required parameter portfolioPlanId was null or undefined when calling updateResourcePoolBudgetAmountsForPortfolioPlan.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateResourcePoolBudgetAmountsForPortfolioPlan.');
        }

        if (portfolioPlanId !== undefined) {
            localVarQueryParameters['portfolioPlanId'] = ObjectSerializer.serialize(portfolioPlanId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<ResourcePoolBudgetAmountPatchItem>")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ResourcePool>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ResourcePool>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SourcesApiApiKeys {
}

export class SourcesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SourcesApiApiKeys, value: string) {
        (this.authentications as any)[SourcesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Fetch data for source.
     * @param id Source id
     * @param priorityScenario Priority Scenario name
     * @param {*} [options] Override http request options.
     */
    public fetchDataForSource (id: string, priorityScenario?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Source;  }> {
        const localVarPath = this.basePath + '/sources/{id}/fetchData'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling fetchDataForSource.');
        }

        if (priorityScenario !== undefined) {
            localVarQueryParameters['priorityScenario'] = ObjectSerializer.serialize(priorityScenario, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Source;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Source");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send data for source.
     * @param id Source id
     * @param statuses Statuses
     * @param {*} [options] Override http request options.
     */
    public sendDataForSource (id: string, statuses: Array<string>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Source;  }> {
        const localVarPath = this.basePath + '/sources/{id}/sendData'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling sendDataForSource.');
        }

        // verify required parameter 'statuses' is not null or undefined
        if (statuses === null || statuses === undefined) {
            throw new Error('Required parameter statuses was null or undefined when calling sendDataForSource.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(statuses, "Array<string>")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Source;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Source");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SpreadsheetApiApiKeys {
}

export class SpreadsheetApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SpreadsheetApiApiKeys, value: string) {
        (this.authentications as any)[SpreadsheetApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * Creates spreadsheet from file upload.
     * @param file xls or xlsx file upload
     * @param {*} [options] Override http request options.
     */
    public createSpreadsheet (file: Buffer, options: any = {}) : Promise<{ response: http.ClientResponse; body: Spreadsheet;  }> {
        const localVarPath = this.basePath + '/spreadsheet';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling createSpreadsheet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Spreadsheet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Spreadsheet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates spreadsheet from kloudless file
     * @param kloudlessFile kloudless file
     * @param {*} [options] Override http request options.
     */
    public createSpreadsheetForKloudlessFile (kloudlessFile: KloudlessFile, options: any = {}) : Promise<{ response: http.ClientResponse; body: Spreadsheet;  }> {
        const localVarPath = this.basePath + '/spreadsheet/kloudless';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'kloudlessFile' is not null or undefined
        if (kloudlessFile === null || kloudlessFile === undefined) {
            throw new Error('Required parameter kloudlessFile was null or undefined when calling createSpreadsheetForKloudlessFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(kloudlessFile, "KloudlessFile")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Spreadsheet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Spreadsheet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete spreadsheet and mappings
     * @param id spreadsheet id
     * @param {*} [options] Override http request options.
     */
    public deleteSpreadsheet (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/spreadsheet/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSpreadsheet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get mappings for spreadsheet
     * @param id spreadsheet id
     * @param sheetName 
     * @param importType Whether import PROJECT or COST data. Defaults to PROJECT
     * @param expand JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request options.
     */
    public getMappingsForSpreadsheet (id: string, sheetName?: string, importType?: any, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Mappings;  }> {
        const localVarPath = this.basePath + '/spreadsheet/{id}/mappings'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getMappingsForSpreadsheet.');
        }

        if (sheetName !== undefined) {
            localVarQueryParameters['sheetName'] = ObjectSerializer.serialize(sheetName, "string");
        }

        if (importType !== undefined) {
            localVarQueryParameters['importType'] = ObjectSerializer.serialize(importType, "any");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Mappings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mappings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get spreadsheet
     * @param id spreadsheet id
     * @param {*} [options] Override http request options.
     */
    public getSpreadsheet (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Spreadsheet;  }> {
        const localVarPath = this.basePath + '/spreadsheet/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSpreadsheet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Spreadsheet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Spreadsheet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TagsApiApiKeys {
}

export class TagsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TagsApiApiKeys, value: string) {
        (this.authentications as any)[TagsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Creates a new tag
     * @param body Tag to create
     * @param {*} [options] Override http request options.
     */
    public createTag (body: Tag, options: any = {}) : Promise<{ response: http.ClientResponse; body: Tag;  }> {
        const localVarPath = this.basePath + '/tags';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Tag")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Tag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Tag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a single tag
     * @param id Tag ID
     * @param {*} [options] Override http request options.
     */
    public deleteTag (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tags/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a tag
     * @param id Tag id
     * @param {*} [options] Override http request options.
     */
    public getTag (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Tag;  }> {
        const localVarPath = this.basePath + '/tags/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Tag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Tag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves tags for a portfolio
     * @param portfolioId Portfolio id
     * @param {*} [options] Override http request options.
     */
    public getTagsForPortfolio (portfolioId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Tags;  }> {
        const localVarPath = this.basePath + '/tags';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portfolioId' is not null or undefined
        if (portfolioId === null || portfolioId === undefined) {
            throw new Error('Required parameter portfolioId was null or undefined when calling getTagsForPortfolio.');
        }

        if (portfolioId !== undefined) {
            localVarQueryParameters['portfolioId'] = ObjectSerializer.serialize(portfolioId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Tags;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Tags");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a single tag
     * @param id Tag ID
     * @param body JSON Patch operations to update value field.
     * @param {*} [options] Override http request options.
     */
    public updateTag (id: string, body: Operations, options: any = {}) : Promise<{ response: http.ClientResponse; body: Tag;  }> {
        const localVarPath = this.basePath + '/tags/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTag.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Operations")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Tag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Tag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserApiApiKeys {
}

export class UserApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserApiApiKeys, value: string) {
        (this.authentications as any)[UserApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Get user
     * @param id User id
     * @param {*} [options] Override http request options.
     */
    public getUser (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/users/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get user activities
     * @param id User id
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getUserActivities (id: string, limit?: number, offset?: number, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Activities;  }> {
        const localVarPath = this.basePath + '/users/{id}/activities'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserActivities.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Activities;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Activities");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get user activities for group
     * @param limit Pagination limit
     * @param offset Pagination offset
     * @param match Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request options.
     */
    public getUserActivitiesForGroup (limit?: number, offset?: number, match?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Activities;  }> {
        const localVarPath = this.basePath + '/users/activities';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (match !== undefined) {
            localVarQueryParameters['match'] = ObjectSerializer.serialize(match, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Activities;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Activities");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }
    /**
     * 
     * @summary Creates a new user.
     * @param user User to create
     * @param {*} [options] Override http request options.
     */
    public createUser (user: AddUserRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling createUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(user, "AddUserRequest")
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get users.
     * @param {*} [options] Override http request options.
     */
    public getUsers (options: any = {}) : Promise<{ response: http.ClientResponse; body: Users;  }> {
        const localVarPath = this.basePath + '/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.OAuth2.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
