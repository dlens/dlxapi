/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Decision Lens API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:9005/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AccessTokenGeneratedEvent
 */
export interface AccessTokenGeneratedEvent {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenGeneratedEvent
     */
    id?: string;
    /**
     * 
     * @type {User}
     * @memberof AccessTokenGeneratedEvent
     */
    user?: User;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenGeneratedEvent
     */
    grantType?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenGeneratedEvent
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenGeneratedEvent
     */
    groupId?: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ActivityType {
    FieldCreatedEvent = <any> 'FieldCreatedEvent',
    FieldDataTypeUpdatedEvent = <any> 'FieldDataTypeUpdatedEvent',
    FieldDeletedEvent = <any> 'FieldDeletedEvent',
    FieldNameUpdatedEvent = <any> 'FieldNameUpdatedEvent',
    FieldDescriptionUpdatedEvent = <any> 'FieldDescriptionUpdatedEvent',
    FieldTypePositionUpdatedEvent = <any> 'FieldTypePositionUpdatedEvent',
    FieldPositionUpdatedEvent = <any> 'FieldPositionUpdatedEvent',
    FieldTargetTypeUpdatedEvent = <any> 'FieldTargetTypeUpdatedEvent',
    FieldTypeUpdatedEvent = <any> 'FieldTypeUpdatedEvent',
    FieldCalculationTypeUpdatedEvent = <any> 'FieldCalculationTypeUpdatedEvent',
    FieldIsFieldTypeApprovedUpdatedEvent = <any> 'FieldIsFieldTypeApprovedUpdatedEvent',
    FieldIsIdeaFieldUpdatedEvent = <any> 'FieldIsIdeaFieldUpdatedEvent',
    FieldTagAddedEvent = <any> 'FieldTagAddedEvent',
    FieldTagRemovedEvent = <any> 'FieldTagRemovedEvent',
    FieldIdeaFieldPositionUpdatedEvent = <any> 'FieldIdeaFieldPositionUpdatedEvent',
    FieldIsIdeaFieldRequiredUpdatedEvent = <any> 'FieldIsIdeaFieldRequiredUpdatedEvent',
    FieldIsAutoScaleUpdatedEvent = <any> 'FieldIsAutoScaleUpdatedEvent',
    PortfolioArchivedEvent = <any> 'PortfolioArchivedEvent',
    PortfolioCreatedEvent = <any> 'PortfolioCreatedEvent',
    PortfolioNameUpdatedEvent = <any> 'PortfolioNameUpdatedEvent',
    PortfolioUserRegistrationTokenUpdatedEvent = <any> 'PortfolioUserRegistrationTokenUpdatedEvent',
    SubPortfolioAddedEvent = <any> 'SubPortfolioAddedEvent',
    SubPortfolioRemovedEvent = <any> 'SubPortfolioRemovedEvent',
    PortfolioPlanCreatedEvent = <any> 'PortfolioPlanCreatedEvent',
    PortfolioRankUpdatedEvent = <any> 'PortfolioRankUpdatedEvent',
    PortfolioPlanDeletedEvent = <any> 'PortfolioPlanDeletedEvent',
    PortfolioPlanUserCreatedV2Event = <any> 'PortfolioPlanUserCreatedV2Event',
    PortfolioPlanUserFieldPermissionsUpdatedEvent = <any> 'PortfolioPlanUserFieldPermissionsUpdatedEvent',
    PortfolioPlanUserProjectPermissionsUpdatedEvent = <any> 'PortfolioPlanUserProjectPermissionsUpdatedEvent',
    PortfolioPlanUserRolesUpdatedNewEvent = <any> 'PortfolioPlanUserRolesUpdatedNewEvent',
    PortfolioPlanUserDeletedEvent = <any> 'PortfolioPlanUserDeletedEvent',
    ProjectCreatedEvent = <any> 'ProjectCreatedEvent',
    ProjectDeletedEvent = <any> 'ProjectDeletedEvent',
    ProjectFieldValueDeletedEvent = <any> 'ProjectFieldValueDeletedEvent',
    ProjectFieldValueUpdatedEvent = <any> 'ProjectFieldValueUpdatedEvent',
    ProjectRankFieldValueUpdatedEvent = <any> 'ProjectRankFieldValueUpdatedEvent',
    ProjectTagAddedEvent = <any> 'ProjectTagAddedEvent',
    ProjectTagRemovedEvent = <any> 'ProjectTagRemovedEvent',
    ProjectPortfolioPlanFieldValuesCopiedEvent = <any> 'ProjectPortfolioPlanFieldValuesCopiedEvent',
    ProjectPortfolioPlanFieldValueUpdatedEvent = <any> 'ProjectPortfolioPlanFieldValueUpdatedEvent',
    ProjectPortfolioPlanFieldValueDeletedEvent = <any> 'ProjectPortfolioPlanFieldValueDeletedEvent',
    ProjectPortfolioPlanDeletedEvent = <any> 'ProjectPortfolioPlanDeletedEvent',
    ProjectPortfolioPlanIsDraftUpdatedEvent = <any> 'ProjectPortfolioPlanIsDraftUpdatedEvent',
    ResourcePoolBudgetAmountUpdatedEvent = <any> 'ResourcePoolBudgetAmountUpdatedEvent',
    ResourcePoolPlanBudgetAmountUpdatedEvent = <any> 'ResourcePoolPlanBudgetAmountUpdatedEvent',
    ResourcePoolPlanBudgetCopiedEvent = <any> 'ResourcePoolPlanBudgetCopiedEvent',
    ResourcePoolCreatedEvent = <any> 'ResourcePoolCreatedEvent',
    ResourcePoolNameUpdatedEvent = <any> 'ResourcePoolNameUpdatedEvent',
    ResourcePoolDeletedEvent = <any> 'ResourcePoolDeletedEvent',
    SourceCreatedEvent = <any> 'SourceCreatedEvent',
    SourceDeletedEvent = <any> 'SourceDeletedEvent',
    SourceNameUpdatedEvent = <any> 'SourceNameUpdatedEvent',
    UserAddedEvent = <any> 'UserAddedEvent',
    UserLockedUpdatedEvent = <any> 'UserLockedUpdatedEvent',
    UserApprovalAddedEvent = <any> 'UserApprovalAddedEvent',
    UserDeletedFromGroupEvent = <any> 'UserDeletedFromGroupEvent',
    UserAuthenticatedEvent = <any> 'UserAuthenticatedEvent',
    UserGroupAddedEvent = <any> 'UserGroupAddedEvent',
    AuthorizationCodeGeneratedEvent = <any> 'AuthorizationCodeGeneratedEvent',
    AccessTokenGeneratedEvent = <any> 'AccessTokenGeneratedEvent',
    PlanCreatedEvent = <any> 'PlanCreatedEvent',
    PlanDeletedEvent = <any> 'PlanDeletedEvent',
    PlanGeneratedEvent = <any> 'PlanGeneratedEvent',
    PlanNameUpdatedEvent = <any> 'PlanNameUpdatedEvent',
    PlanCopiedEvent = <any> 'PlanCopiedEvent',
    PlanProjectFundingUpdatedEvent = <any> 'PlanProjectFundingUpdatedEvent',
    PlanTypeUpdatedEvent = <any> 'PlanTypeUpdatedEvent',
    PlanComparisonCreatedEvent = <any> 'PlanComparisonCreatedEvent',
    PlanComparisonNameUpdatedEvent = <any> 'PlanComparisonNameUpdatedEvent',
    PlanComparisonPlansUpdatedEvent = <any> 'PlanComparisonPlansUpdatedEvent',
    PortfolioPlanNameUpdatedEvent = <any> 'PortfolioPlanNameUpdatedEvent',
    PortfolioPlanDescriptionUpdatedEvent = <any> 'PortfolioPlanDescriptionUpdatedEvent',
    PortfolioTimeIntervalUpdatedEvent = <any> 'PortfolioTimeIntervalUpdatedEvent',
    PortfolioBudgetTimePeriodTypeUpdatedEvent = <any> 'PortfolioBudgetTimePeriodTypeUpdatedEvent',
    PortfolioIsMonthlySpendPlanUpdatedEvent = <any> 'PortfolioIsMonthlySpendPlanUpdatedEvent',
    PortfolioPlanRebaselinedEvent = <any> 'PortfolioPlanRebaselinedEvent',
    PortfolioPlanDataImportedEvent = <any> 'PortfolioPlanDataImportedEvent',
    PortfolioPlanUserDraftProjectIdsUpdatedEvent = <any> 'PortfolioPlanUserDraftProjectIdsUpdatedEvent',
    CommentAddedEvent = <any> 'CommentAddedEvent',
    CommentEditedEvent = <any> 'CommentEditedEvent',
    CommentDeletedEvent = <any> 'CommentDeletedEvent',
    TagCreatedEvent = <any> 'TagCreatedEvent',
    TagNameUpdatedEvent = <any> 'TagNameUpdatedEvent',
    TagColorUpdatedEvent = <any> 'TagColorUpdatedEvent',
    TagParentUpdatedEvent = <any> 'TagParentUpdatedEvent',
    TagDeletedEvent = <any> 'TagDeletedEvent',
    CategoryOptionCreatedEvent = <any> 'CategoryOptionCreatedEvent',
    FieldCategoryOptionsUpdatedEvent = <any> 'FieldCategoryOptionsUpdatedEvent',
    CategoryOptionNameUpdatedEvent = <any> 'CategoryOptionNameUpdatedEvent',
    CategoryOptionDeletedEvent = <any> 'CategoryOptionDeletedEvent',
    CategoryOptionPositionUpdatedEvent = <any> 'CategoryOptionPositionUpdatedEvent',
    ProjectContributingUserAddedEvent = <any> 'ProjectContributingUserAddedEvent',
    ProjectContributingUserDeletedEvent = <any> 'ProjectContributingUserDeletedEvent',
    AttachmentDeletedEvent = <any> 'AttachmentDeletedEvent',
    AttachmentCreatedEvent = <any> 'AttachmentCreatedEvent',
    AttachmentNameUpdatedEvent = <any> 'AttachmentNameUpdatedEvent',
    ProjectAttachmentAddedEvent = <any> 'ProjectAttachmentAddedEvent',
    ProjectAttachmentRemovedEvent = <any> 'ProjectAttachmentRemovedEvent',
    CustomNameAddedEvent = <any> 'CustomNameAddedEvent',
    CustomNameUpdatedEvent = <any> 'CustomNameUpdatedEvent',
    CustomNameDeletedEvent = <any> 'CustomNameDeletedEvent',
    ProjectDependsOnAddedEvent = <any> 'ProjectDependsOnAddedEvent',
    ProjectDependsOnRemovedEvent = <any> 'ProjectDependsOnRemovedEvent',
    PortfolioProjectsCreatedEvent = <any> 'PortfolioProjectsCreatedEvent',
    PortfolioProjectsUpdatedEvent = <any> 'PortfolioProjectsUpdatedEvent',
    GoalAddedEvent = <any> 'GoalAddedEvent',
    GoalUpdatedEvent = <any> 'GoalUpdatedEvent',
    GoalDeletedEvent = <any> 'GoalDeletedEvent',
    ProjectFieldValuesDeletedEvent = <any> 'ProjectFieldValuesDeletedEvent',
    ResourcePoolFieldValueUpdatedEvent = <any> 'ResourcePoolFieldValueUpdatedEvent',
    ScalePointCreatedEvent = <any> 'ScalePointCreatedEvent',
    ScalePointDeletedEvent = <any> 'ScalePointDeletedEvent',
    ScalePointNameUpdatedEvent = <any> 'ScalePointNameUpdatedEvent',
    ScalePointAutoValueUpdatedEvent = <any> 'ScalePointAutoValueUpdatedEvent',
    ScalePointAutoScaleValueUpdatedEvent = <any> 'ScalePointAutoScaleValueUpdatedEvent',
    ScalePointManualScaleValueUpdatedEvent = <any> 'ScalePointManualScaleValueUpdatedEvent',
    ScalePointManualValueUpdatedEvent = <any> 'ScalePointManualValueUpdatedEvent',
    ScalePointProjectUpdatedEvent = <any> 'ScalePointProjectUpdatedEvent',
    FieldAttributesPlanningWindowStartUpdatedEvent = <any> 'FieldAttributesPlanningWindowStartUpdatedEvent',
    FieldAttributesPlanningWindowEndUpdatedEvent = <any> 'FieldAttributesPlanningWindowEndUpdatedEvent',
    PortfolioScoreWeightsUpdatedEvent = <any> 'PortfolioScoreWeightsUpdatedEvent',
    ScoreWeightCreatedEvent = <any> 'ScoreWeightCreatedEvent',
    ScoreWeightDeletedEvent = <any> 'ScoreWeightDeletedEvent',
    ScoreWeightNameUpdatedEvent = <any> 'ScoreWeightNameUpdatedEvent',
    ScoreWeightFieldWeightCreatedEvent = <any> 'ScoreWeightFieldWeightCreatedEvent',
    ScoreWeightFieldWeightValueUpdatedEvent = <any> 'ScoreWeightFieldWeightValueUpdatedEvent',
    ScoreWeightFieldWeightLockUpdatedEvent = <any> 'ScoreWeightFieldWeightLockUpdatedEvent',
    ScoreWeightFieldWeightDeletedEvent = <any> 'ScoreWeightFieldWeightDeletedEvent',
    FieldAttributesCategoryDisplayOrderUpdatedEvent = <any> 'FieldAttributesCategoryDisplayOrderUpdatedEvent',
    FieldAttributesDataFormatsDecimalPlacesUpdatedEvent = <any> 'FieldAttributesDataFormatsDecimalPlacesUpdatedEvent',
    FieldAttributesDataFormatsCurrencyUpdatedEvent = <any> 'FieldAttributesDataFormatsCurrencyUpdatedEvent',
    FieldAttributesDataFormatsNegativesUpdatedEvent = <any> 'FieldAttributesDataFormatsNegativesUpdatedEvent',
    FieldRankedBasedOnSortOrderEvent = <any> 'FieldRankedBasedOnSortOrderEvent',
    FieldAttributesDataFormatsDateFormatUpdatedEvent = <any> 'FieldAttributesDataFormatsDateFormatUpdatedEvent'
}

/**
 * 
 * @export
 * @interface AddAndDeleteFieldValuesForFieldsRequest
 */
export interface AddAndDeleteFieldValuesForFieldsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddAndDeleteFieldValuesForFieldsRequest
     */
    fieldIdsToAdd?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddAndDeleteFieldValuesForFieldsRequest
     */
    fieldIdsToRemove?: Array<string>;
    /**
     * 
     * @type {Array<TimePeriod>}
     * @memberof AddAndDeleteFieldValuesForFieldsRequest
     */
    timePeriods?: Array<TimePeriod>;
    /**
     * 
     * @type {FieldValue}
     * @memberof AddAndDeleteFieldValuesForFieldsRequest
     */
    fieldValue?: FieldValue;
}

/**
 * 
 * @export
 * @interface AddUserRequest
 */
export interface AddUserRequest {
    /**
     * 
     * @type {User}
     * @memberof AddUserRequest
     */
    user?: User;
    /**
     * 
     * @type {string}
     * @memberof AddUserRequest
     */
    message?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddUserRequest
     */
    sendRegistrationEmail?: boolean;
}

/**
 * 
 * @export
 * @interface AddUsersRequest
 */
export interface AddUsersRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddUsersRequest
     */
    emailIds?: Array<string>;
    /**
     * 
     * @type {PortfolioPlanUserRole}
     * @memberof AddUsersRequest
     */
    role?: PortfolioPlanUserRole;
    /**
     * 
     * @type {string}
     * @memberof AddUsersRequest
     */
    message?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddUsersRequest
     */
    doNotNotify?: boolean;
}

/**
 * 
 * @export
 * @interface AddedToPortfolioMessagePayload
 */
export interface AddedToPortfolioMessagePayload {
    /**
     * 
     * @type {Portfolio}
     * @memberof AddedToPortfolioMessagePayload
     */
    portfolio: Portfolio;
}

/**
 * 
 * @export
 * @interface AddedToPortfolioPlanMessagePayload
 */
export interface AddedToPortfolioPlanMessagePayload {
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof AddedToPortfolioPlanMessagePayload
     */
    portfolioPlan: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface AttachmentCreatedEvent
 */
export interface AttachmentCreatedEvent {
    /**
     * 
     * @type {string}
     * @memberof AttachmentCreatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {number}
     * @memberof AttachmentCreatedEvent
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof AttachmentCreatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentCreatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof AttachmentCreatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface AttachmentDeletedEvent
 */
export interface AttachmentDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof AttachmentDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {number}
     * @memberof AttachmentDeletedEvent
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof AttachmentDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof AttachmentDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface AttachmentNameUpdatedEvent
 */
export interface AttachmentNameUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof AttachmentNameUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {number}
     * @memberof AttachmentNameUpdatedEvent
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof AttachmentNameUpdatedEvent
     */
    previousName?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentNameUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentNameUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof AttachmentNameUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface AttachmentUpdatedMessagePayload
 */
export interface AttachmentUpdatedMessagePayload {
    /**
     * 
     * @type {Attachment}
     * @memberof AttachmentUpdatedMessagePayload
     */
    attachment: Attachment;
}

/**
 * 
 * @export
 * @interface Attributes
 */
export interface Attributes {
    /**
     * 
     * @type {TimeInterval}
     * @memberof Attributes
     */
    timeInterval?: TimeInterval;
    /**
     * 
     * @type {TimePeriodType}
     * @memberof Attributes
     */
    budgetTimePeriodType?: TimePeriodType;
    /**
     * 
     * @type {boolean}
     * @memberof Attributes
     */
    isMonthlySpendPlan?: boolean;
}

/**
 * 
 * @export
 * @interface AuthorizationCodeGeneratedEvent
 */
export interface AuthorizationCodeGeneratedEvent {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationCodeGeneratedEvent
     */
    id?: string;
    /**
     * 
     * @type {User}
     * @memberof AuthorizationCodeGeneratedEvent
     */
    user?: User;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationCodeGeneratedEvent
     */
    redirectUri?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationCodeGeneratedEvent
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationCodeGeneratedEvent
     */
    groupId?: string;
}

/**
 * 
 * @export
 * @interface BalanceFieldDetail
 */
export interface BalanceFieldDetail {
    /**
     * 
     * @type {string}
     * @memberof BalanceFieldDetail
     */
    categoryName?: string;
    /**
     * 
     * @type {number}
     * @memberof BalanceFieldDetail
     */
    actual?: number;
    /**
     * 
     * @type {number}
     * @memberof BalanceFieldDetail
     */
    expected?: number;
}

/**
 * 
 * @export
 * @interface BudgetAllocation
 */
export interface BudgetAllocation {
    /**
     * 
     * @type {string}
     * @memberof BudgetAllocation
     */
    resourcePoolName?: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetAllocation
     */
    resourcePoolId?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof BudgetAllocation
     */
    yearlyBudgets?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof BudgetAllocation
     */
    yearlyAllocations?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof BudgetAllocation
     */
    yearlyTimePeriods?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof BudgetAllocation
     */
    yearlyConstrainedAllocations?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof BudgetAllocation
     */
    monthlyAllocations?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof BudgetAllocation
     */
    monthlyBudgets?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof BudgetAllocation
     */
    monthlyTimePeriods?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof BudgetAllocation
     */
    monthlyConstrainedAllocations?: Array<number>;
}

/**
 * 
 * @export
 * @interface BudgetFieldCreatedMessagePayload
 */
export interface BudgetFieldCreatedMessagePayload {
    /**
     * 
     * @type {Array<Field>}
     * @memberof BudgetFieldCreatedMessagePayload
     */
    budgetFields: Array<Field>;
}

/**
 * 
 * @export
 * @interface BudgetFieldsDeletedMessagePayload
 */
export interface BudgetFieldsDeletedMessagePayload {
    /**
     * 
     * @type {string}
     * @memberof BudgetFieldsDeletedMessagePayload
     */
    portfolioId?: string;
    /**
     * 
     * @type {Array<Field>}
     * @memberof BudgetFieldsDeletedMessagePayload
     */
    budgetFields: Array<Field>;
}

/**
 * 
 * @export
 * @interface BudgetFieldsUpdatedMessagePayload
 */
export interface BudgetFieldsUpdatedMessagePayload {
    /**
     * 
     * @type {string}
     * @memberof BudgetFieldsUpdatedMessagePayload
     */
    portfolioId?: string;
    /**
     * 
     * @type {Array<Field>}
     * @memberof BudgetFieldsUpdatedMessagePayload
     */
    budgetFields?: Array<Field>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum CalculationType {
    SUM = <any> 'SUM',
    AVERAGE = <any> 'AVERAGE',
    NONE = <any> 'NONE'
}

/**
 * 
 * @export
 * @interface CategorizationInsight
 */
export interface CategorizationInsight {
    /**
     * 
     * @type {string}
     * @memberof CategorizationInsight
     */
    name?: string;
    /**
     * 
     * @type {LikertScaleType}
     * @memberof CategorizationInsight
     */
    likertScaleType?: LikertScaleType;
    /**
     * 
     * @type {RiskType}
     * @memberof CategorizationInsight
     */
    riskType?: RiskType;
    /**
     * 
     * @type {number}
     * @memberof CategorizationInsight
     */
    allocation?: number;
    /**
     * 
     * @type {number}
     * @memberof CategorizationInsight
     */
    expectedAllocation?: number;
    /**
     * 
     * @type {number}
     * @memberof CategorizationInsight
     */
    projectCount?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CategorizationInsight
     */
    projectIds?: Array<string>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum CategoryDisplayOrder {
    DEFAULTPOSITION = <any> 'DEFAULT_POSITION',
    ALPHABETIC = <any> 'ALPHABETIC'
}

/**
 * 
 * @export
 * @interface CategoryOptionAddedMessagePayload
 */
export interface CategoryOptionAddedMessagePayload {
    /**
     * 
     * @type {CategoryOption}
     * @memberof CategoryOptionAddedMessagePayload
     */
    categoryOption: CategoryOption;
}

/**
 * 
 * @export
 * @interface CategoryOptionCreatedEvent
 */
export interface CategoryOptionCreatedEvent {
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionCreatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionCreatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionCreatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof CategoryOptionCreatedEvent
     */
    position?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionCreatedEvent
     */
    fieldId?: string;
}

/**
 * 
 * @export
 * @interface CategoryOptionDeletedEvent
 */
export interface CategoryOptionDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionDeletedEvent
     */
    fieldId?: string;
}

/**
 * 
 * @export
 * @interface CategoryOptionDeletedMessagePayload
 */
export interface CategoryOptionDeletedMessagePayload {
    /**
     * 
     * @type {CategoryOption}
     * @memberof CategoryOptionDeletedMessagePayload
     */
    categoryOption: CategoryOption;
}

/**
 * 
 * @export
 * @interface CategoryOptionNameUpdatedEvent
 */
export interface CategoryOptionNameUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionNameUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionNameUpdatedEvent
     */
    previousName?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionNameUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionNameUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionNameUpdatedEvent
     */
    fieldId?: string;
}

/**
 * 
 * @export
 * @interface CategoryOptionPositionUpdatedEvent
 */
export interface CategoryOptionPositionUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionPositionUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionPositionUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof CategoryOptionPositionUpdatedEvent
     */
    position?: number;
    /**
     * 
     * @type {number}
     * @memberof CategoryOptionPositionUpdatedEvent
     */
    previousPosition?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoryOptionPositionUpdatedEvent
     */
    fieldId?: string;
}

/**
 * 
 * @export
 * @interface CategoryOptionUpdatedMessagePayload
 */
export interface CategoryOptionUpdatedMessagePayload {
    /**
     * 
     * @type {CategoryOption}
     * @memberof CategoryOptionUpdatedMessagePayload
     */
    categoryOption: CategoryOption;
}

/**
 * 
 * @export
 * @interface Column
 */
export interface Column {
    /**
     * 
     * @type {string}
     * @memberof Column
     */
    fieldId?: string;
    /**
     * 
     * @type {string}
     * @memberof Column
     */
    name?: string;
    /**
     * 
     * @type {ColumnType}
     * @memberof Column
     */
    type?: ColumnType;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ColumnType {
    TOTALREQUEST = <any> 'TOTAL_REQUEST',
    TOTALDIFF = <any> 'TOTAL_DIFF',
    COSTREQUEST = <any> 'COST_REQUEST',
    TOTALALLOCATED = <any> 'TOTAL_ALLOCATED',
    TOTALPLANNED = <any> 'TOTAL_PLANNED',
    TOTALALLOCATEDPLANNEDDIFF = <any> 'TOTAL_ALLOCATED_PLANNED_DIFF',
    CUMULATIVEPLANNED = <any> 'CUMULATIVE_PLANNED',
    CUMULATIVEOBLIGATED = <any> 'CUMULATIVE_OBLIGATED',
    CUMULATIVEPLANNEDOBLIGATEDDIFF = <any> 'CUMULATIVE_PLANNED_OBLIGATED_DIFF',
    FIELD = <any> 'FIELD',
    RANK = <any> 'RANK'
}

/**
 * 
 * @export
 * @interface CommentAddedEvent
 */
export interface CommentAddedEvent {
    /**
     * 
     * @type {string}
     * @memberof CommentAddedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAddedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAddedEvent
     */
    projectName?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAddedEvent
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAddedEvent
     */
    projectId?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAddedEvent
     */
    value?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof CommentAddedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface CommentAddedMessagePayload
 */
export interface CommentAddedMessagePayload {
    /**
     * 
     * @type {Comment}
     * @memberof CommentAddedMessagePayload
     */
    comment: Comment;
}

/**
 * 
 * @export
 * @interface CommentDeletedEvent
 */
export interface CommentDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof CommentDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentDeletedEvent
     */
    projectName?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentDeletedEvent
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentDeletedEvent
     */
    projectId?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentDeletedEvent
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentDeletedEvent
     */
    previousValue?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof CommentDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface CommentDeletedMessagePayload
 */
export interface CommentDeletedMessagePayload {
    /**
     * 
     * @type {Comment}
     * @memberof CommentDeletedMessagePayload
     */
    comment: Comment;
}

/**
 * 
 * @export
 * @interface CommentEditedEvent
 */
export interface CommentEditedEvent {
    /**
     * 
     * @type {string}
     * @memberof CommentEditedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentEditedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentEditedEvent
     */
    projectName?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentEditedEvent
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentEditedEvent
     */
    projectId?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentEditedEvent
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentEditedEvent
     */
    previousValue?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof CommentEditedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface CommentEditedMessagePayload
 */
export interface CommentEditedMessagePayload {
    /**
     * 
     * @type {Comment}
     * @memberof CommentEditedMessagePayload
     */
    comment: Comment;
}

/**
 * 
 * @export
 * @interface CostBudgetAllocation
 */
export interface CostBudgetAllocation {
    /**
     * 
     * @type {Field}
     * @memberof CostBudgetAllocation
     */
    field?: Field;
    /**
     * 
     * @type {number}
     * @memberof CostBudgetAllocation
     */
    budget?: number;
    /**
     * 
     * @type {number}
     * @memberof CostBudgetAllocation
     */
    allocation?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Currency {
    DEFAULT = <any> 'DEFAULT',
    DOLLAR = <any> 'DOLLAR'
}

/**
 * 
 * @export
 * @interface CustomName
 */
export interface CustomName {
    /**
     * 
     * @type {CustomNameType}
     * @memberof CustomName
     */
    type?: CustomNameType;
    /**
     * 
     * @type {string}
     * @memberof CustomName
     */
    value?: string;
    /**
     * 
     * @type {CustomNameGroupType}
     * @memberof CustomName
     */
    groupType?: CustomNameGroupType;
}

/**
 * 
 * @export
 * @interface CustomNameAddedEvent
 */
export interface CustomNameAddedEvent {
    /**
     * 
     * @type {string}
     * @memberof CustomNameAddedEvent
     */
    groupType?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomNameAddedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomNameAddedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomNameAddedEvent
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomNameAddedEvent
     */
    value?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof CustomNameAddedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface CustomNameDeletedEvent
 */
export interface CustomNameDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof CustomNameDeletedEvent
     */
    groupType?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomNameDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomNameDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomNameDeletedEvent
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomNameDeletedEvent
     */
    value?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof CustomNameDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum CustomNameGroupType {
    GENERAL = <any> 'GENERAL',
    STATUS = <any> 'STATUS',
    COST = <any> 'COST'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum CustomNameType {
    PROJECT = <any> 'PROJECT',
    BUDGET = <any> 'BUDGET',
    REQUEST = <any> 'REQUEST',
    ALLOCATED = <any> 'ALLOCATED',
    DRAFT = <any> 'DRAFT',
    IDEA = <any> 'IDEA',
    BACKLOG = <any> 'BACKLOG',
    SCHEDULED = <any> 'SCHEDULED',
    INPROGRESS = <any> 'IN_PROGRESS',
    COMPLETED = <any> 'COMPLETED',
    ONHOLD = <any> 'ON_HOLD',
    ARCHIVED = <any> 'ARCHIVED',
    PLANNED = <any> 'PLANNED',
    OBLIGATED = <any> 'OBLIGATED'
}

/**
 * 
 * @export
 * @interface CustomNameUpdatedEvent
 */
export interface CustomNameUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof CustomNameUpdatedEvent
     */
    groupType?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomNameUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomNameUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomNameUpdatedEvent
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomNameUpdatedEvent
     */
    previousValue?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomNameUpdatedEvent
     */
    value?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof CustomNameUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface CustomNamesUpdatedMessagePayload
 */
export interface CustomNamesUpdatedMessagePayload {
    /**
     * 
     * @type {Array<CustomName>}
     * @memberof CustomNamesUpdatedMessagePayload
     */
    customNames: Array<CustomName>;
}

/**
 * 
 * @export
 * @interface DLCGroup
 */
export interface DLCGroup {
    /**
     * 
     * @type {string}
     * @memberof DLCGroup
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DLCGroup
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof DLCGroup
     */
    domainName?: string;
    /**
     * 
     * @type {SSOPrincipalTransmitMethod}
     * @memberof DLCGroup
     */
    ssoPrincipalTransmitMethod?: SSOPrincipalTransmitMethod;
    /**
     * 
     * @type {string}
     * @memberof DLCGroup
     */
    ssoPrincipalKey?: string;
    /**
     * 
     * @type {string}
     * @memberof DLCGroup
     */
    dl4Domain?: string;
}

/**
 * 
 * @export
 * @interface DLIApplication
 */
export interface DLIApplication {
    /**
     * 
     * @type {string}
     * @memberof DLIApplication
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DLIApplication
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof DLIApplication
     */
    family?: string;
}

/**
 * 
 * @export
 * @interface DataFormats
 */
export interface DataFormats {
    /**
     * 
     * @type {number}
     * @memberof DataFormats
     */
    decimalPlaces?: number;
    /**
     * 
     * @type {Currency}
     * @memberof DataFormats
     */
    currency?: Currency;
    /**
     * 
     * @type {Negatives}
     * @memberof DataFormats
     */
    negatives?: Negatives;
    /**
     * 
     * @type {DateFormat}
     * @memberof DataFormats
     */
    dateFormat?: DateFormat;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum DataType {
    TEXT = <any> 'TEXT',
    NUMERIC = <any> 'NUMERIC',
    DATE = <any> 'DATE',
    BOOLEAN = <any> 'BOOLEAN',
    NUMERICARRAY = <any> 'NUMERIC_ARRAY',
    TEXTARRAY = <any> 'TEXT_ARRAY',
    CATEGORY = <any> 'CATEGORY',
    STARCATEGORY = <any> 'STAR_CATEGORY',
    RANK = <any> 'RANK'
}

/**
 * 
 * @export
 * @interface DataUpdatedMessagePayload
 */
export interface DataUpdatedMessagePayload {
    /**
     * 
     * @type {string}
     * @memberof DataUpdatedMessagePayload
     */
    message: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum DateFormat {
    MMMDDYYYY = <any> 'MMM_DD_YYYY',
    MMDDYYYYSLASH = <any> 'MM_DD_YYYY_SLASH',
    MMDDYYYYDASH = <any> 'MM_DD_YYYY_DASH',
    DDMMYYYY = <any> 'DD_MM_YYYY',
    MMMYYYY = <any> 'MMM_YYYY',
    MMYYYYSLASH = <any> 'MM_YYYY_SLASH',
    MMYYYYDASH = <any> 'MM_YYYY_DASH',
    YYYY = <any> 'YYYY',
    FYYYYY = <any> 'FY_YYYY',
    DATETIME = <any> 'DATE_TIME'
}

/**
 * 
 * @export
 * @interface DlCollection
 */
export interface DlCollection {
    /**
     * 
     * @type {string}
     * @memberof DlCollection
     */
    href?: string;
    /**
     * 
     * @type {number}
     * @memberof DlCollection
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof DlCollection
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof DlCollection
     */
    size?: number;
}

/**
 * 
 * @export
 * @interface DlResource
 */
export interface DlResource {
    /**
     * 
     * @type {string}
     * @memberof DlResource
     */
    href?: string;
    /**
     * 
     * @type {string}
     * @memberof DlResource
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DlResource
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof DlResource
     */
    modifiedAt?: string;
}

/**
 * 
 * @export
 * @interface DlcPortfolio
 */
export interface DlcPortfolio {
    /**
     * 
     * @type {string}
     * @memberof DlcPortfolio
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DlcPortfolio
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof DlcPortfolio
     */
    taskUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof DlcPortfolio
     */
    lastUpdatedAt?: number;
    /**
     * 
     * @type {number}
     * @memberof DlcPortfolio
     */
    lastFetchedAt?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DlcPortfolio
     */
    statuses?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DlcPortfolio
     */
    defaultPriorityScenario?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DlcPortfolio
     */
    priorityScenarios?: Array<string>;
}

/**
 * 
 * @export
 * @interface DraftProjectsSubmittedMessagePayload
 */
export interface DraftProjectsSubmittedMessagePayload {
    /**
     * 
     * @type {Array<Project>}
     * @memberof DraftProjectsSubmittedMessagePayload
     */
    projects: Array<Project>;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof DraftProjectsSubmittedMessagePayload
     */
    attachments?: Array<Attachment>;
}

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    message: string;
}

/**
 * 
 * @export
 * @interface ExpandComponent
 */
export interface ExpandComponent {
    /**
     * path to the collection. example - items.fieldValues
     * @type {string}
     * @memberof ExpandComponent
     */
    path?: string;
    /**
     * filter the collection. example - \"field.id:123-12321-321312-e3e21w\"
     * @type {string}
     * @memberof ExpandComponent
     */
    match?: string;
    /**
     * return all possible values in the collection even if they are not assigned to projects currently like all STATUS values.
     * @type {boolean}
     * @memberof ExpandComponent
     */
    allPossible?: boolean;
    /**
     * return only unique values in the collection
     * @type {boolean}
     * @memberof ExpandComponent
     */
    unique?: boolean;
    /**
     * pagination - limit
     * @type {number}
     * @memberof ExpandComponent
     */
    limit?: number;
    /**
     * pagination - offset
     * @type {number}
     * @memberof ExpandComponent
     */
    offset?: number;
    /**
     * order the values returned in the collection
     * @type {string}
     * @memberof ExpandComponent
     */
    orderBy?: string;
}

/**
 * 
 * @export
 * @interface ExportConfig
 */
export interface ExportConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof ExportConfig
     */
    projectIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExportConfig
     */
    costFieldIds?: Array<string>;
    /**
     * 
     * @type {Array<Column>}
     * @memberof ExportConfig
     */
    columns?: Array<Column>;
    /**
     * 
     * @type {PlanningPeriod}
     * @memberof ExportConfig
     */
    planningPeriod?: PlanningPeriod;
    /**
     * 
     * @type {Array<Filter>}
     * @memberof ExportConfig
     */
    filters?: Array<Filter>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ExportFormatType {
    XLSX = <any> 'XLSX',
    CSV = <any> 'CSV',
    ZIP = <any> 'ZIP'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ExportType {
    PROJECT = <any> 'PROJECT',
    SCHEDULE = <any> 'SCHEDULE',
    SPENDPLAN = <any> 'SPEND_PLAN',
    GROUP = <any> 'GROUP'
}

/**
 * 
 * @export
 * @interface FieldAttributes
 */
export interface FieldAttributes {
    /**
     * 
     * @type {PlanningWindow}
     * @memberof FieldAttributes
     */
    planningWindow?: PlanningWindow;
    /**
     * 
     * @type {TimePeriod}
     * @memberof FieldAttributes
     */
    timePeriod?: TimePeriod;
    /**
     * 
     * @type {CategoryDisplayOrder}
     * @memberof FieldAttributes
     */
    categoryDisplayOrder?: CategoryDisplayOrder;
    /**
     * 
     * @type {DataFormats}
     * @memberof FieldAttributes
     */
    dataFormats?: DataFormats;
}

/**
 * 
 * @export
 * @interface FieldAttributesCategoryDisplayOrderUpdatedEvent
 */
export interface FieldAttributesCategoryDisplayOrderUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesCategoryDisplayOrderUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {CategoryDisplayOrder}
     * @memberof FieldAttributesCategoryDisplayOrderUpdatedEvent
     */
    categoryDisplayOrder?: CategoryDisplayOrder;
    /**
     * 
     * @type {CategoryDisplayOrder}
     * @memberof FieldAttributesCategoryDisplayOrderUpdatedEvent
     */
    previousCategoryDisplayOrder?: CategoryDisplayOrder;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesCategoryDisplayOrderUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesCategoryDisplayOrderUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldAttributesCategoryDisplayOrderUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldAttributesDataFormatsCurrencyUpdatedEvent
 */
export interface FieldAttributesDataFormatsCurrencyUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesDataFormatsCurrencyUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesDataFormatsCurrencyUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {Currency}
     * @memberof FieldAttributesDataFormatsCurrencyUpdatedEvent
     */
    currency?: Currency;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesDataFormatsCurrencyUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldAttributesDataFormatsCurrencyUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {Currency}
     * @memberof FieldAttributesDataFormatsCurrencyUpdatedEvent
     */
    previousCurrency?: Currency;
}

/**
 * 
 * @export
 * @interface FieldAttributesDataFormatsDateFormatUpdatedEvent
 */
export interface FieldAttributesDataFormatsDateFormatUpdatedEvent {
    /**
     * 
     * @type {DateFormat}
     * @memberof FieldAttributesDataFormatsDateFormatUpdatedEvent
     */
    previousDateFormat?: DateFormat;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesDataFormatsDateFormatUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {DateFormat}
     * @memberof FieldAttributesDataFormatsDateFormatUpdatedEvent
     */
    dateFormat?: DateFormat;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesDataFormatsDateFormatUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesDataFormatsDateFormatUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldAttributesDataFormatsDateFormatUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldAttributesDataFormatsDecimalPlacesUpdatedEvent
 */
export interface FieldAttributesDataFormatsDecimalPlacesUpdatedEvent {
    /**
     * 
     * @type {number}
     * @memberof FieldAttributesDataFormatsDecimalPlacesUpdatedEvent
     */
    previousDecimalPlaces?: number;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesDataFormatsDecimalPlacesUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldAttributesDataFormatsDecimalPlacesUpdatedEvent
     */
    decimalPlaces?: number;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesDataFormatsDecimalPlacesUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesDataFormatsDecimalPlacesUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldAttributesDataFormatsDecimalPlacesUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldAttributesDataFormatsNegativesUpdatedEvent
 */
export interface FieldAttributesDataFormatsNegativesUpdatedEvent {
    /**
     * 
     * @type {Negatives}
     * @memberof FieldAttributesDataFormatsNegativesUpdatedEvent
     */
    previousNegatives?: Negatives;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesDataFormatsNegativesUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Negatives}
     * @memberof FieldAttributesDataFormatsNegativesUpdatedEvent
     */
    negatives?: Negatives;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesDataFormatsNegativesUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesDataFormatsNegativesUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldAttributesDataFormatsNegativesUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldAttributesPlanningWindowEndUpdatedEvent
 */
export interface FieldAttributesPlanningWindowEndUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesPlanningWindowEndUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesPlanningWindowEndUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldAttributesPlanningWindowEndUpdatedEvent
     */
    end?: number;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesPlanningWindowEndUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldAttributesPlanningWindowEndUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {number}
     * @memberof FieldAttributesPlanningWindowEndUpdatedEvent
     */
    previousEnd?: number;
}

/**
 * 
 * @export
 * @interface FieldAttributesPlanningWindowStartUpdatedEvent
 */
export interface FieldAttributesPlanningWindowStartUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesPlanningWindowStartUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesPlanningWindowStartUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldAttributesPlanningWindowStartUpdatedEvent
     */
    start?: number;
    /**
     * 
     * @type {string}
     * @memberof FieldAttributesPlanningWindowStartUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldAttributesPlanningWindowStartUpdatedEvent
     */
    previousStart?: number;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldAttributesPlanningWindowStartUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldCalculationTypeUpdatedEvent
 */
export interface FieldCalculationTypeUpdatedEvent {
    /**
     * 
     * @type {CalculationType}
     * @memberof FieldCalculationTypeUpdatedEvent
     */
    calculationType?: CalculationType;
    /**
     * 
     * @type {string}
     * @memberof FieldCalculationTypeUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldCalculationTypeUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {CalculationType}
     * @memberof FieldCalculationTypeUpdatedEvent
     */
    previousCalculationType?: CalculationType;
    /**
     * 
     * @type {string}
     * @memberof FieldCalculationTypeUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {FieldType}
     * @memberof FieldCalculationTypeUpdatedEvent
     */
    fieldType?: FieldType;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldCalculationTypeUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldCategoryOptionsUpdatedEvent
 */
export interface FieldCategoryOptionsUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldCategoryOptionsUpdatedEvent
     */
    fieldName?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldCategoryOptionsUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldCategoryOptionsUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldCategoryOptionsUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldCreatedEvent
 */
export interface FieldCreatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldCreatedEvent
     */
    sourceId?: string;
    /**
     * 
     * @type {Field}
     * @memberof FieldCreatedEvent
     */
    parent?: Field;
    /**
     * 
     * @type {boolean}
     * @memberof FieldCreatedEvent
     */
    isFieldTypeApproved?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldCreatedEvent
     */
    isIdeaFieldRequired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FieldCreatedEvent
     */
    typePosition?: number;
    /**
     * 
     * @type {DataType}
     * @memberof FieldCreatedEvent
     */
    dataType?: DataType;
    /**
     * 
     * @type {TargetType}
     * @memberof FieldCreatedEvent
     */
    targetType?: TargetType;
    /**
     * 
     * @type {boolean}
     * @memberof FieldCreatedEvent
     */
    isFromImport?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FieldCreatedEvent
     */
    originalName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FieldCreatedEvent
     */
    isIdeaField?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FieldCreatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldCreatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldCreatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldCreatedEvent
     */
    position?: number;
    /**
     * 
     * @type {number}
     * @memberof FieldCreatedEvent
     */
    ideaFieldPosition?: number;
    /**
     * 
     * @type {FieldType}
     * @memberof FieldCreatedEvent
     */
    fieldType?: FieldType;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldCreatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldCreatedMessagePayload
 */
export interface FieldCreatedMessagePayload {
    /**
     * 
     * @type {Array<Field>}
     * @memberof FieldCreatedMessagePayload
     */
    fields: Array<Field>;
}

/**
 * 
 * @export
 * @interface FieldDataTypeUpdatedEvent
 */
export interface FieldDataTypeUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldDataTypeUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {DataType}
     * @memberof FieldDataTypeUpdatedEvent
     */
    previousDataType?: DataType;
    /**
     * 
     * @type {DataType}
     * @memberof FieldDataTypeUpdatedEvent
     */
    dataType?: DataType;
    /**
     * 
     * @type {string}
     * @memberof FieldDataTypeUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldDataTypeUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {FieldType}
     * @memberof FieldDataTypeUpdatedEvent
     */
    fieldType?: FieldType;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldDataTypeUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldDeletedEvent
 */
export interface FieldDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {FieldType}
     * @memberof FieldDeletedEvent
     */
    fieldType?: FieldType;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldDescriptionUpdatedEvent
 */
export interface FieldDescriptionUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldDescriptionUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldDescriptionUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldDescriptionUpdatedEvent
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldDescriptionUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldDescriptionUpdatedEvent
     */
    previousDescription?: string;
    /**
     * 
     * @type {FieldType}
     * @memberof FieldDescriptionUpdatedEvent
     */
    fieldType?: FieldType;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldDescriptionUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldGrade
 */
export interface FieldGrade {
    /**
     * 
     * @type {Field}
     * @memberof FieldGrade
     */
    field?: Field;
    /**
     * 
     * @type {Grade}
     * @memberof FieldGrade
     */
    grade?: Grade;
    /**
     * 
     * @type {number}
     * @memberof FieldGrade
     */
    min?: number;
    /**
     * 
     * @type {number}
     * @memberof FieldGrade
     */
    max?: number;
    /**
     * 
     * @type {number}
     * @memberof FieldGrade
     */
    current?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof FieldGrade
     */
    gradingBoundaries?: Array<number>;
    /**
     * 
     * @type {Array<BalanceFieldDetail>}
     * @memberof FieldGrade
     */
    balanceFieldDetails?: Array<BalanceFieldDetail>;
    /**
     * 
     * @type {Array<RiskFieldDetail>}
     * @memberof FieldGrade
     */
    riskFieldDetails?: Array<RiskFieldDetail>;
}

/**
 * 
 * @export
 * @interface FieldIdeaFieldPositionUpdatedEvent
 */
export interface FieldIdeaFieldPositionUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldIdeaFieldPositionUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldIdeaFieldPositionUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldIdeaFieldPositionUpdatedEvent
     */
    previousIdeaFieldPosition?: number;
    /**
     * 
     * @type {string}
     * @memberof FieldIdeaFieldPositionUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldIdeaFieldPositionUpdatedEvent
     */
    ideaFieldPosition?: number;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldIdeaFieldPositionUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldInsight
 */
export interface FieldInsight {
    /**
     * 
     * @type {Field}
     * @memberof FieldInsight
     */
    field?: Field;
    /**
     * 
     * @type {Grade}
     * @memberof FieldInsight
     */
    grade?: Grade;
    /**
     * 
     * @type {Array<number>}
     * @memberof FieldInsight
     */
    gradingBoundaries?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof FieldInsight
     */
    minValue?: number;
    /**
     * 
     * @type {number}
     * @memberof FieldInsight
     */
    maxValue?: number;
    /**
     * 
     * @type {number}
     * @memberof FieldInsight
     */
    value?: number;
    /**
     * 
     * @type {number}
     * @memberof FieldInsight
     */
    budget?: number;
    /**
     * 
     * @type {number}
     * @memberof FieldInsight
     */
    allocation?: number;
    /**
     * 
     * @type {Array<CategorizationInsight>}
     * @memberof FieldInsight
     */
    categorizationInsights?: Array<CategorizationInsight>;
}

/**
 * 
 * @export
 * @interface FieldIsAutoScaleUpdatedEvent
 */
export interface FieldIsAutoScaleUpdatedEvent {
    /**
     * 
     * @type {boolean}
     * @memberof FieldIsAutoScaleUpdatedEvent
     */
    isAutoScale?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FieldIsAutoScaleUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldIsAutoScaleUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldIsAutoScaleUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {FieldType}
     * @memberof FieldIsAutoScaleUpdatedEvent
     */
    fieldType?: FieldType;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldIsAutoScaleUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {boolean}
     * @memberof FieldIsAutoScaleUpdatedEvent
     */
    previousIsAutoScale?: boolean;
}

/**
 * 
 * @export
 * @interface FieldIsFieldTypeApprovedUpdatedEvent
 */
export interface FieldIsFieldTypeApprovedUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldIsFieldTypeApprovedUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FieldIsFieldTypeApprovedUpdatedEvent
     */
    isFieldTypeApproved?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldIsFieldTypeApprovedUpdatedEvent
     */
    previousIsFieldTypeApproved?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FieldIsFieldTypeApprovedUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldIsFieldTypeApprovedUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldIsFieldTypeApprovedUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldIsIdeaFieldRequiredUpdatedEvent
 */
export interface FieldIsIdeaFieldRequiredUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldIsIdeaFieldRequiredUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FieldIsIdeaFieldRequiredUpdatedEvent
     */
    previousIsIdeaFieldRequired?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldIsIdeaFieldRequiredUpdatedEvent
     */
    isIdeaFieldRequired?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FieldIsIdeaFieldRequiredUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldIsIdeaFieldRequiredUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldIsIdeaFieldRequiredUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldIsIdeaFieldUpdatedEvent
 */
export interface FieldIsIdeaFieldUpdatedEvent {
    /**
     * 
     * @type {boolean}
     * @memberof FieldIsIdeaFieldUpdatedEvent
     */
    isIdeaField?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FieldIsIdeaFieldUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldIsIdeaFieldUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldIsIdeaFieldUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FieldIsIdeaFieldUpdatedEvent
     */
    previousIsIdeaField?: boolean;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldIsIdeaFieldUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldNameUpdatedEvent
 */
export interface FieldNameUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldNameUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldNameUpdatedEvent
     */
    previousName?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldNameUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldNameUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {FieldType}
     * @memberof FieldNameUpdatedEvent
     */
    fieldType?: FieldType;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldNameUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldPositionUpdatedEvent
 */
export interface FieldPositionUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldPositionUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldPositionUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldPositionUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldPositionUpdatedEvent
     */
    position?: number;
    /**
     * 
     * @type {FieldType}
     * @memberof FieldPositionUpdatedEvent
     */
    fieldType?: FieldType;
    /**
     * 
     * @type {number}
     * @memberof FieldPositionUpdatedEvent
     */
    previousPosition?: number;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldPositionUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldRankedBasedOnSortOrderEvent
 */
export interface FieldRankedBasedOnSortOrderEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldRankedBasedOnSortOrderEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldRankedBasedOnSortOrderEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldRankedBasedOnSortOrderEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldRankedBasedOnSortOrderEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldTagAddedEvent
 */
export interface FieldTagAddedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldTagAddedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTagAddedEvent
     */
    tagParentName?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTagAddedEvent
     */
    tagId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTagAddedEvent
     */
    tagColor?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTagAddedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTagAddedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTagAddedEvent
     */
    tagName?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTagAddedEvent
     */
    tagParentId?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldTagAddedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldTagRemovedEvent
 */
export interface FieldTagRemovedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldTagRemovedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTagRemovedEvent
     */
    tagParentName?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTagRemovedEvent
     */
    tagId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTagRemovedEvent
     */
    tagColor?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTagRemovedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTagRemovedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTagRemovedEvent
     */
    tagName?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTagRemovedEvent
     */
    tagParentId?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldTagRemovedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldTargetTypeUpdatedEvent
 */
export interface FieldTargetTypeUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldTargetTypeUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTargetTypeUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {TargetType}
     * @memberof FieldTargetTypeUpdatedEvent
     */
    targetType?: TargetType;
    /**
     * 
     * @type {string}
     * @memberof FieldTargetTypeUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {TargetType}
     * @memberof FieldTargetTypeUpdatedEvent
     */
    previousTargetType?: TargetType;
    /**
     * 
     * @type {FieldType}
     * @memberof FieldTargetTypeUpdatedEvent
     */
    fieldType?: FieldType;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldTargetTypeUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum FieldType {
    NONE = <any> 'NONE',
    PROJECTNAME = <any> 'PROJECTNAME',
    OTHER = <any> 'OTHER',
    STATUS = <any> 'STATUS',
    VALUE = <any> 'VALUE',
    COST = <any> 'COST',
    RISK = <any> 'RISK',
    BALANCE = <any> 'BALANCE',
    ALLOCATE = <any> 'ALLOCATE',
    START = <any> 'START',
    END = <any> 'END',
    PORTFOLIONAME = <any> 'PORTFOLIONAME',
    TAGS = <any> 'TAGS',
    ATTACHMENTS = <any> 'ATTACHMENTS',
    LOCK = <any> 'LOCK',
    COSTAGGREGATE = <any> 'COSTAGGREGATE',
    SPENDPLANNED = <any> 'SPEND_PLANNED',
    SPENDACTUAL = <any> 'SPEND_ACTUAL',
    BUDGET = <any> 'BUDGET',
    COSTWINDOWSTART = <any> 'COST_WINDOW_START',
    COSTWINDOWEND = <any> 'COST_WINDOW_END',
    SCORE = <any> 'SCORE',
    FIELDSCORE = <any> 'FIELD_SCORE',
    COSTTABLE = <any> 'COST_TABLE',
    MODIFIEDAT = <any> 'MODIFIED_AT',
    ALLOCATEAGGREGATE = <any> 'ALLOCATE_AGGREGATE',
    SPENDPLANNEDAGGREGATE = <any> 'SPEND_PLANNED_AGGREGATE',
    SPENDACTUALAGGREGATE = <any> 'SPEND_ACTUAL_AGGREGATE',
    TIMEPERIODCOST = <any> 'TIME_PERIOD_COST',
    TIMEPERIODALLOCATE = <any> 'TIME_PERIOD_ALLOCATE',
    TIMEPERIODSPENDPLANNED = <any> 'TIME_PERIOD_SPEND_PLANNED',
    TIMEPERIODSPENDACTUAL = <any> 'TIME_PERIOD_SPEND_ACTUAL'
}

/**
 * 
 * @export
 * @interface FieldTypePositionUpdatedEvent
 */
export interface FieldTypePositionUpdatedEvent {
    /**
     * 
     * @type {number}
     * @memberof FieldTypePositionUpdatedEvent
     */
    previousTypePosition?: number;
    /**
     * 
     * @type {string}
     * @memberof FieldTypePositionUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldTypePositionUpdatedEvent
     */
    typePosition?: number;
    /**
     * 
     * @type {string}
     * @memberof FieldTypePositionUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTypePositionUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {FieldType}
     * @memberof FieldTypePositionUpdatedEvent
     */
    fieldType?: FieldType;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldTypePositionUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldTypeUpdatedEvent
 */
export interface FieldTypeUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof FieldTypeUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldTypeUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {FieldType}
     * @memberof FieldTypeUpdatedEvent
     */
    previousFieldType?: FieldType;
    /**
     * 
     * @type {string}
     * @memberof FieldTypeUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {FieldType}
     * @memberof FieldTypeUpdatedEvent
     */
    fieldType?: FieldType;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof FieldTypeUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface FieldValue
 */
export interface FieldValue {
    /**
     * 
     * @type {Field}
     * @memberof FieldValue
     */
    field?: Field;
    /**
     * 
     * @type {Project}
     * @memberof FieldValue
     */
    project?: Project;
    /**
     * 
     * @type {string}
     * @memberof FieldValue
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldValue
     */
    numericValue?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FieldValue
     */
    booleanValue?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof FieldValue
     */
    numericValues?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FieldValue
     */
    values?: Array<string>;
    /**
     * 
     * @type {TimePeriod}
     * @memberof FieldValue
     */
    timePeriod?: TimePeriod;
    /**
     * 
     * @type {FieldValues}
     * @memberof FieldValue
     */
    details?: FieldValues;
    /**
     * 
     * @type {string}
     * @memberof FieldValue
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldValue
     */
    modifiedAt?: string;
}

/**
 * 
 * @export
 * @interface FieldValuePatchItem
 */
export interface FieldValuePatchItem {
    /**
     * 
     * @type {string}
     * @memberof FieldValuePatchItem
     */
    projectId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldValuePatchItem
     */
    fieldId?: string;
    /**
     * 
     * @type {TimePeriod}
     * @memberof FieldValuePatchItem
     */
    timePeriod?: TimePeriod;
    /**
     * 
     * @type {Operations}
     * @memberof FieldValuePatchItem
     */
    operations?: Operations;
}

/**
 * 
 * @export
 * @interface FieldValuesCollectionInfo
 */
export interface FieldValuesCollectionInfo {
    /**
     * 
     * @type {boolean}
     * @memberof FieldValuesCollectionInfo
     */
    hasDuplicateValues?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldValuesCollectionInfo
     */
    hasBlankValues?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FieldValuesCollectionInfo
     */
    totalValue?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FieldValuesCollectionInfo
     */
    balanceUniquenessExceeded?: boolean;
}

/**
 * 
 * @export
 * @interface FieldValuesDataUpdatedMessagePayload
 */
export interface FieldValuesDataUpdatedMessagePayload {
    /**
     * 
     * @type {string}
     * @memberof FieldValuesDataUpdatedMessagePayload
     */
    portfolioPlanId: string;
    /**
     * 
     * @type {string}
     * @memberof FieldValuesDataUpdatedMessagePayload
     */
    dataId: string;
}

/**
 * 
 * @export
 * @interface FieldValuesProjectDeletedMessagePayload
 */
export interface FieldValuesProjectDeletedMessagePayload {
    /**
     * 
     * @type {string}
     * @memberof FieldValuesProjectDeletedMessagePayload
     */
    projectId: string;
    /**
     * 
     * @type {Array<Field>}
     * @memberof FieldValuesProjectDeletedMessagePayload
     */
    fields: Array<Field>;
}

/**
 * 
 * @export
 * @interface FieldValuesUpdatedMessagePayload
 */
export interface FieldValuesUpdatedMessagePayload {
    /**
     * 
     * @type {string}
     * @memberof FieldValuesUpdatedMessagePayload
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldValuesUpdatedMessagePayload
     */
    portfolioPlanId?: string;
    /**
     * 
     * @type {Array<FieldValue>}
     * @memberof FieldValuesUpdatedMessagePayload
     */
    fieldValues: Array<FieldValue>;
}

/**
 * 
 * @export
 * @interface FieldWeight
 */
export interface FieldWeight {
    /**
     * 
     * @type {string}
     * @memberof FieldWeight
     */
    fieldId?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldWeight
     */
    value?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FieldWeight
     */
    isLocked?: boolean;
}

/**
 * 
 * @export
 * @interface FieldsDeletedMessagePayload
 */
export interface FieldsDeletedMessagePayload {
    /**
     * 
     * @type {string}
     * @memberof FieldsDeletedMessagePayload
     */
    portfolioId?: string;
    /**
     * 
     * @type {Array<Field>}
     * @memberof FieldsDeletedMessagePayload
     */
    fields: Array<Field>;
}

/**
 * 
 * @export
 * @interface FieldsUpdatedMessagePayload
 */
export interface FieldsUpdatedMessagePayload {
    /**
     * 
     * @type {string}
     * @memberof FieldsUpdatedMessagePayload
     */
    portfolioId?: string;
    /**
     * 
     * @type {Array<Field>}
     * @memberof FieldsUpdatedMessagePayload
     */
    fields: Array<Field>;
}

/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {FilterType}
     * @memberof Filter
     */
    type?: FilterType;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum FilterType {
    WITHINDATERANGE = <any> 'WITHIN_DATE_RANGE',
    OUTSIDEDATERANGE = <any> 'OUTSIDE_DATE_RANGE'
}

/**
 * 
 * @export
 * @interface Goal
 */
export interface Goal {
    /**
     * 
     * @type {number}
     * @memberof Goal
     */
    date?: number;
    /**
     * 
     * @type {number}
     * @memberof Goal
     */
    value?: number;
}

/**
 * 
 * @export
 * @interface GoalAddedEvent
 */
export interface GoalAddedEvent {
    /**
     * 
     * @type {number}
     * @memberof GoalAddedEvent
     */
    date?: number;
    /**
     * 
     * @type {string}
     * @memberof GoalAddedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof GoalAddedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof GoalAddedEvent
     */
    value?: number;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof GoalAddedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface GoalDeletedEvent
 */
export interface GoalDeletedEvent {
    /**
     * 
     * @type {number}
     * @memberof GoalDeletedEvent
     */
    date?: number;
    /**
     * 
     * @type {string}
     * @memberof GoalDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof GoalDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof GoalDeletedEvent
     */
    value?: number;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof GoalDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface GoalUpdatedEvent
 */
export interface GoalUpdatedEvent {
    /**
     * 
     * @type {number}
     * @memberof GoalUpdatedEvent
     */
    date?: number;
    /**
     * 
     * @type {string}
     * @memberof GoalUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof GoalUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof GoalUpdatedEvent
     */
    previousValue?: number;
    /**
     * 
     * @type {number}
     * @memberof GoalUpdatedEvent
     */
    value?: number;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof GoalUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface GoalsUpdatedMessagePayload
 */
export interface GoalsUpdatedMessagePayload {
    /**
     * 
     * @type {Array<Goal>}
     * @memberof GoalsUpdatedMessagePayload
     */
    goals: Array<Goal>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Grade {
    A = <any> 'A',
    B = <any> 'B',
    C = <any> 'C',
    D = <any> 'D',
    F = <any> 'F'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum GradingType {
    GRADED = <any> 'GRADED',
    NOTENOUGHBUDGET = <any> 'NOT_ENOUGH_BUDGET',
    TOOMUCHBUDGETSIMPLE = <any> 'TOO_MUCH_BUDGET_SIMPLE',
    TOOMUCHBUDGETCOMPLEX = <any> 'TOO_MUCH_BUDGET_COMPLEX',
    NOTGRADABLECOMBINED = <any> 'NOT_GRADABLE_COMBINED'
}

/**
 * 
 * @export
 * @interface Header
 */
export interface Header {
    /**
     * 
     * @type {string}
     * @memberof Header
     */
    destination: string;
    /**
     * 
     * @type {string}
     * @memberof Header
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof Header
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof Header
     */
    lastName?: string;
}

/**
 * 
 * @export
 * @interface IdeaFormFieldRequest
 */
export interface IdeaFormFieldRequest {
    /**
     * 
     * @type {string}
     * @memberof IdeaFormFieldRequest
     */
    portfolioId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IdeaFormFieldRequest
     */
    fieldIds?: Array<string>;
    /**
     * 
     * @type {Array<FieldType>}
     * @memberof IdeaFormFieldRequest
     */
    fieldTypes?: Array<FieldType>;
    /**
     * 
     * @type {boolean}
     * @memberof IdeaFormFieldRequest
     */
    isIncluded?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IdeaFormFieldRequest
     */
    isRequired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IdeaFormFieldRequest
     */
    ideaFieldPosition?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ImportType {
    PROJECT = <any> 'PROJECT',
    BUDGET = <any> 'BUDGET',
    BUDGETAMOUNTS = <any> 'BUDGET_AMOUNTS',
    COST = <any> 'COST',
    COSTAGGREGATE = <any> 'COSTAGGREGATE',
    ALLOCATE = <any> 'ALLOCATE',
    SPENDPLANNED = <any> 'SPEND_PLANNED',
    SPENDACTUAL = <any> 'SPEND_ACTUAL'
}

/**
 * 
 * @export
 * @interface Insight
 */
export interface Insight {
    /**
     * 
     * @type {InsightType}
     * @memberof Insight
     */
    insightType?: InsightType;
    /**
     * 
     * @type {Grade}
     * @memberof Insight
     */
    grade?: Grade;
    /**
     * 
     * @type {number}
     * @memberof Insight
     */
    score?: number;
    /**
     * 
     * @type {Array<FieldInsight>}
     * @memberof Insight
     */
    fieldInsights?: Array<FieldInsight>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum InsightType {
    OVERALL = <any> 'OVERALL',
    VALUE = <any> 'VALUE',
    COST = <any> 'COST',
    RISK = <any> 'RISK',
    BALANCE = <any> 'BALANCE',
    OTHER = <any> 'OTHER'
}

/**
 * 
 * @export
 * @interface JiraComment
 */
export interface JiraComment {
    /**
     * 
     * @type {string}
     * @memberof JiraComment
     */
    jiraEpicId?: string;
    /**
     * 
     * @type {string}
     * @memberof JiraComment
     */
    commentText?: string;
}

/**
 * 
 * @export
 * @interface KloudlessFile
 */
export interface KloudlessFile {
    /**
     * 
     * @type {string}
     * @memberof KloudlessFile
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof KloudlessFile
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof KloudlessFile
     */
    fileId?: string;
}

/**
 * 
 * @export
 * @interface LikertScaleFieldInsight
 */
export interface LikertScaleFieldInsight {
    /**
     * 
     * @type {string}
     * @memberof LikertScaleFieldInsight
     */
    fieldId?: string;
    /**
     * 
     * @type {Array<LikertScaleInsight>}
     * @memberof LikertScaleFieldInsight
     */
    likertScaleInsights?: Array<LikertScaleInsight>;
}

/**
 * 
 * @export
 * @interface LikertScaleInsight
 */
export interface LikertScaleInsight {
    /**
     * 
     * @type {LikertScaleType}
     * @memberof LikertScaleInsight
     */
    type: LikertScaleType;
    /**
     * 
     * @type {Array<string>}
     * @memberof LikertScaleInsight
     */
    projectIds?: Array<string>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum LikertScaleType {
    VERYLOW = <any> 'VERY_LOW',
    LOW = <any> 'LOW',
    MEDIUM = <any> 'MEDIUM',
    HIGH = <any> 'HIGH',
    VERYHIGH = <any> 'VERY_HIGH'
}

/**
 * 
 * @export
 * @interface Mail
 */
export interface Mail {
    /**
     * 
     * @type {string}
     * @memberof Mail
     */
    from?: string;
    /**
     * 
     * @type {string}
     * @memberof Mail
     */
    replyTo?: string;
    /**
     * 
     * @type {string}
     * @memberof Mail
     */
    replyToDisplayName?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof Mail
     */
    to?: Array<User>;
    /**
     * 
     * @type {Array<User>}
     * @memberof Mail
     */
    cc?: Array<User>;
    /**
     * 
     * @type {Array<User>}
     * @memberof Mail
     */
    bcc?: Array<User>;
    /**
     * 
     * @type {string}
     * @memberof Mail
     */
    subject?: string;
    /**
     * 
     * @type {string}
     * @memberof Mail
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof Mail
     */
    templateName?: string;
    /**
     * 
     * @type {Array<TemplateProperty>}
     * @memberof Mail
     */
    templateProperties?: Array<TemplateProperty>;
}

/**
 * 
 * @export
 * @interface MappedProject
 */
export interface MappedProject {
    /**
     * 
     * @type {string}
     * @memberof MappedProject
     */
    href?: string;
    /**
     * 
     * @type {string}
     * @memberof MappedProject
     */
    scheduleView?: string;
    /**
     * 
     * @type {string}
     * @memberof MappedProject
     */
    projectView?: string;
}

/**
 * 
 * @export
 * @interface Mappings
 */
export interface Mappings {
    /**
     * 
     * @type {number}
     * @memberof Mappings
     */
    size?: number;
    /**
     * 
     * @type {Array<Mapping>}
     * @memberof Mappings
     */
    items?: Array<Mapping>;
}

/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {MessageType}
     * @memberof Message
     */
    type: MessageType;
    /**
     * 
     * @type {Header}
     * @memberof Message
     */
    header: Header;
    /**
     * 
     * @type {any}
     * @memberof Message
     */
    payload: any;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum MessageDestinationType {
    USER = <any> 'USER',
    GROUPUSER = <any> 'GROUP_USER',
    GROUP = <any> 'GROUP',
    PORTFOLIO = <any> 'PORTFOLIO',
    PORTFOLIOUSER = <any> 'PORTFOLIO_USER',
    PORTFOLIOPLAN = <any> 'PORTFOLIOPLAN'
}

/**
 * 
 * @export
 * @interface MessageToken
 */
export interface MessageToken {
    /**
     * 
     * @type {string}
     * @memberof MessageToken
     */
    token: string;
    /**
     * 
     * @type {number}
     * @memberof MessageToken
     */
    expirationInMillis: number;
    /**
     * 
     * @type {string}
     * @memberof MessageToken
     */
    destination: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum MessageType {
    FieldCreatedMessage = <any> 'FieldCreatedMessage',
    BudgetFieldCreatedMessage = <any> 'BudgetFieldCreatedMessage',
    FieldsUpdatedMessage = <any> 'FieldsUpdatedMessage',
    BudgetFieldsUpdatedMessage = <any> 'BudgetFieldsUpdatedMessage',
    FieldsDeletedMessage = <any> 'FieldsDeletedMessage',
    BudgetFieldsDeletedMessage = <any> 'BudgetFieldsDeletedMessage',
    ProjectsCreatedMessage = <any> 'ProjectsCreatedMessage',
    ProjectsDeletedMessage = <any> 'ProjectsDeletedMessage',
    AddedToPortfolioPlanMessage = <any> 'AddedToPortfolioPlanMessage',
    RemovedFromPortfolioPlanMessage = <any> 'RemovedFromPortfolioPlanMessage',
    PortfolioPlansUpdatedMessage = <any> 'PortfolioPlansUpdatedMessage',
    PortfolioUpdatedMessage = <any> 'PortfolioUpdatedMessage',
    PortfolioArchivedMessage = <any> 'PortfolioArchivedMessage',
    AddedToPortfolioMessage = <any> 'AddedToPortfolioMessage',
    RemovedFromPortfolioMessage = <any> 'RemovedFromPortfolioMessage',
    FieldValuesUpdatedMessage = <any> 'FieldValuesUpdatedMessage',
    FieldValuesDataUpdatedMessage = <any> 'FieldValuesDataUpdatedMessage',
    ResourcePoolsUpdatedMessage = <any> 'ResourcePoolsUpdatedMessage',
    DataUpdatedMessage = <any> 'DataUpdatedMessage',
    ToastMessage = <any> 'ToastMessage',
    ResourcePoolsCreatedMessage = <any> 'ResourcePoolsCreatedMessage',
    ResourcePoolsDeletedMessage = <any> 'ResourcePoolsDeletedMessage',
    SpreadsheetReportProgressMessage = <any> 'SpreadsheetReportProgressMessage',
    CommentAddedMessage = <any> 'CommentAddedMessage',
    CommentEditedMessage = <any> 'CommentEditedMessage',
    CommentDeletedMessage = <any> 'CommentDeletedMessage',
    NotificationsMessage = <any> 'NotificationsMessage',
    TagAddedMessage = <any> 'TagAddedMessage',
    TagUpdatedMessage = <any> 'TagUpdatedMessage',
    TagDeletedMessage = <any> 'TagDeletedMessage',
    CategoryOptionAddedMessage = <any> 'CategoryOptionAddedMessage',
    CategoryOptionUpdatedMessage = <any> 'CategoryOptionUpdatedMessage',
    CategoryOptionDeletedMessage = <any> 'CategoryOptionDeletedMessage',
    DraftProjectsSubmittedMessage = <any> 'DraftProjectsSubmittedMessage',
    ProjectAttachmentAddedMessage = <any> 'ProjectAttachmentAddedMessage',
    ProjectAttachmentRemovedMessage = <any> 'ProjectAttachmentRemovedMessage',
    AttachmentUpdatedMessage = <any> 'AttachmentUpdatedMessage',
    PortfolioPlanUserCreatedMessage = <any> 'PortfolioPlanUserCreatedMessage',
    PortfolioPlanUserDeletedMessage = <any> 'PortfolioPlanUserDeletedMessage',
    PortfolioPlanUserUpdatedMessage = <any> 'PortfolioPlanUserUpdatedMessage',
    ProjectAccessRevokedMessage = <any> 'ProjectAccessRevokedMessage',
    ProjectAccessGrantedMessage = <any> 'ProjectAccessGrantedMessage',
    ProjectContributorsUpdatedMessage = <any> 'ProjectContributorsUpdatedMessage',
    CustomNamesUpdatedMessage = <any> 'CustomNamesUpdatedMessage',
    ProjectDependenciesUpdatedMessage = <any> 'ProjectDependenciesUpdatedMessage',
    ProjectScoresUpdatedMessage = <any> 'ProjectScoresUpdatedMessage',
    ProjectScoresUpdatedAggregatedMessage = <any> 'ProjectScoresUpdatedAggregatedMessage',
    ProjectRanksUpdatedAggregatedMessage = <any> 'ProjectRanksUpdatedAggregatedMessage',
    ProjectDataCacheMessage = <any> 'ProjectDataCacheMessage',
    GoalsUpdatedMessage = <any> 'GoalsUpdatedMessage',
    FieldValuesProjectDeletedMessage = <any> 'FieldValuesProjectDeletedMessage',
    ResourcePoolFieldValuesUpdatedMessage = <any> 'ResourcePoolFieldValuesUpdatedMessage',
    ScoreWeightsUpdatedMessage = <any> 'ScoreWeightsUpdatedMessage',
    UserUpdatedMessage = <any> 'UserUpdatedMessage'
}

/**
 * 
 * @export
 * @interface MinifiedFieldValue
 */
export interface MinifiedFieldValue {
    /**
     * Text value
     * @type {string}
     * @memberof MinifiedFieldValue
     */
    v?: string;
    /**
     * Numeric Value
     * @type {number}
     * @memberof MinifiedFieldValue
     */
    nv?: number;
    /**
     * Boolean Value
     * @type {boolean}
     * @memberof MinifiedFieldValue
     */
    bv?: boolean;
    /**
     * Yearly cost/allocate data
     * @type {{ [key: string]: MinifiedYearlyFieldValue; }}
     * @memberof MinifiedFieldValue
     */
    yrs?: { [key: string]: MinifiedYearlyFieldValue; };
    /**
     * Monthly cost/allocate data
     * @type {{ [key: string]: number; }}
     * @memberof MinifiedFieldValue
     */
    mns?: { [key: string]: number; };
    /**
     * Text values array
     * @type {Array<string>}
     * @memberof MinifiedFieldValue
     */
    vs?: Array<string>;
    /**
     * Numeric values array
     * @type {Array<number>}
     * @memberof MinifiedFieldValue
     */
    nvs?: Array<number>;
}

/**
 * 
 * @export
 * @interface MinifiedProject
 */
export interface MinifiedProject {
    /**
     * project id
     * @type {string}
     * @memberof MinifiedProject
     */
    id?: string;
    /**
     * Project name
     * @type {string}
     * @memberof MinifiedProject
     */
    n?: string;
    /**
     * Project position
     * @type {number}
     * @memberof MinifiedProject
     */
    pos?: number;
    /**
     * Project modified time in epoch millis
     * @type {number}
     * @memberof MinifiedProject
     */
    mt?: number;
    /**
     * Minified field values. Key is field index.
     * @type {{ [key: string]: MinifiedFieldValue; }}
     * @memberof MinifiedProject
     */
    fvs?: { [key: string]: MinifiedFieldValue; };
    /**
     * Contibuting user indices.
     * @type {Array<string>}
     * @memberof MinifiedProject
     */
    cus?: Array<string>;
    /**
     * Depends On project Ids
     * @type {Array<string>}
     * @memberof MinifiedProject
     */
    doi?: Array<string>;
    /**
     * Has Dependent Ids
     * @type {Array<string>}
     * @memberof MinifiedProject
     */
    hdi?: Array<string>;
    /**
     * Rank of the project
     * @type {number}
     * @memberof MinifiedProject
     */
    r?: number;
}

/**
 * Optimized object with minified project data
 * @export
 * @interface MinifiedProjects
 */
export interface MinifiedProjects {
    /**
     * Field index
     * @type {{ [key: string]: string; }}
     * @memberof MinifiedProjects
     */
    fidx?: { [key: string]: string; };
    /**
     * TimePeriod index
     * @type {{ [key: string]: number; }}
     * @memberof MinifiedProjects
     */
    tidx?: { [key: string]: number; };
    /**
     * User index
     * @type {{ [key: string]: string; }}
     * @memberof MinifiedProjects
     */
    uidx?: { [key: string]: string; };
    /**
     * Minified projects.
     * @type {Array<MinifiedProject>}
     * @memberof MinifiedProjects
     */
    prs?: Array<MinifiedProject>;
    /**
     * Total projects count
     * @type {number}
     * @memberof MinifiedProjects
     */
    tot?: number;
    /**
     * pagination limit
     * @type {number}
     * @memberof MinifiedProjects
     */
    lim?: number;
    /**
     * pagination offset
     * @type {number}
     * @memberof MinifiedProjects
     */
    ofs?: number;
}

/**
 * Minified yearly cost/allocate data
 * @export
 * @interface MinifiedYearlyFieldValue
 */
export interface MinifiedYearlyFieldValue {
    /**
     * Yearly aggregate numeric Value
     * @type {number}
     * @memberof MinifiedYearlyFieldValue
     */
    nv?: number;
    /**
     * Number of monthly values in the year
     * @type {number}
     * @memberof MinifiedYearlyFieldValue
     */
    ct?: number;
    /**
     * TimePeriod index of the first month in the year
     * @type {string}
     * @memberof MinifiedYearlyFieldValue
     */
    fmn?: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Negatives {
    DEFAULT = <any> 'DEFAULT',
    PARENTHESIS = <any> 'PARENTHESIS'
}

/**
 * 
 * @export
 * @interface NotificationsMessagePayload
 */
export interface NotificationsMessagePayload {
    /**
     * 
     * @type {Array<Activity>}
     * @memberof NotificationsMessagePayload
     */
    activities?: Array<Activity>;
    /**
     * 
     * @type {string}
     * @memberof NotificationsMessagePayload
     */
    portfolioId?: string;
}

/**
 * 
 * @export
 * @interface Operation
 */
export interface Operation {
    /**
     * 
     * @type {OperationType}
     * @memberof Operation
     */
    op: OperationType;
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    from?: string;
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    path: string;
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    value?: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum OperationType {
    ADD = <any> 'ADD',
    REMOVE = <any> 'REMOVE',
    REPLACE = <any> 'REPLACE',
    MOVE = <any> 'MOVE',
    COPY = <any> 'COPY',
    TEST = <any> 'TEST'
}

/**
 * 
 * @export
 * @interface Operations
 */
export interface Operations extends Array<Operation> {
}

/**
 * 
 * @export
 * @interface PatchItem
 */
export interface PatchItem {
    /**
     * 
     * @type {string}
     * @memberof PatchItem
     */
    id?: string;
    /**
     * 
     * @type {Operations}
     * @memberof PatchItem
     */
    operations?: Operations;
}

/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {PermissionType}
     * @memberof Permission
     */
    type: PermissionType;
    /**
     * 
     * @type {Array<string>}
     * @memberof Permission
     */
    fieldIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Permission
     */
    projectIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Permission
     */
    categoryOptionIds?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Permission
     */
    enabled?: boolean;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PermissionType {
    ALLFIELDS = <any> 'ALL_FIELDS',
    ALLPROJECTS = <any> 'ALL_PROJECTS',
    FIELDS = <any> 'FIELDS',
    PROJECTS = <any> 'PROJECTS',
    ALLOCATE = <any> 'ALLOCATE',
    BUDGET = <any> 'BUDGET',
    CATEGORIES = <any> 'CATEGORIES'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PlanType {
    OVERALL = <any> 'OVERALL',
    VALUE = <any> 'VALUE',
    COST = <any> 'COST',
    RISK = <any> 'RISK',
    BALANCE = <any> 'BALANCE'
}

/**
 * Deprecated. Use TimePeriod.
 * @export
 * @interface PlanningPeriod
 */
export interface PlanningPeriod {
    /**
     * 
     * @type {number}
     * @memberof PlanningPeriod
     */
    startDate?: number;
    /**
     * 
     * @type {number}
     * @memberof PlanningPeriod
     */
    endDate?: number;
    /**
     * 
     * @type {TimePeriodType}
     * @memberof PlanningPeriod
     */
    timePeriodType?: TimePeriodType;
}

/**
 * Deprecated. Use TimePeriod.
 * @export
 * @interface PlanningWindow
 */
export interface PlanningWindow {
    /**
     * 
     * @type {number}
     * @memberof PlanningWindow
     */
    start?: number;
    /**
     * 
     * @type {number}
     * @memberof PlanningWindow
     */
    end?: number;
}

/**
 * 
 * @export
 * @interface PortfolioArchivedEvent
 */
export interface PortfolioArchivedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioArchivedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortfolioArchivedEvent
     */
    isArchived?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortfolioArchivedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioArchivedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioArchivedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioArchivedMessagePayload
 */
export interface PortfolioArchivedMessagePayload {
    /**
     * 
     * @type {Portfolio}
     * @memberof PortfolioArchivedMessagePayload
     */
    portfolio: Portfolio;
}

/**
 * 
 * @export
 * @interface PortfolioBudgetTimePeriodTypeUpdatedEvent
 */
export interface PortfolioBudgetTimePeriodTypeUpdatedEvent {
    /**
     * 
     * @type {TimePeriodType}
     * @memberof PortfolioBudgetTimePeriodTypeUpdatedEvent
     */
    budgetTimePeriodType?: TimePeriodType;
    /**
     * 
     * @type {string}
     * @memberof PortfolioBudgetTimePeriodTypeUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioBudgetTimePeriodTypeUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {TimePeriodType}
     * @memberof PortfolioBudgetTimePeriodTypeUpdatedEvent
     */
    previousTimePeriodType?: TimePeriodType;
    /**
     * 
     * @type {string}
     * @memberof PortfolioBudgetTimePeriodTypeUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioBudgetTimePeriodTypeUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioCreatedEvent
 */
export interface PortfolioCreatedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioCreatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioCreatedEvent
     */
    userRegistrationToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortfolioCreatedEvent
     */
    isArchived?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortfolioCreatedEvent
     */
    groupId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioCreatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioCreatedEvent
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortfolioCreatedEvent
     */
    isCombined?: boolean;
    /**
     * 
     * @type {Attributes}
     * @memberof PortfolioCreatedEvent
     */
    attributes?: Attributes;
    /**
     * 
     * @type {string}
     * @memberof PortfolioCreatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioCreatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioIsMonthlySpendPlanUpdatedEvent
 */
export interface PortfolioIsMonthlySpendPlanUpdatedEvent {
    /**
     * 
     * @type {boolean}
     * @memberof PortfolioIsMonthlySpendPlanUpdatedEvent
     */
    isMonthlySpendPlan?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortfolioIsMonthlySpendPlanUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioIsMonthlySpendPlanUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioIsMonthlySpendPlanUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortfolioIsMonthlySpendPlanUpdatedEvent
     */
    previousIsMonthlySpendPlan?: boolean;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioIsMonthlySpendPlanUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioNameUpdatedEvent
 */
export interface PortfolioNameUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioNameUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioNameUpdatedEvent
     */
    previousName?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioNameUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioNameUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioNameUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioPlanCreatedEvent
 */
export interface PortfolioPlanCreatedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanCreatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanCreatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanCreatedEvent
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortfolioPlanCreatedEvent
     */
    isBaseline?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanCreatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanCreatedEvent
     */
    portfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanCreatedEvent
     */
    parentPortfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioPlanDataImportedEvent
 */
export interface PortfolioPlanDataImportedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanDataImportedEvent
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanDataImportedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanDataImportedEvent
     */
    sheetName?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanDataImportedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanDataImportedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioPlanDeletedEvent
 */
export interface PortfolioPlanDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioPlanDescriptionUpdatedEvent
 */
export interface PortfolioPlanDescriptionUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanDescriptionUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanDescriptionUpdatedEvent
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanDescriptionUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanDescriptionUpdatedEvent
     */
    previousDescription?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanDescriptionUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioPlanGrade
 */
export interface PortfolioPlanGrade {
    /**
     * 
     * @type {PlanType}
     * @memberof PortfolioPlanGrade
     */
    type?: PlanType;
    /**
     * 
     * @type {Grade}
     * @memberof PortfolioPlanGrade
     */
    grade?: Grade;
    /**
     * 
     * @type {FieldGrades}
     * @memberof PortfolioPlanGrade
     */
    fieldGrades?: FieldGrades;
    /**
     * 
     * @type {number}
     * @memberof PortfolioPlanGrade
     */
    score?: number;
}

/**
 * 
 * @export
 * @interface PortfolioPlanNameUpdatedEvent
 */
export interface PortfolioPlanNameUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanNameUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanNameUpdatedEvent
     */
    previousName?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanNameUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanNameUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanNameUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioPlanRebaselinedEvent
 */
export interface PortfolioPlanRebaselinedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanRebaselinedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanRebaselinedEvent
     */
    baselinePortfolioPlanName?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanRebaselinedEvent
     */
    whatIfPortfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanRebaselinedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanRebaselinedEvent
     */
    whatIfPortfolioPlanName?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanRebaselinedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioPlanUserCreatedMessagePayload
 */
export interface PortfolioPlanUserCreatedMessagePayload {
    /**
     * 
     * @type {PortfolioPlanUser}
     * @memberof PortfolioPlanUserCreatedMessagePayload
     */
    portfolioPlanUser: PortfolioPlanUser;
}

/**
 * 
 * @export
 * @interface PortfolioPlanUserCreatedV2Event
 */
export interface PortfolioPlanUserCreatedV2Event {
    /**
     * 
     * @type {Array<PortfolioPlanUserRole>}
     * @memberof PortfolioPlanUserCreatedV2Event
     */
    portfolioPlanUserRoleList?: Array<PortfolioPlanUserRole>;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanUserCreatedV2Event
     */
    portfolioId?: string;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof PortfolioPlanUserCreatedV2Event
     */
    permissions?: Array<Permission>;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanUserCreatedV2Event
     */
    id?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PortfolioPlanUserCreatedV2Event
     */
    contributingProjectIds?: Array<string>;
    /**
     * 
     * @type {User}
     * @memberof PortfolioPlanUserCreatedV2Event
     */
    user?: User;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanUserCreatedV2Event
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioPlanUserDeletedEvent
 */
export interface PortfolioPlanUserDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanUserDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanUserDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {User}
     * @memberof PortfolioPlanUserDeletedEvent
     */
    user?: User;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanUserDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioPlanUserDeletedMessagePayload
 */
export interface PortfolioPlanUserDeletedMessagePayload {
    /**
     * 
     * @type {PortfolioPlanUser}
     * @memberof PortfolioPlanUserDeletedMessagePayload
     */
    portfolioPlanUser: PortfolioPlanUser;
}

/**
 * 
 * @export
 * @interface PortfolioPlanUserDraftProjectIdsUpdatedEvent
 */
export interface PortfolioPlanUserDraftProjectIdsUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanUserDraftProjectIdsUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PortfolioPlanUserDraftProjectIdsUpdatedEvent
     */
    previousDraftProjectIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanUserDraftProjectIdsUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {User}
     * @memberof PortfolioPlanUserDraftProjectIdsUpdatedEvent
     */
    user?: User;
    /**
     * 
     * @type {Array<string>}
     * @memberof PortfolioPlanUserDraftProjectIdsUpdatedEvent
     */
    draftProjectIds?: Array<string>;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanUserDraftProjectIdsUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioPlanUserFieldPermissionsUpdatedEvent
 */
export interface PortfolioPlanUserFieldPermissionsUpdatedEvent {
    /**
     * 
     * @type {Array<PortfolioPlanUserRole>}
     * @memberof PortfolioPlanUserFieldPermissionsUpdatedEvent
     */
    portfolioPlanUserRoleList?: Array<PortfolioPlanUserRole>;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanUserFieldPermissionsUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof PortfolioPlanUserFieldPermissionsUpdatedEvent
     */
    previousPermissions?: Array<Permission>;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanUserFieldPermissionsUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {User}
     * @memberof PortfolioPlanUserFieldPermissionsUpdatedEvent
     */
    user?: User;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanUserFieldPermissionsUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof PortfolioPlanUserFieldPermissionsUpdatedEvent
     */
    fieldPermissions?: Array<Permission>;
}

/**
 * 
 * @export
 * @interface PortfolioPlanUserProjectPermissionsUpdatedEvent
 */
export interface PortfolioPlanUserProjectPermissionsUpdatedEvent {
    /**
     * 
     * @type {Array<PortfolioPlanUserRole>}
     * @memberof PortfolioPlanUserProjectPermissionsUpdatedEvent
     */
    portfolioPlanUserRoleList?: Array<PortfolioPlanUserRole>;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof PortfolioPlanUserProjectPermissionsUpdatedEvent
     */
    projectPermissions?: Array<Permission>;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanUserProjectPermissionsUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof PortfolioPlanUserProjectPermissionsUpdatedEvent
     */
    previousPermissions?: Array<Permission>;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanUserProjectPermissionsUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {User}
     * @memberof PortfolioPlanUserProjectPermissionsUpdatedEvent
     */
    user?: User;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanUserProjectPermissionsUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PortfolioPlanUserRole {
    OWNER = <any> 'OWNER',
    VIEWER = <any> 'VIEWER',
    VIEWERCOMBINED = <any> 'VIEWER_COMBINED',
    CONTRIBUTOR = <any> 'CONTRIBUTOR',
    PARTICIPANT = <any> 'PARTICIPANT'
}

/**
 * 
 * @export
 * @interface PortfolioPlanUserRolesUpdatedNewEvent
 */
export interface PortfolioPlanUserRolesUpdatedNewEvent {
    /**
     * 
     * @type {Array<PortfolioPlanUserRole>}
     * @memberof PortfolioPlanUserRolesUpdatedNewEvent
     */
    previousPortfolioPlanUserRoleList?: Array<PortfolioPlanUserRole>;
    /**
     * 
     * @type {Array<PortfolioPlanUserRole>}
     * @memberof PortfolioPlanUserRolesUpdatedNewEvent
     */
    portfolioPlanUserRoleList?: Array<PortfolioPlanUserRole>;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanUserRolesUpdatedNewEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanUserRolesUpdatedNewEvent
     */
    id?: string;
    /**
     * 
     * @type {User}
     * @memberof PortfolioPlanUserRolesUpdatedNewEvent
     */
    user?: User;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanUserRolesUpdatedNewEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioPlanUserUpdatedMessagePayload
 */
export interface PortfolioPlanUserUpdatedMessagePayload {
    /**
     * 
     * @type {PortfolioPlanUser}
     * @memberof PortfolioPlanUserUpdatedMessagePayload
     */
    portfolioPlanUser: PortfolioPlanUser;
}

/**
 * 
 * @export
 * @interface PortfolioPlanWithProjects
 */
export interface PortfolioPlanWithProjects extends Array<string> {
}

/**
 * 
 * @export
 * @interface PortfolioPlansUpdatedMessagePayload
 */
export interface PortfolioPlansUpdatedMessagePayload {
    /**
     * 
     * @type {Array<PortfolioPlan>}
     * @memberof PortfolioPlansUpdatedMessagePayload
     */
    portfolioPlans: Array<PortfolioPlan>;
}

/**
 * 
 * @export
 * @interface PortfolioPlansWithProjects
 */
export interface PortfolioPlansWithProjects {
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlansWithProjects
     */
    id?: string;
    /**
     * 
     * @type {Array<PortfolioPlanWithProjects>}
     * @memberof PortfolioPlansWithProjects
     */
    projects?: Array<PortfolioPlanWithProjects>;
}

/**
 * 
 * @export
 * @interface PortfolioProjectsCreatedEvent
 */
export interface PortfolioProjectsCreatedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioProjectsCreatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioProjectsCreatedEvent
     */
    id?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PortfolioProjectsCreatedEvent
     */
    projectIds?: Array<string>;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioProjectsCreatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioProjectsUpdatedEvent
 */
export interface PortfolioProjectsUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioProjectsUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioProjectsUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PortfolioProjectsUpdatedEvent
     */
    projectIds?: Array<string>;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioProjectsUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioRankUpdatedEvent
 */
export interface PortfolioRankUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioRankUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioRankUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioRankUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {Array<ProjectRankUpdatedCascades>}
     * @memberof PortfolioRankUpdatedEvent
     */
    items?: Array<ProjectRankUpdatedCascades>;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioRankUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioScoreWeightsUpdatedEvent
 */
export interface PortfolioScoreWeightsUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioScoreWeightsUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioScoreWeightsUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioScoreWeightsUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioTimeIntervalUpdatedEvent
 */
export interface PortfolioTimeIntervalUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioTimeIntervalUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {TimeInterval}
     * @memberof PortfolioTimeIntervalUpdatedEvent
     */
    previousTimeInterval?: TimeInterval;
    /**
     * 
     * @type {string}
     * @memberof PortfolioTimeIntervalUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {TimeInterval}
     * @memberof PortfolioTimeIntervalUpdatedEvent
     */
    timeInterval?: TimeInterval;
    /**
     * 
     * @type {string}
     * @memberof PortfolioTimeIntervalUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioTimeIntervalUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface PortfolioUpdatedMessagePayload
 */
export interface PortfolioUpdatedMessagePayload {
    /**
     * 
     * @type {Portfolio}
     * @memberof PortfolioUpdatedMessagePayload
     */
    portfolio: Portfolio;
}

/**
 * 
 * @export
 * @interface PortfolioUserRegistrationTokenUpdatedEvent
 */
export interface PortfolioUserRegistrationTokenUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof PortfolioUserRegistrationTokenUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioUserRegistrationTokenUpdatedEvent
     */
    previousUserRegistrationToken?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioUserRegistrationTokenUpdatedEvent
     */
    userRegistrationToken?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioUserRegistrationTokenUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioUserRegistrationTokenUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectAccessGrantedMessagePayload
 */
export interface ProjectAccessGrantedMessagePayload {
    /**
     * 
     * @type {Array<Project>}
     * @memberof ProjectAccessGrantedMessagePayload
     */
    projects: Array<Project>;
}

/**
 * 
 * @export
 * @interface ProjectAccessRevokedMessagePayload
 */
export interface ProjectAccessRevokedMessagePayload {
    /**
     * 
     * @type {Array<Project>}
     * @memberof ProjectAccessRevokedMessagePayload
     */
    projects: Array<Project>;
}

/**
 * 
 * @export
 * @interface ProjectAttachmentAddedEvent
 */
export interface ProjectAttachmentAddedEvent {
    /**
     * 
     * @type {number}
     * @memberof ProjectAttachmentAddedEvent
     */
    attachmentSize?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentAddedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentAddedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentAddedEvent
     */
    attachmentName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentAddedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentAddedEvent
     */
    attachmentId?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectAttachmentAddedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectAttachmentAddedMessagePayload
 */
export interface ProjectAttachmentAddedMessagePayload {
    /**
     * 
     * @type {Attachment}
     * @memberof ProjectAttachmentAddedMessagePayload
     */
    attachment: Attachment;
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentAddedMessagePayload
     */
    portfolioId: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentAddedMessagePayload
     */
    projectId: string;
}

/**
 * 
 * @export
 * @interface ProjectAttachmentRemovedEvent
 */
export interface ProjectAttachmentRemovedEvent {
    /**
     * 
     * @type {number}
     * @memberof ProjectAttachmentRemovedEvent
     */
    attachmentSize?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentRemovedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentRemovedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentRemovedEvent
     */
    attachmentName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentRemovedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentRemovedEvent
     */
    attachmentId?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectAttachmentRemovedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectAttachmentRemovedMessagePayload
 */
export interface ProjectAttachmentRemovedMessagePayload {
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentRemovedMessagePayload
     */
    attachmentId: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentRemovedMessagePayload
     */
    portfolioId: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectAttachmentRemovedMessagePayload
     */
    projectId: string;
}

/**
 * 
 * @export
 * @interface ProjectContributingUserAddedEvent
 */
export interface ProjectContributingUserAddedEvent {
    /**
     * 
     * @type {string}
     * @memberof ProjectContributingUserAddedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {User}
     * @memberof ProjectContributingUserAddedEvent
     */
    contributingUser?: User;
    /**
     * 
     * @type {string}
     * @memberof ProjectContributingUserAddedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectContributingUserAddedEvent
     */
    projectName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectContributingUserAddedEvent
     */
    userId?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectContributingUserAddedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectContributingUserDeletedEvent
 */
export interface ProjectContributingUserDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof ProjectContributingUserDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {User}
     * @memberof ProjectContributingUserDeletedEvent
     */
    contributingUser?: User;
    /**
     * 
     * @type {string}
     * @memberof ProjectContributingUserDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectContributingUserDeletedEvent
     */
    projectName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectContributingUserDeletedEvent
     */
    userId?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectContributingUserDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectContributorsUpdatedMessagePayload
 */
export interface ProjectContributorsUpdatedMessagePayload {
    /**
     * 
     * @type {Array<Project>}
     * @memberof ProjectContributorsUpdatedMessagePayload
     */
    projects: Array<Project>;
}

/**
 * 
 * @export
 * @interface ProjectCreatedEvent
 */
export interface ProjectCreatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ProjectCreatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectCreatedEvent
     */
    contributingUserIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProjectCreatedEvent
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectCreatedEvent
     */
    isDraft?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectCreatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectCreatedEvent
     */
    position?: number;
    /**
     * 
     * @type {Array<ProjectFieldValue>}
     * @memberof ProjectCreatedEvent
     */
    fieldValues?: Array<ProjectFieldValue>;
    /**
     * 
     * @type {string}
     * @memberof ProjectCreatedEvent
     */
    userId?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectCreatedEvent
     */
    portfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectCreatedEvent
     */
    isFromImport?: boolean;
}

/**
 * 
 * @export
 * @interface ProjectDeletedEvent
 */
export interface ProjectDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof ProjectDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectDeletedEvent
     */
    contributingUserIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDeletedEvent
     */
    isDraft?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectDependenciesUpdatedMessagePayload
 */
export interface ProjectDependenciesUpdatedMessagePayload {
    /**
     * 
     * @type {Projects}
     * @memberof ProjectDependenciesUpdatedMessagePayload
     */
    projects: Projects;
}

/**
 * 
 * @export
 * @interface ProjectDependsOnAddedEvent
 */
export interface ProjectDependsOnAddedEvent {
    /**
     * 
     * @type {string}
     * @memberof ProjectDependsOnAddedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Project}
     * @memberof ProjectDependsOnAddedEvent
     */
    dependsOnProject?: Project;
    /**
     * 
     * @type {string}
     * @memberof ProjectDependsOnAddedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDependsOnAddedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectDependsOnAddedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectDependsOnRemovedEvent
 */
export interface ProjectDependsOnRemovedEvent {
    /**
     * 
     * @type {string}
     * @memberof ProjectDependsOnRemovedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Project}
     * @memberof ProjectDependsOnRemovedEvent
     */
    dependsOnProject?: Project;
    /**
     * 
     * @type {string}
     * @memberof ProjectDependsOnRemovedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDependsOnRemovedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectDependsOnRemovedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectFieldValue
 */
export interface ProjectFieldValue {
    /**
     * 
     * @type {Field}
     * @memberof ProjectFieldValue
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ProjectFieldValue
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectFieldValue
     */
    numericValue?: number;
    /**
     * 
     * @type {TimePeriod}
     * @memberof ProjectFieldValue
     */
    timePeriod?: TimePeriod;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectFieldValue
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectFieldValueDeletedEvent
 */
export interface ProjectFieldValueDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof ProjectFieldValueDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ProjectFieldValueDeletedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ProjectFieldValueDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {TimePeriod}
     * @memberof ProjectFieldValueDeletedEvent
     */
    timePeriod?: TimePeriod;
    /**
     * 
     * @type {string}
     * @memberof ProjectFieldValueDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectFieldValueDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectFieldValueUpdatedEvent
 */
export interface ProjectFieldValueUpdatedEvent {
    /**
     * 
     * @type {DataType}
     * @memberof ProjectFieldValueUpdatedEvent
     */
    previousDataType?: DataType;
    /**
     * 
     * @type {number}
     * @memberof ProjectFieldValueUpdatedEvent
     */
    numericValue?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectFieldValueUpdatedEvent
     */
    previousNumericValue?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectFieldValueUpdatedEvent
     */
    isRebaseline?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectFieldValueUpdatedEvent
     */
    previousValue?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectFieldValueUpdatedEvent
     */
    isFromImport?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectFieldValueUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ProjectFieldValueUpdatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ProjectFieldValueUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {TimePeriod}
     * @memberof ProjectFieldValueUpdatedEvent
     */
    timePeriod?: TimePeriod;
    /**
     * 
     * @type {string}
     * @memberof ProjectFieldValueUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectFieldValueUpdatedEvent
     */
    value?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectFieldValueUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectFieldValuesDeletedEvent
 */
export interface ProjectFieldValuesDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof ProjectFieldValuesDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ProjectFieldValuesDeletedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ProjectFieldValuesDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectFieldValuesDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectFieldValuesDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectPortfolioPlanDeletedEvent
 */
export interface ProjectPortfolioPlanDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectPortfolioPlanDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectPortfolioPlanFieldValueDeletedEvent
 */
export interface ProjectPortfolioPlanFieldValueDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanFieldValueDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ProjectPortfolioPlanFieldValueDeletedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanFieldValueDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {TimePeriod}
     * @memberof ProjectPortfolioPlanFieldValueDeletedEvent
     */
    timePeriod?: TimePeriod;
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanFieldValueDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectPortfolioPlanFieldValueDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectPortfolioPlanFieldValueUpdatedEvent
 */
export interface ProjectPortfolioPlanFieldValueUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanFieldValueUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ProjectPortfolioPlanFieldValueUpdatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanFieldValueUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {TimePeriod}
     * @memberof ProjectPortfolioPlanFieldValueUpdatedEvent
     */
    timePeriod?: TimePeriod;
    /**
     * 
     * @type {number}
     * @memberof ProjectPortfolioPlanFieldValueUpdatedEvent
     */
    numericValue?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanFieldValueUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectPortfolioPlanFieldValueUpdatedEvent
     */
    previousNumericValue?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectPortfolioPlanFieldValueUpdatedEvent
     */
    isRebaseline?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanFieldValueUpdatedEvent
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanFieldValueUpdatedEvent
     */
    previousValue?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectPortfolioPlanFieldValueUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectPortfolioPlanFieldValueUpdatedEvent
     */
    isFromImport?: boolean;
}

/**
 * 
 * @export
 * @interface ProjectPortfolioPlanFieldValuesCopiedEvent
 */
export interface ProjectPortfolioPlanFieldValuesCopiedEvent {
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanFieldValuesCopiedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectPortfolioPlanFieldValuesCopiedEvent
     */
    fromPortfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanFieldValuesCopiedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanFieldValuesCopiedEvent
     */
    id?: string;
    /**
     * 
     * @type {Array<ProjectFieldValue>}
     * @memberof ProjectPortfolioPlanFieldValuesCopiedEvent
     */
    fieldValues?: Array<ProjectFieldValue>;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectPortfolioPlanFieldValuesCopiedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectPortfolioPlanIsDraftUpdatedEvent
 */
export interface ProjectPortfolioPlanIsDraftUpdatedEvent {
    /**
     * 
     * @type {boolean}
     * @memberof ProjectPortfolioPlanIsDraftUpdatedEvent
     */
    previousIsDraft?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanIsDraftUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanIsDraftUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectPortfolioPlanIsDraftUpdatedEvent
     */
    isDraft?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectPortfolioPlanIsDraftUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectPortfolioPlanIsDraftUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectRankFieldValueUpdatedEvent
 */
export interface ProjectRankFieldValueUpdatedEvent {
    /**
     * 
     * @type {DataType}
     * @memberof ProjectRankFieldValueUpdatedEvent
     */
    previousDataType?: DataType;
    /**
     * 
     * @type {number}
     * @memberof ProjectRankFieldValueUpdatedEvent
     */
    numericValue?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectRankFieldValueUpdatedEvent
     */
    previousNumericValue?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectRankFieldValueUpdatedEvent
     */
    isRebaseline?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectRankFieldValueUpdatedEvent
     */
    previousValue?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectRankFieldValueUpdatedEvent
     */
    isFromImport?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectRankFieldValueUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ProjectRankFieldValueUpdatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ProjectRankFieldValueUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {TimePeriod}
     * @memberof ProjectRankFieldValueUpdatedEvent
     */
    timePeriod?: TimePeriod;
    /**
     * 
     * @type {string}
     * @memberof ProjectRankFieldValueUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectRankFieldValueUpdatedEvent
     */
    value?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectRankFieldValueUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectRankUpdatedCascades
 */
export interface ProjectRankUpdatedCascades {
    /**
     * 
     * @type {string}
     * @memberof ProjectRankUpdatedCascades
     */
    projectId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectRankUpdatedCascades
     */
    projectName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectRankUpdatedCascades
     */
    fieldId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectRankUpdatedCascades
     */
    fieldName?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectRankUpdatedCascades
     */
    cascadedProjectsCount?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectRankUpdatedCascades
     */
    direction?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectRankUpdatedCascades
     */
    previousValue?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectRankUpdatedCascades
     */
    value?: number;
}

/**
 * 
 * @export
 * @interface ProjectScoresUpdatedMessagePayload
 */
export interface ProjectScoresUpdatedMessagePayload {
    /**
     * 
     * @type {string}
     * @memberof ProjectScoresUpdatedMessagePayload
     */
    portfolioId: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectScoresUpdatedMessagePayload
     */
    dataId: string;
}

/**
 * 
 * @export
 * @interface ProjectSummary
 */
export interface ProjectSummary {
    /**
     * 
     * @type {string}
     * @memberof ProjectSummary
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectSummary
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectSummary
     */
    request?: number;
}

/**
 * 
 * @export
 * @interface ProjectTagAddedEvent
 */
export interface ProjectTagAddedEvent {
    /**
     * 
     * @type {string}
     * @memberof ProjectTagAddedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectTagAddedEvent
     */
    tagParentName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectTagAddedEvent
     */
    tagId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectTagAddedEvent
     */
    tagColor?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectTagAddedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectTagAddedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectTagAddedEvent
     */
    tagName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectTagAddedEvent
     */
    tagParentId?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectTagAddedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectTagRemovedEvent
 */
export interface ProjectTagRemovedEvent {
    /**
     * 
     * @type {string}
     * @memberof ProjectTagRemovedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectTagRemovedEvent
     */
    tagParentName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectTagRemovedEvent
     */
    tagId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectTagRemovedEvent
     */
    tagColor?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectTagRemovedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectTagRemovedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectTagRemovedEvent
     */
    tagName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectTagRemovedEvent
     */
    tagParentId?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ProjectTagRemovedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ProjectsCreatedMessagePayload
 */
export interface ProjectsCreatedMessagePayload {
    /**
     * 
     * @type {Array<Project>}
     * @memberof ProjectsCreatedMessagePayload
     */
    projects: Array<Project>;
}

/**
 * 
 * @export
 * @interface ProjectsDeletedMessagePayload
 */
export interface ProjectsDeletedMessagePayload {
    /**
     * 
     * @type {Array<Project>}
     * @memberof ProjectsDeletedMessagePayload
     */
    projects: Array<Project>;
}

/**
 * 
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * 
     * @type {PropertyName}
     * @memberof Property
     */
    name?: PropertyName;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    value?: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PropertyName {
    WARNINGBANNERTEXT = <any> 'WARNING_BANNER_TEXT',
    INACTIVITYTIMEOUT = <any> 'INACTIVITY_TIMEOUT',
    DLCSOURCEENABLED = <any> 'DLC_SOURCE_ENABLED',
    KLOUDLESSENABLED = <any> 'KLOUDLESS_ENABLED',
    COMMENTEMAILNOTIFY = <any> 'COMMENT_EMAIL_NOTIFY',
    INTAKEENGINEENABLED = <any> 'INTAKE_ENGINE_ENABLED',
    IPALLOWLIST = <any> 'IP_ALLOWLIST',
    ATTACHMENTMAXSIZE = <any> 'ATTACHMENT_MAX_SIZE',
    SSOSELFENROLLMENTENABLED = <any> 'SSO_SELF_ENROLLMENT_ENABLED',
    SHOWDLCLINK = <any> 'SHOW_DLC_LINK',
    LINKEDAPPURL = <any> 'LINKED_APP_URL',
    MAXCATEGORYOPTIONS = <any> 'MAX_CATEGORY_OPTIONS',
    SHOWSPENDPLANVIEW = <any> 'SHOW_SPEND_PLAN_VIEW',
    USERPROFILECUSTOMIDALLOWED = <any> 'USER_PROFILE_CUSTOM_ID_ALLOWED',
    STATUSOFFUNDSENABLED = <any> 'STATUS_OF_FUNDS_ENABLED',
    EMAILENABLED = <any> 'EMAIL_ENABLED',
    STIGSHOWBANNER = <any> 'STIG_SHOW_BANNER',
    STIGTEXTCONTENT = <any> 'STIG_TEXT_CONTENT',
    STIGBACKGROUNDCOLOR = <any> 'STIG_BACKGROUND_COLOR',
    STIGTEXTCOLOR = <any> 'STIG_TEXT_COLOR',
    LOCKNEWUSERS = <any> 'LOCK_NEW_USERS',
    MINIMALINFOEMAILENABLED = <any> 'MINIMAL_INFO_EMAIL_ENABLED'
}

/**
 * 
 * @export
 * @interface ProvisionGroupRequest
 */
export interface ProvisionGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof ProvisionGroupRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ProvisionGroupRequest
     */
    domain: string;
    /**
     * 
     * @type {string}
     * @memberof ProvisionGroupRequest
     */
    linkedDomain?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProvisionGroupRequest
     */
    userNames?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProvisionGroupRequest
     */
    authUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvisionGroupRequest
     */
    logoutUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvisionGroupRequest
     */
    ssoPrincipalKey?: string;
    /**
     * 
     * @type {SSOPrincipalTransmitMethod}
     * @memberof ProvisionGroupRequest
     */
    ssoPrincipalTransmitMethod?: SSOPrincipalTransmitMethod;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ProvisionGroupRequest
     */
    dliProperties?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ProvisionGroupRequest
     */
    dlxProperties?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ProvisionGroupRequest
     */
    dlcProperties?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface ProvisionGroupResponse
 */
export interface ProvisionGroupResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProvisionGroupResponse
     */
    appUrls?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ProvisionGroupResponse
     */
    errors?: { [key: string]: string; };
    /**
     * 
     * @type {Array<Schema>}
     * @memberof ProvisionGroupResponse
     */
    schemas?: Array<Schema>;
    /**
     * 
     * @type {Array<Group>}
     * @memberof ProvisionGroupResponse
     */
    groups?: Array<Group>;
    /**
     * 
     * @type {DLCGroup}
     * @memberof ProvisionGroupResponse
     */
    dlcGroup?: DLCGroup;
    /**
     * 
     * @type {Array<DLIApplication>}
     * @memberof ProvisionGroupResponse
     */
    dliApplications?: Array<DLIApplication>;
    /**
     * 
     * @type {Array<User>}
     * @memberof ProvisionGroupResponse
     */
    users?: Array<User>;
}

/**
 * 
 * @export
 * @interface Recommendation
 */
export interface Recommendation {
    /**
     * 
     * @type {RecommendationType}
     * @memberof Recommendation
     */
    type?: RecommendationType;
    /**
     * 
     * @type {FieldValues}
     * @memberof Recommendation
     */
    fieldValues?: FieldValues;
    /**
     * 
     * @type {PortfolioPlanInsights}
     * @memberof Recommendation
     */
    portfolioPlanInsights?: PortfolioPlanInsights;
    /**
     * 
     * @type {Project}
     * @memberof Recommendation
     */
    project?: Project;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum RecommendationType {
    ADDTOPLAN = <any> 'ADD_TO_PLAN',
    REMOVEFROMPLAN = <any> 'REMOVE_FROM_PLAN',
    MOVEOUTSIDEHORIZON = <any> 'MOVE_OUTSIDE_HORIZON',
    MOVEINSIDEHORIZON = <any> 'MOVE_INSIDE_HORIZON',
    MOVEWITHINHORIZONTOWARDSFUTURE = <any> 'MOVE_WITHIN_HORIZON_TOWARDS_FUTURE',
    MOVEWITHINHORIZONTOWARDSPAST = <any> 'MOVE_WITHIN_HORIZON_TOWARDS_PAST'
}

/**
 * 
 * @export
 * @interface RegisterUserRequest
 */
export interface RegisterUserRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    userRegistrationToken: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    emailId: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    landingPage?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RegisterUserRequest
     */
    doNotNotify?: boolean;
}

/**
 * 
 * @export
 * @interface RemoveContributingUsersRequest
 */
export interface RemoveContributingUsersRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveContributingUsersRequest
     */
    contributingUserIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface RemovedFromPortfolioMessagePayload
 */
export interface RemovedFromPortfolioMessagePayload {
    /**
     * 
     * @type {Portfolio}
     * @memberof RemovedFromPortfolioMessagePayload
     */
    portfolio: Portfolio;
}

/**
 * 
 * @export
 * @interface RemovedFromPortfolioPlanMessagePayload
 */
export interface RemovedFromPortfolioPlanMessagePayload {
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof RemovedFromPortfolioPlanMessagePayload
     */
    portfolioPlan: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ResourcePoolBudgetAmount
 */
export interface ResourcePoolBudgetAmount {
    /**
     * 
     * @type {ResourcePool}
     * @memberof ResourcePoolBudgetAmount
     */
    resourcePool?: ResourcePool;
    /**
     * 
     * @type {TimePeriod}
     * @memberof ResourcePoolBudgetAmount
     */
    timePeriod?: TimePeriod;
    /**
     * 
     * @type {number}
     * @memberof ResourcePoolBudgetAmount
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourcePoolBudgetAmount
     */
    baselineAmount?: number;
    /**
     * 
     * @type {ResourcePoolBudgetAmounts}
     * @memberof ResourcePoolBudgetAmount
     */
    details?: ResourcePoolBudgetAmounts;
}

/**
 * 
 * @export
 * @interface ResourcePoolBudgetAmountPatchItem
 */
export interface ResourcePoolBudgetAmountPatchItem {
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolBudgetAmountPatchItem
     */
    resourcePoolId?: string;
    /**
     * 
     * @type {TimePeriod}
     * @memberof ResourcePoolBudgetAmountPatchItem
     */
    timePeriod?: TimePeriod;
    /**
     * 
     * @type {Operations}
     * @memberof ResourcePoolBudgetAmountPatchItem
     */
    operations?: Operations;
}

/**
 * 
 * @export
 * @interface ResourcePoolBudgetAmountUpdatedEvent
 */
export interface ResourcePoolBudgetAmountUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolBudgetAmountUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourcePoolBudgetAmountUpdatedEvent
     */
    budgetAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolBudgetAmountUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {TimePeriod}
     * @memberof ResourcePoolBudgetAmountUpdatedEvent
     */
    timePeriod?: TimePeriod;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolBudgetAmountUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ResourcePoolBudgetAmountUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {number}
     * @memberof ResourcePoolBudgetAmountUpdatedEvent
     */
    previousBudgetAmount?: number;
}

/**
 * 
 * @export
 * @interface ResourcePoolCreatedEvent
 */
export interface ResourcePoolCreatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolCreatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ResourcePoolCreatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolCreatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolCreatedEvent
     */
    id?: string;
    /**
     * 
     * @type {Array<ResourcePoolBudgetAmount>}
     * @memberof ResourcePoolCreatedEvent
     */
    budgetAmounts?: Array<ResourcePoolBudgetAmount>;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ResourcePoolCreatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ResourcePoolDeletedEvent
 */
export interface ResourcePoolDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ResourcePoolDeletedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ResourcePoolDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ResourcePoolFieldValuePatchItem
 */
export interface ResourcePoolFieldValuePatchItem {
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolFieldValuePatchItem
     */
    resourcePoolId?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolFieldValuePatchItem
     */
    fieldId?: string;
    /**
     * 
     * @type {Operations}
     * @memberof ResourcePoolFieldValuePatchItem
     */
    operations?: Operations;
}

/**
 * 
 * @export
 * @interface ResourcePoolFieldValueUpdatedEvent
 */
export interface ResourcePoolFieldValueUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolFieldValueUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ResourcePoolFieldValueUpdatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolFieldValueUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourcePoolFieldValueUpdatedEvent
     */
    numericValue?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolFieldValueUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourcePoolFieldValueUpdatedEvent
     */
    previousNumericValue?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolFieldValueUpdatedEvent
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolFieldValueUpdatedEvent
     */
    previousValue?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ResourcePoolFieldValueUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {boolean}
     * @memberof ResourcePoolFieldValueUpdatedEvent
     */
    isFromImport?: boolean;
}

/**
 * 
 * @export
 * @interface ResourcePoolFieldValuesUpdatedMessagePayload
 */
export interface ResourcePoolFieldValuesUpdatedMessagePayload {
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolFieldValuesUpdatedMessagePayload
     */
    portfolioId?: string;
    /**
     * 
     * @type {Array<ResourcePoolFieldValue>}
     * @memberof ResourcePoolFieldValuesUpdatedMessagePayload
     */
    fieldValues: Array<ResourcePoolFieldValue>;
}

/**
 * 
 * @export
 * @interface ResourcePoolNameUpdatedEvent
 */
export interface ResourcePoolNameUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolNameUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolNameUpdatedEvent
     */
    previousName?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolNameUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolNameUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ResourcePoolNameUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ResourcePoolPlanBudgetAmountUpdatedEvent
 */
export interface ResourcePoolPlanBudgetAmountUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolPlanBudgetAmountUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourcePoolPlanBudgetAmountUpdatedEvent
     */
    budgetAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolPlanBudgetAmountUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {TimePeriod}
     * @memberof ResourcePoolPlanBudgetAmountUpdatedEvent
     */
    timePeriod?: TimePeriod;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolPlanBudgetAmountUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ResourcePoolPlanBudgetAmountUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {number}
     * @memberof ResourcePoolPlanBudgetAmountUpdatedEvent
     */
    previousBudgetAmount?: number;
}

/**
 * 
 * @export
 * @interface ResourcePoolPlanBudgetCopiedEvent
 */
export interface ResourcePoolPlanBudgetCopiedEvent {
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolPlanBudgetCopiedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ResourcePoolPlanBudgetCopiedEvent
     */
    fromPortfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolPlanBudgetCopiedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourcePoolPlanBudgetCopiedEvent
     */
    id?: string;
    /**
     * 
     * @type {Array<ResourcePoolBudgetAmount>}
     * @memberof ResourcePoolPlanBudgetCopiedEvent
     */
    budgetAmounts?: Array<ResourcePoolBudgetAmount>;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ResourcePoolPlanBudgetCopiedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ResourcePoolsCreatedMessagePayload
 */
export interface ResourcePoolsCreatedMessagePayload {
    /**
     * 
     * @type {Array<ResourcePool>}
     * @memberof ResourcePoolsCreatedMessagePayload
     */
    resourcePools: Array<ResourcePool>;
}

/**
 * 
 * @export
 * @interface ResourcePoolsDeletedMessagePayload
 */
export interface ResourcePoolsDeletedMessagePayload {
    /**
     * 
     * @type {Array<ResourcePool>}
     * @memberof ResourcePoolsDeletedMessagePayload
     */
    resourcePools: Array<ResourcePool>;
}

/**
 * 
 * @export
 * @interface ResourcePoolsUpdatedMessagePayload
 */
export interface ResourcePoolsUpdatedMessagePayload {
    /**
     * 
     * @type {Array<ResourcePool>}
     * @memberof ResourcePoolsUpdatedMessagePayload
     */
    resourcePools: Array<ResourcePool>;
}

/**
 * 
 * @export
 * @interface RiskFieldDetail
 */
export interface RiskFieldDetail {
    /**
     * 
     * @type {RiskType}
     * @memberof RiskFieldDetail
     */
    type?: RiskType;
    /**
     * 
     * @type {number}
     * @memberof RiskFieldDetail
     */
    projectCount?: number;
    /**
     * 
     * @type {number}
     * @memberof RiskFieldDetail
     */
    allocation?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum RiskType {
    VERYGOOD = <any> 'VERY_GOOD',
    GOOD = <any> 'GOOD',
    FAIR = <any> 'FAIR',
    POOR = <any> 'POOR',
    VERYPOOR = <any> 'VERY_POOR'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum RoleType {
    SYSADMIN = <any> 'SYSADMIN',
    GROUPADMIN = <any> 'GROUPADMIN',
    PARTICIPANT = <any> 'PARTICIPANT'
}

/**
 * 
 * @export
 * @interface Row
 */
export interface Row {
    /**
     * 
     * @type {number}
     * @memberof Row
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Row
     */
    columns?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Row
     */
    dataFormats?: Array<string>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SSOPrincipalTransmitMethod {
    HTTPHEADER = <any> 'HTTP_HEADER',
    JWT = <any> 'JWT',
    COOKIE = <any> 'COOKIE',
    REMOTEUSER = <any> 'REMOTE_USER',
    NONE = <any> 'NONE'
}

/**
 * 
 * @export
 * @interface Scale
 */
export interface Scale {
    /**
     * 
     * @type {boolean}
     * @memberof Scale
     */
    isAutoScale?: boolean;
    /**
     * 
     * @type {Array<ScalePoint>}
     * @memberof Scale
     */
    points?: Array<ScalePoint>;
}

/**
 * 
 * @export
 * @interface ScalePoint
 */
export interface ScalePoint {
    /**
     * 
     * @type {string}
     * @memberof ScalePoint
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ScalePoint
     */
    autoScaleValue?: number;
    /**
     * 
     * @type {number}
     * @memberof ScalePoint
     */
    manualScaleValue?: number;
    /**
     * 
     * @type {number}
     * @memberof ScalePoint
     */
    autoValue?: number;
    /**
     * 
     * @type {number}
     * @memberof ScalePoint
     */
    manualValue?: number;
    /**
     * 
     * @type {string}
     * @memberof ScalePoint
     */
    categoryId?: string;
    /**
     * 
     * @type {Project}
     * @memberof ScalePoint
     */
    project?: Project;
    /**
     * 
     * @type {number}
     * @memberof ScalePoint
     */
    autoValueModifiedAt?: number;
}

/**
 * 
 * @export
 * @interface ScalePointAutoScaleValueUpdatedEvent
 */
export interface ScalePointAutoScaleValueUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ScalePointAutoScaleValueUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ScalePointAutoScaleValueUpdatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {number}
     * @memberof ScalePointAutoScaleValueUpdatedEvent
     */
    autoScaleValue?: number;
    /**
     * 
     * @type {string}
     * @memberof ScalePointAutoScaleValueUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {Project}
     * @memberof ScalePointAutoScaleValueUpdatedEvent
     */
    project?: Project;
    /**
     * 
     * @type {string}
     * @memberof ScalePointAutoScaleValueUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ScalePointAutoScaleValueUpdatedEvent
     */
    previousAutoScaleValue?: number;
    /**
     * 
     * @type {CategoryOption}
     * @memberof ScalePointAutoScaleValueUpdatedEvent
     */
    category?: CategoryOption;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScalePointAutoScaleValueUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ScalePointAutoValueUpdatedEvent
 */
export interface ScalePointAutoValueUpdatedEvent {
    /**
     * 
     * @type {number}
     * @memberof ScalePointAutoValueUpdatedEvent
     */
    previousAutoValue?: number;
    /**
     * 
     * @type {string}
     * @memberof ScalePointAutoValueUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ScalePointAutoValueUpdatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ScalePointAutoValueUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {Project}
     * @memberof ScalePointAutoValueUpdatedEvent
     */
    project?: Project;
    /**
     * 
     * @type {string}
     * @memberof ScalePointAutoValueUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ScalePointAutoValueUpdatedEvent
     */
    position?: number;
    /**
     * 
     * @type {CategoryOption}
     * @memberof ScalePointAutoValueUpdatedEvent
     */
    category?: CategoryOption;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScalePointAutoValueUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {number}
     * @memberof ScalePointAutoValueUpdatedEvent
     */
    autoValue?: number;
}

/**
 * 
 * @export
 * @interface ScalePointCreatedEvent
 */
export interface ScalePointCreatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ScalePointCreatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ScalePointCreatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {number}
     * @memberof ScalePointCreatedEvent
     */
    autoScaleValue?: number;
    /**
     * 
     * @type {string}
     * @memberof ScalePointCreatedEvent
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ScalePointCreatedEvent
     */
    manualScaleValue?: number;
    /**
     * 
     * @type {Project}
     * @memberof ScalePointCreatedEvent
     */
    project?: Project;
    /**
     * 
     * @type {string}
     * @memberof ScalePointCreatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ScalePointCreatedEvent
     */
    position?: number;
    /**
     * 
     * @type {CategoryOption}
     * @memberof ScalePointCreatedEvent
     */
    category?: CategoryOption;
    /**
     * 
     * @type {number}
     * @memberof ScalePointCreatedEvent
     */
    manualValue?: number;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScalePointCreatedEvent
     */
    portfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {number}
     * @memberof ScalePointCreatedEvent
     */
    autoValue?: number;
}

/**
 * 
 * @export
 * @interface ScalePointDeletedEvent
 */
export interface ScalePointDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof ScalePointDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ScalePointDeletedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ScalePointDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ScalePointDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScalePointDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ScalePointManualScaleValueUpdatedEvent
 */
export interface ScalePointManualScaleValueUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ScalePointManualScaleValueUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ScalePointManualScaleValueUpdatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ScalePointManualScaleValueUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ScalePointManualScaleValueUpdatedEvent
     */
    manualScaleValue?: number;
    /**
     * 
     * @type {Project}
     * @memberof ScalePointManualScaleValueUpdatedEvent
     */
    project?: Project;
    /**
     * 
     * @type {number}
     * @memberof ScalePointManualScaleValueUpdatedEvent
     */
    previousManualScaleValue?: number;
    /**
     * 
     * @type {string}
     * @memberof ScalePointManualScaleValueUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {CategoryOption}
     * @memberof ScalePointManualScaleValueUpdatedEvent
     */
    category?: CategoryOption;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScalePointManualScaleValueUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ScalePointManualValueUpdatedEvent
 */
export interface ScalePointManualValueUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ScalePointManualValueUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ScalePointManualValueUpdatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ScalePointManualValueUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ScalePointManualValueUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ScalePointManualValueUpdatedEvent
     */
    position?: number;
    /**
     * 
     * @type {number}
     * @memberof ScalePointManualValueUpdatedEvent
     */
    manualValue?: number;
    /**
     * 
     * @type {number}
     * @memberof ScalePointManualValueUpdatedEvent
     */
    previousManualValue?: number;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScalePointManualValueUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ScalePointNameUpdatedEvent
 */
export interface ScalePointNameUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ScalePointNameUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ScalePointNameUpdatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ScalePointNameUpdatedEvent
     */
    previousName?: string;
    /**
     * 
     * @type {string}
     * @memberof ScalePointNameUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {Project}
     * @memberof ScalePointNameUpdatedEvent
     */
    project?: Project;
    /**
     * 
     * @type {string}
     * @memberof ScalePointNameUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {CategoryOption}
     * @memberof ScalePointNameUpdatedEvent
     */
    category?: CategoryOption;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScalePointNameUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ScalePointProjectUpdatedEvent
 */
export interface ScalePointProjectUpdatedEvent {
    /**
     * 
     * @type {Project}
     * @memberof ScalePointProjectUpdatedEvent
     */
    previousProject?: Project;
    /**
     * 
     * @type {string}
     * @memberof ScalePointProjectUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ScalePointProjectUpdatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ScalePointProjectUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {Project}
     * @memberof ScalePointProjectUpdatedEvent
     */
    project?: Project;
    /**
     * 
     * @type {string}
     * @memberof ScalePointProjectUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScalePointProjectUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SchedulingCriteria {
    TIMEPERIODOVERBUDGETPERCENT = <any> 'TIME_PERIOD_OVER_BUDGET_PERCENT',
    RESOURCEPOOLANDTIMEPERIODOVERBUDGETPERCENT = <any> 'RESOURCE_POOL_AND_TIME_PERIOD_OVER_BUDGET_PERCENT',
    TIMEPERIODOVERBUDGETAMOUNT = <any> 'TIME_PERIOD_OVER_BUDGET_AMOUNT',
    RESOURCEPOOLANDTIMEPERIODOVERBUDGETAMOUNT = <any> 'RESOURCE_POOL_AND_TIME_PERIOD_OVER_BUDGET_AMOUNT',
    TIMEPERIODOVERBUDGETRANGE = <any> 'TIME_PERIOD_OVER_BUDGET_RANGE',
    TOLERANCEDISRUPTIONVALUE = <any> 'TOLERANCE_DISRUPTION_VALUE'
}

/**
 * 
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    service?: string;
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface ScoreWeightCreatedEvent
 */
export interface ScoreWeightCreatedEvent {
    /**
     * 
     * @type {boolean}
     * @memberof ScoreWeightCreatedEvent
     */
    isDefault?: boolean;
    /**
     * 
     * @type {Array<FieldWeight>}
     * @memberof ScoreWeightCreatedEvent
     */
    fieldWeights?: Array<FieldWeight>;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightCreatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightCreatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightCreatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScoreWeightCreatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ScoreWeightDeletedEvent
 */
export interface ScoreWeightDeletedEvent {
    /**
     * 
     * @type {boolean}
     * @memberof ScoreWeightDeletedEvent
     */
    isDefault?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScoreWeightDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ScoreWeightFieldWeightCreatedEvent
 */
export interface ScoreWeightFieldWeightCreatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightFieldWeightCreatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ScoreWeightFieldWeightCreatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {boolean}
     * @memberof ScoreWeightFieldWeightCreatedEvent
     */
    isLocked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightFieldWeightCreatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightFieldWeightCreatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreWeightFieldWeightCreatedEvent
     */
    value?: number;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScoreWeightFieldWeightCreatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ScoreWeightFieldWeightDeletedEvent
 */
export interface ScoreWeightFieldWeightDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightFieldWeightDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ScoreWeightFieldWeightDeletedEvent
     */
    field?: Field;
    /**
     * 
     * @type {boolean}
     * @memberof ScoreWeightFieldWeightDeletedEvent
     */
    isLocked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightFieldWeightDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightFieldWeightDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreWeightFieldWeightDeletedEvent
     */
    value?: number;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScoreWeightFieldWeightDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ScoreWeightFieldWeightLockUpdatedEvent
 */
export interface ScoreWeightFieldWeightLockUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightFieldWeightLockUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ScoreWeightFieldWeightLockUpdatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {boolean}
     * @memberof ScoreWeightFieldWeightLockUpdatedEvent
     */
    previousIsLocked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScoreWeightFieldWeightLockUpdatedEvent
     */
    isLocked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightFieldWeightLockUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightFieldWeightLockUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScoreWeightFieldWeightLockUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ScoreWeightFieldWeightValueUpdatedEvent
 */
export interface ScoreWeightFieldWeightValueUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightFieldWeightValueUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Field}
     * @memberof ScoreWeightFieldWeightValueUpdatedEvent
     */
    field?: Field;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightFieldWeightValueUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightFieldWeightValueUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreWeightFieldWeightValueUpdatedEvent
     */
    value?: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreWeightFieldWeightValueUpdatedEvent
     */
    previousValue?: number;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScoreWeightFieldWeightValueUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ScoreWeightNameUpdatedEvent
 */
export interface ScoreWeightNameUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightNameUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightNameUpdatedEvent
     */
    previousName?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightNameUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightNameUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof ScoreWeightNameUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface ScoreWeightsUpdatedMessagePayload
 */
export interface ScoreWeightsUpdatedMessagePayload {
    /**
     * 
     * @type {string}
     * @memberof ScoreWeightsUpdatedMessagePayload
     */
    portfolioId: string;
    /**
     * 
     * @type {Array<ScoreWeight>}
     * @memberof ScoreWeightsUpdatedMessagePayload
     */
    scoreWeights?: Array<ScoreWeight>;
}

/**
 * 
 * @export
 * @interface ServiceInfo
 */
export interface ServiceInfo {
    /**
     * 
     * @type {string}
     * @memberof ServiceInfo
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInfo
     */
    buildDate?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInfo
     */
    serviceName?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInfo
     */
    contextPath?: string;
}

/**
 * 
 * @export
 * @interface SetDependenciesRequest
 */
export interface SetDependenciesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof SetDependenciesRequest
     */
    dependsOnProjectIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SetDependenciesRequest
     */
    hasDependentProjectIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface Sheet
 */
export interface Sheet {
    /**
     * 
     * @type {string}
     * @memberof Sheet
     */
    name?: string;
    /**
     * 
     * @type {Array<Row>}
     * @memberof Sheet
     */
    rows?: Array<Row>;
}

/**
 * 
 * @export
 * @interface SourceCreatedEvent
 */
export interface SourceCreatedEvent {
    /**
     * 
     * @type {SourceType}
     * @memberof SourceCreatedEvent
     */
    sourceType?: SourceType;
    /**
     * 
     * @type {string}
     * @memberof SourceCreatedEvent
     */
    name?: string;
    /**
     * 
     * @type {DlcPortfolio}
     * @memberof SourceCreatedEvent
     */
    dlcPortfolio?: DlcPortfolio;
    /**
     * 
     * @type {string}
     * @memberof SourceCreatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof SourceCreatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface SourceDeletedEvent
 */
export interface SourceDeletedEvent {
    /**
     * 
     * @type {SourceType}
     * @memberof SourceDeletedEvent
     */
    sourceType?: SourceType;
    /**
     * 
     * @type {string}
     * @memberof SourceDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof SourceDeletedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface SourceNameUpdatedEvent
 */
export interface SourceNameUpdatedEvent {
    /**
     * 
     * @type {SourceType}
     * @memberof SourceNameUpdatedEvent
     */
    sourceType?: SourceType;
    /**
     * 
     * @type {string}
     * @memberof SourceNameUpdatedEvent
     */
    previousName?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceNameUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceNameUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof SourceNameUpdatedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SourceType {
    ESTIMATE = <any> 'ESTIMATE',
    GOOGLESHEETS = <any> 'GOOGLESHEETS',
    MANUALENTRY = <any> 'MANUALENTRY',
    SPREADSHEET = <any> 'SPREADSHEET',
    SYSTEM = <any> 'SYSTEM',
    DLC = <any> 'DLC'
}

/**
 * 
 * @export
 * @interface SpreadsheetField
 */
export interface SpreadsheetField {
    /**
     * 
     * @type {Field}
     * @memberof SpreadsheetField
     */
    field?: Field;
    /**
     * 
     * @type {boolean}
     * @memberof SpreadsheetField
     */
    isNew?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SpreadsheetField
     */
    isImported?: boolean;
    /**
     * 
     * @type {SpreadsheetWarnings}
     * @memberof SpreadsheetField
     */
    warnings?: SpreadsheetWarnings;
}

/**
 * 
 * @export
 * @interface SpreadsheetReport
 */
export interface SpreadsheetReport {
    /**
     * 
     * @type {string}
     * @memberof SpreadsheetReport
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof SpreadsheetReport
     */
    spreadsheetId?: string;
    /**
     * 
     * @type {string}
     * @memberof SpreadsheetReport
     */
    sheetName?: string;
    /**
     * 
     * @type {Projects}
     * @memberof SpreadsheetReport
     */
    newProjects?: Projects;
    /**
     * 
     * @type {SpreadsheetFields}
     * @memberof SpreadsheetReport
     */
    fields?: SpreadsheetFields;
    /**
     * 
     * @type {Fields}
     * @memberof SpreadsheetReport
     */
    newFields?: Fields;
    /**
     * 
     * @type {ResourcePools}
     * @memberof SpreadsheetReport
     */
    newBudgets?: ResourcePools;
    /**
     * 
     * @type {Fields}
     * @memberof SpreadsheetReport
     */
    updateFields?: Fields;
    /**
     * 
     * @type {ResourcePools}
     * @memberof SpreadsheetReport
     */
    updateBudgets?: ResourcePools;
    /**
     * 
     * @type {number}
     * @memberof SpreadsheetReport
     */
    updateProjectFieldValuesCount?: number;
    /**
     * 
     * @type {number}
     * @memberof SpreadsheetReport
     */
    updateBudgetFieldValuesCount?: number;
    /**
     * 
     * @type {number}
     * @memberof SpreadsheetReport
     */
    newBudgetAmountsCount?: number;
    /**
     * 
     * @type {number}
     * @memberof SpreadsheetReport
     */
    updateBudgetAmountsCount?: number;
    /**
     * 
     * @type {number}
     * @memberof SpreadsheetReport
     */
    updateTimePeriodsCount?: number;
    /**
     * 
     * @type {Projects}
     * @memberof SpreadsheetReport
     */
    updateProjects?: Projects;
    /**
     * 
     * @type {Warnings}
     * @memberof SpreadsheetReport
     */
    warnings?: Warnings;
    /**
     * 
     * @type {FieldType}
     * @memberof SpreadsheetReport
     */
    importType?: FieldType;
}

/**
 * 
 * @export
 * @interface SpreadsheetReportProgress
 */
export interface SpreadsheetReportProgress {
    /**
     * 
     * @type {SpreadsheetReportProgressStatus}
     * @memberof SpreadsheetReportProgress
     */
    status?: SpreadsheetReportProgressStatus;
}

/**
 * 
 * @export
 * @interface SpreadsheetReportProgressMessagePayload
 */
export interface SpreadsheetReportProgressMessagePayload {
    /**
     * 
     * @type {string}
     * @memberof SpreadsheetReportProgressMessagePayload
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof SpreadsheetReportProgressMessagePayload
     */
    spreadsheetId?: string;
    /**
     * 
     * @type {string}
     * @memberof SpreadsheetReportProgressMessagePayload
     */
    sheetName?: string;
    /**
     * 
     * @type {SpreadsheetReportProgress}
     * @memberof SpreadsheetReportProgressMessagePayload
     */
    newFields?: SpreadsheetReportProgress;
    /**
     * 
     * @type {SpreadsheetReportProgress}
     * @memberof SpreadsheetReportProgressMessagePayload
     */
    newBudgetFields?: SpreadsheetReportProgress;
    /**
     * 
     * @type {SpreadsheetReportProgress}
     * @memberof SpreadsheetReportProgressMessagePayload
     */
    newProjects?: SpreadsheetReportProgress;
    /**
     * 
     * @type {SpreadsheetReportProgress}
     * @memberof SpreadsheetReportProgressMessagePayload
     */
    updateProjects?: SpreadsheetReportProgress;
    /**
     * 
     * @type {SpreadsheetReportProgress}
     * @memberof SpreadsheetReportProgressMessagePayload
     */
    newBudgets?: SpreadsheetReportProgress;
    /**
     * 
     * @type {SpreadsheetReportProgress}
     * @memberof SpreadsheetReportProgressMessagePayload
     */
    updateBudgets?: SpreadsheetReportProgress;
    /**
     * 
     * @type {SpreadsheetReportProgress}
     * @memberof SpreadsheetReportProgressMessagePayload
     */
    budgetAmounts?: SpreadsheetReportProgress;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SpreadsheetReportProgressStatus {
    NOTSTARTED = <any> 'NOT_STARTED',
    DONE = <any> 'DONE'
}

/**
 * 
 * @export
 * @interface SpreadsheetWarning
 */
export interface SpreadsheetWarning {
    /**
     * 
     * @type {string}
     * @memberof SpreadsheetWarning
     */
    headerLabel?: string;
    /**
     * 
     * @type {string}
     * @memberof SpreadsheetWarning
     */
    footerLabel?: string;
    /**
     * 
     * @type {string}
     * @memberof SpreadsheetWarning
     */
    resourceName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SpreadsheetWarning
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface SubPortfolioAddedEvent
 */
export interface SubPortfolioAddedEvent {
    /**
     * 
     * @type {string}
     * @memberof SubPortfolioAddedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Portfolio}
     * @memberof SubPortfolioAddedEvent
     */
    subPortfolio?: Portfolio;
    /**
     * 
     * @type {string}
     * @memberof SubPortfolioAddedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SubPortfolioAddedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof SubPortfolioAddedEvent
     */
    position?: number;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof SubPortfolioAddedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface SubPortfolioRemovedEvent
 */
export interface SubPortfolioRemovedEvent {
    /**
     * 
     * @type {string}
     * @memberof SubPortfolioRemovedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {Portfolio}
     * @memberof SubPortfolioRemovedEvent
     */
    subPortfolio?: Portfolio;
    /**
     * 
     * @type {string}
     * @memberof SubPortfolioRemovedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SubPortfolioRemovedEvent
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof SubPortfolioRemovedEvent
     */
    position?: number;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof SubPortfolioRemovedEvent
     */
    portfolioPlan?: PortfolioPlan;
}

/**
 * 
 * @export
 * @interface TagAddedMessagePayload
 */
export interface TagAddedMessagePayload {
    /**
     * 
     * @type {Tag}
     * @memberof TagAddedMessagePayload
     */
    tag: Tag;
}

/**
 * 
 * @export
 * @interface TagColorUpdatedEvent
 */
export interface TagColorUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof TagColorUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagColorUpdatedEvent
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof TagColorUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TagColorUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TagColorUpdatedEvent
     */
    previousColor?: string;
    /**
     * 
     * @type {string}
     * @memberof TagColorUpdatedEvent
     */
    parentId?: string;
}

/**
 * 
 * @export
 * @interface TagCreatedEvent
 */
export interface TagCreatedEvent {
    /**
     * 
     * @type {string}
     * @memberof TagCreatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagCreatedEvent
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof TagCreatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TagCreatedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TagCreatedEvent
     */
    parentId?: string;
}

/**
 * 
 * @export
 * @interface TagDeletedEvent
 */
export interface TagDeletedEvent {
    /**
     * 
     * @type {string}
     * @memberof TagDeletedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagDeletedEvent
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof TagDeletedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TagDeletedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TagDeletedEvent
     */
    parentId?: string;
}

/**
 * 
 * @export
 * @interface TagDeletedMessagePayload
 */
export interface TagDeletedMessagePayload {
    /**
     * 
     * @type {Tag}
     * @memberof TagDeletedMessagePayload
     */
    tag: Tag;
}

/**
 * 
 * @export
 * @interface TagNameUpdatedEvent
 */
export interface TagNameUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof TagNameUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagNameUpdatedEvent
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof TagNameUpdatedEvent
     */
    previousName?: string;
    /**
     * 
     * @type {string}
     * @memberof TagNameUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TagNameUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TagNameUpdatedEvent
     */
    parentId?: string;
}

/**
 * 
 * @export
 * @interface TagParentUpdatedEvent
 */
export interface TagParentUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof TagParentUpdatedEvent
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagParentUpdatedEvent
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof TagParentUpdatedEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TagParentUpdatedEvent
     */
    previousParentId?: string;
    /**
     * 
     * @type {string}
     * @memberof TagParentUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TagParentUpdatedEvent
     */
    parentId?: string;
}

/**
 * 
 * @export
 * @interface TagUpdatedMessagePayload
 */
export interface TagUpdatedMessagePayload {
    /**
     * 
     * @type {Tag}
     * @memberof TagUpdatedMessagePayload
     */
    tag: Tag;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum TargetType {
    HIGH = <any> 'HIGH',
    LOW = <any> 'LOW'
}

/**
 * 
 * @export
 * @interface TemplateProperty
 */
export interface TemplateProperty {
    /**
     * 
     * @type {string}
     * @memberof TemplateProperty
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof TemplateProperty
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface TimeInterval
 */
export interface TimeInterval {
    /**
     * 
     * @type {number}
     * @memberof TimeInterval
     */
    startMonth?: number;
    /**
     * 
     * @type {TimePeriodType}
     * @memberof TimeInterval
     */
    type?: TimePeriodType;
}

/**
 * 
 * @export
 * @interface TimePeriod
 */
export interface TimePeriod {
    /**
     * 
     * @type {number}
     * @memberof TimePeriod
     */
    startDate?: number;
    /**
     * 
     * @type {number}
     * @memberof TimePeriod
     */
    endDate?: number;
    /**
     * 
     * @type {TimePeriodType}
     * @memberof TimePeriod
     */
    type?: TimePeriodType;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum TimePeriodType {
    YEAR = <any> 'YEAR',
    FISCALYEAR = <any> 'FISCAL_YEAR',
    QUARTER = <any> 'QUARTER',
    MONTH = <any> 'MONTH'
}

/**
 * 
 * @export
 * @interface ToastMessagePayload
 */
export interface ToastMessagePayload {
    /**
     * 
     * @type {string}
     * @memberof ToastMessagePayload
     */
    message: string;
}

/**
 * 
 * @export
 * @interface UserAddedEvent
 */
export interface UserAddedEvent {
    /**
     * 
     * @type {string}
     * @memberof UserAddedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAddedEvent
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAddedEvent
     */
    email?: string;
    /**
     * 
     * @type {User}
     * @memberof UserAddedEvent
     */
    addedByUser?: User;
    /**
     * 
     * @type {string}
     * @memberof UserAddedEvent
     */
    groupId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserAddedEvent
     */
    locked?: boolean;
}

/**
 * 
 * @export
 * @interface UserApprovalAddedEvent
 */
export interface UserApprovalAddedEvent {
    /**
     * 
     * @type {string}
     * @memberof UserApprovalAddedEvent
     */
    id?: string;
    /**
     * 
     * @type {User}
     * @memberof UserApprovalAddedEvent
     */
    user?: User;
    /**
     * 
     * @type {string}
     * @memberof UserApprovalAddedEvent
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserApprovalAddedEvent
     */
    groupId?: string;
}

/**
 * 
 * @export
 * @interface UserAuthenticatedEvent
 */
export interface UserAuthenticatedEvent {
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedEvent
     */
    id?: string;
    /**
     * 
     * @type {User}
     * @memberof UserAuthenticatedEvent
     */
    user?: User;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedEvent
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedEvent
     */
    groupId?: string;
}

/**
 * 
 * @export
 * @interface UserDeletedFromGroupEvent
 */
export interface UserDeletedFromGroupEvent {
    /**
     * 
     * @type {string}
     * @memberof UserDeletedFromGroupEvent
     */
    id?: string;
    /**
     * 
     * @type {User}
     * @memberof UserDeletedFromGroupEvent
     */
    user?: User;
    /**
     * 
     * @type {string}
     * @memberof UserDeletedFromGroupEvent
     */
    groupId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserDeletedFromGroupEvent
     */
    deleted?: boolean;
}

/**
 * 
 * @export
 * @interface UserGroupAddedEvent
 */
export interface UserGroupAddedEvent {
    /**
     * 
     * @type {string}
     * @memberof UserGroupAddedEvent
     */
    id?: string;
    /**
     * 
     * @type {User}
     * @memberof UserGroupAddedEvent
     */
    user?: User;
    /**
     * 
     * @type {User}
     * @memberof UserGroupAddedEvent
     */
    addedByUser?: User;
    /**
     * 
     * @type {string}
     * @memberof UserGroupAddedEvent
     */
    groupId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserGroupAddedEvent
     */
    locked?: boolean;
}

/**
 * 
 * @export
 * @interface UserLockedUpdatedEvent
 */
export interface UserLockedUpdatedEvent {
    /**
     * 
     * @type {string}
     * @memberof UserLockedUpdatedEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLockedUpdatedEvent
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLockedUpdatedEvent
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLockedUpdatedEvent
     */
    groupId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserLockedUpdatedEvent
     */
    previousLocked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserLockedUpdatedEvent
     */
    locked?: boolean;
}

/**
 * 
 * @export
 * @interface UserRegistrationToken
 */
export interface UserRegistrationToken {
    /**
     * portfolio id
     * @type {string}
     * @memberof UserRegistrationToken
     */
    portfolioId?: string;
    /**
     * 
     * @type {Group}
     * @memberof UserRegistrationToken
     */
    group?: Group;
    /**
     * portfolio plan user role
     * @type {PortfolioPlanUserRole}
     * @memberof UserRegistrationToken
     */
    role?: PortfolioPlanUserRole;
    /**
     * 
     * @type {number}
     * @memberof UserRegistrationToken
     */
    expiresAt?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum UserStatus {
    ACTIVE = <any> 'ACTIVE',
    INVITED = <any> 'INVITED',
    LOCKED = <any> 'LOCKED',
    PASSWORDRESETPENDING = <any> 'PASSWORD_RESET_PENDING',
    PASSWORDEXPIRED = <any> 'PASSWORD_EXPIRED',
    SECRETKEYPENDING = <any> 'SECRET_KEY_PENDING',
    UNKNOWN = <any> 'UNKNOWN'
}

/**
 * 
 * @export
 * @interface UserUpdatedMessagePayload
 */
export interface UserUpdatedMessagePayload {
    /**
     * 
     * @type {User}
     * @memberof UserUpdatedMessagePayload
     */
    user?: User;
}

/**
 * 
 * @export
 * @interface ValueCount
 */
export interface ValueCount {
    /**
     * 
     * @type {string}
     * @memberof ValueCount
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof ValueCount
     */
    count?: number;
}

/**
 * 
 * @export
 * @interface ValueInsights
 */
export interface ValueInsights {
    /**
     * 
     * @type {Array<LikertScaleFieldInsight>}
     * @memberof ValueInsights
     */
    likertScaleFieldInsights?: Array<LikertScaleFieldInsight>;
}

/**
 * 
 * @export
 * @interface Warnings
 */
export interface Warnings {
    /**
     * 
     * @type {number}
     * @memberof Warnings
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Warnings
     */
    messages?: Array<string>;
}

/**
 * 
 * @export
 * @interface WhatsIn
 */
export interface WhatsIn {
    /**
     * 
     * @type {Array<ProjectSummary>}
     * @memberof WhatsIn
     */
    projectSummaries?: Array<ProjectSummary>;
    /**
     * 
     * @type {Array<PortfolioPlansWithProjects>}
     * @memberof WhatsIn
     */
    portfolioPlansWithProjects?: Array<PortfolioPlansWithProjects>;
    /**
     * 
     * @type {number}
     * @memberof WhatsIn
     */
    maxSize?: number;
    /**
     * 
     * @type {number}
     * @memberof WhatsIn
     */
    maxLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof WhatsIn
     */
    offset?: number;
    /**
     * 
     * @type {string}
     * @memberof WhatsIn
     */
    href?: string;
}

/**
 * 
 * @export
 * @interface Wiwo
 */
export interface Wiwo {
    /**
     * 
     * @type {Projects}
     * @memberof Wiwo
     */
    inProjects?: Projects;
    /**
     * 
     * @type {Projects}
     * @memberof Wiwo
     */
    outProjects?: Projects;
}

/**
 * 
 * @export
 * @interface Activities
 */
export interface Activities extends DlCollection {
    /**
     * 
     * @type {Array<Activity>}
     * @memberof Activities
     */
    items?: Array<Activity>;
}

/**
 * 
 * @export
 * @interface Activity
 */
export interface Activity extends DlResource {
    /**
     * 
     * @type {ActivityType}
     * @memberof Activity
     */
    type?: ActivityType;
    /**
     * 
     * @type {User}
     * @memberof Activity
     */
    user?: User;
    /**
     * 
     * @type {any}
     * @memberof Activity
     */
    data?: any;
}

/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    size?: number;
    /**
     * 
     * @type {User}
     * @memberof Attachment
     */
    user?: User;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    portfolioId?: string;
}

/**
 * 
 * @export
 * @interface Attachments
 */
export interface Attachments extends DlCollection {
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof Attachments
     */
    items?: Array<Attachment>;
}

/**
 * 
 * @export
 * @interface BudgetAllocations
 */
export interface BudgetAllocations extends DlCollection {
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof BudgetAllocations
     */
    portfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {TimePeriodType}
     * @memberof BudgetAllocations
     */
    timePeriodType?: TimePeriodType;
    /**
     * 
     * @type {number}
     * @memberof BudgetAllocations
     */
    yearlyStartTime?: number;
    /**
     * 
     * @type {number}
     * @memberof BudgetAllocations
     */
    monthlyStartTime?: number;
    /**
     * 
     * @type {Array<BudgetAllocation>}
     * @memberof BudgetAllocations
     */
    items?: Array<BudgetAllocation>;
}

/**
 * 
 * @export
 * @interface CategoryOption
 */
export interface CategoryOption extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof CategoryOption
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryOption
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryOption
     */
    fieldId?: string;
    /**
     * 
     * @type {number}
     * @memberof CategoryOption
     */
    position?: number;
}

/**
 * 
 * @export
 * @interface CategoryOptions
 */
export interface CategoryOptions extends DlCollection {
    /**
     * 
     * @type {Array<CategoryOption>}
     * @memberof CategoryOptions
     */
    items?: Array<CategoryOption>;
}

/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    portfolioId?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    projectId?: string;
    /**
     * 
     * @type {User}
     * @memberof Comment
     */
    user?: User;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    value?: string;
    /**
     * 
     * @type {Array<PortfolioPlanUser>}
     * @memberof Comment
     */
    contributorsAdded?: Array<PortfolioPlanUser>;
}

/**
 * 
 * @export
 * @interface Comments
 */
export interface Comments extends DlCollection {
    /**
     * 
     * @type {Array<Comment>}
     * @memberof Comments
     */
    items?: Array<Comment>;
}

/**
 * 
 * @export
 * @interface CustomNames
 */
export interface CustomNames extends DlCollection {
    /**
     * 
     * @type {Array<CustomName>}
     * @memberof CustomNames
     */
    items?: Array<CustomName>;
}

/**
 * 
 * @export
 * @interface Field
 */
export interface Field extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    originalName?: string;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    description?: string;
    /**
     * 
     * @type {FieldType}
     * @memberof Field
     */
    type?: FieldType;
    /**
     * 
     * @type {Source}
     * @memberof Field
     */
    source?: Source;
    /**
     * 
     * @type {Portfolio}
     * @memberof Field
     */
    portfolio?: Portfolio;
    /**
     * 
     * @type {Field}
     * @memberof Field
     */
    parent?: Field;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    position?: number;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    typePosition?: number;
    /**
     * 
     * @type {FieldValues}
     * @memberof Field
     */
    fieldValues?: FieldValues;
    /**
     * 
     * @type {TargetType}
     * @memberof Field
     */
    targetType?: TargetType;
    /**
     * 
     * @type {DataType}
     * @memberof Field
     */
    dataType?: DataType;
    /**
     * 
     * @type {CalculationType}
     * @memberof Field
     */
    calculationType?: CalculationType;
    /**
     * 
     * @type {boolean}
     * @memberof Field
     */
    isFieldTypeApproved?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Field
     */
    tagIds?: Array<string>;
    /**
     * 
     * @type {CategoryOptions}
     * @memberof Field
     */
    categoryOptions?: CategoryOptions;
    /**
     * 
     * @type {boolean}
     * @memberof Field
     */
    isIdeaField?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    ideaFieldPosition?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Field
     */
    isIdeaFieldRequired?: boolean;
    /**
     * 
     * @type {Scale}
     * @memberof Field
     */
    scale?: Scale;
    /**
     * 
     * @type {FieldAttributes}
     * @memberof Field
     */
    attributes?: FieldAttributes;
}

/**
 * 
 * @export
 * @interface FieldGrades
 */
export interface FieldGrades extends DlCollection {
    /**
     * 
     * @type {Array<FieldGrade>}
     * @memberof FieldGrades
     */
    items?: Array<FieldGrade>;
}

/**
 * 
 * @export
 * @interface FieldValues
 */
export interface FieldValues extends DlCollection {
    /**
     * 
     * @type {Array<FieldValue>}
     * @memberof FieldValues
     */
    items?: Array<FieldValue>;
    /**
     * 
     * @type {FieldValuesCollectionInfo}
     * @memberof FieldValues
     */
    collectionInfo?: FieldValuesCollectionInfo;
}

/**
 * 
 * @export
 * @interface Fields
 */
export interface Fields extends DlCollection {
    /**
     * 
     * @type {Array<Field>}
     * @memberof Fields
     */
    items?: Array<Field>;
}

/**
 * 
 * @export
 * @interface FileAttachment
 */
export interface FileAttachment extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof FileAttachment
     */
    fileContent?: string;
}

/**
 * 
 * @export
 * @interface Goals
 */
export interface Goals extends DlCollection {
    /**
     * 
     * @type {Array<Goal>}
     * @memberof Goals
     */
    items?: Array<Goal>;
}

/**
 * 
 * @export
 * @interface Group
 */
export interface Group extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    domain?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    linkedDomain?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    parentDomain?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    isActive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    authType?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    authUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    logoutUrl?: string;
    /**
     * 
     * @type {Users}
     * @memberof Group
     */
    users?: Users;
}

/**
 * 
 * @export
 * @interface Groups
 */
export interface Groups extends DlCollection {
    /**
     * 
     * @type {Array<Group>}
     * @memberof Groups
     */
    items?: Array<Group>;
}

/**
 * 
 * @export
 * @interface JiraFieldMapping
 */
export interface JiraFieldMapping extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof JiraFieldMapping
     */
    jiraFieldId?: string;
    /**
     * 
     * @type {string}
     * @memberof JiraFieldMapping
     */
    dlFieldId?: string;
    /**
     * 
     * @type {FieldType}
     * @memberof JiraFieldMapping
     */
    dlFieldType?: FieldType;
    /**
     * 
     * @type {DataType}
     * @memberof JiraFieldMapping
     */
    dlDataType?: DataType;
    /**
     * 
     * @type {Tags}
     * @memberof JiraFieldMapping
     */
    dlTags?: Tags;
    /**
     * 
     * @type {CategoryOptions}
     * @memberof JiraFieldMapping
     */
    dlCategories?: CategoryOptions;
}

/**
 * 
 * @export
 * @interface JiraFieldMappings
 */
export interface JiraFieldMappings extends DlCollection {
    /**
     * 
     * @type {Array<JiraFieldMapping>}
     * @memberof JiraFieldMappings
     */
    items?: Array<JiraFieldMapping>;
}

/**
 * 
 * @export
 * @interface JiraInstance
 */
export interface JiraInstance extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof JiraInstance
     */
    jiraBaseUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof JiraInstance
     */
    jiraConsumerKey?: string;
    /**
     * 
     * @type {string}
     * @memberof JiraInstance
     */
    jiraPrivateKey?: string;
    /**
     * 
     * @type {string}
     * @memberof JiraInstance
     */
    jiraProjectId?: string;
    /**
     * 
     * @type {string}
     * @memberof JiraInstance
     */
    dlClientKey?: string;
    /**
     * 
     * @type {string}
     * @memberof JiraInstance
     */
    dlSecretKey?: string;
    /**
     * 
     * @type {string}
     * @memberof JiraInstance
     */
    dlPortfolioId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JiraInstance
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JiraInstance
     */
    lastSyncAttempt?: string;
    /**
     * 
     * @type {string}
     * @memberof JiraInstance
     */
    lastSuccessfulSync?: string;
    /**
     * 
     * @type {string}
     * @memberof JiraInstance
     */
    lastSyncMessage?: string;
}

/**
 * 
 * @export
 * @interface Mapping
 */
export interface Mapping extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof Mapping
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Mapping
     */
    originalName?: string;
    /**
     * 
     * @type {FieldType}
     * @memberof Mapping
     */
    type?: FieldType;
    /**
     * 
     * @type {FieldType}
     * @memberof Mapping
     */
    inititalType?: FieldType;
    /**
     * 
     * @type {TargetType}
     * @memberof Mapping
     */
    targetType?: TargetType;
    /**
     * 
     * @type {DataType}
     * @memberof Mapping
     */
    dataType?: DataType;
    /**
     * 
     * @type {ImportType}
     * @memberof Mapping
     */
    importType?: ImportType;
    /**
     * 
     * @type {number}
     * @memberof Mapping
     */
    position?: number;
    /**
     * 
     * @type {DateFormat}
     * @memberof Mapping
     */
    dateFormat?: DateFormat;
    /**
     * 
     * @type {Array<string>}
     * @memberof Mapping
     */
    rawDateFormats?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Mapping
     */
    values?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Mapping
     */
    numericValues?: Array<number>;
    /**
     * 
     * @type {Array<boolean>}
     * @memberof Mapping
     */
    booleanValues?: Array<boolean>;
    /**
     * 
     * @type {TimePeriod}
     * @memberof Mapping
     */
    timePeriod?: TimePeriod;
    /**
     * 
     * @type {boolean}
     * @memberof Mapping
     */
    isDuplicated?: boolean;
}

/**
 * 
 * @export
 * @interface Permissions
 */
export interface Permissions extends DlCollection {
    /**
     * 
     * @type {Array<Permission>}
     * @memberof Permissions
     */
    items?: Array<Permission>;
}

/**
 * 
 * @export
 * @interface PlanGrade
 */
export interface PlanGrade extends DlResource {
    /**
     * 
     * @type {PlanType}
     * @memberof PlanGrade
     */
    type?: PlanType;
    /**
     * 
     * @type {Grade}
     * @memberof PlanGrade
     */
    grade?: Grade;
    /**
     * 
     * @type {FieldGrades}
     * @memberof PlanGrade
     */
    fieldGrades?: FieldGrades;
}

/**
 * 
 * @export
 * @interface Portfolio
 */
export interface Portfolio extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof Portfolio
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Portfolio
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Portfolio
     */
    isArchived?: boolean;
    /**
     * 
     * @type {PortfolioPlanUser}
     * @memberof Portfolio
     */
    baselinePortfolioPlanUser?: PortfolioPlanUser;
    /**
     * 
     * @type {Fields}
     * @memberof Portfolio
     */
    fields?: Fields;
    /**
     * 
     * @type {Projects}
     * @memberof Portfolio
     */
    projects?: Projects;
    /**
     * 
     * @type {PortfolioPlans}
     * @memberof Portfolio
     */
    portfolioPlans?: PortfolioPlans;
    /**
     * 
     * @type {PortfolioPlanUsers}
     * @memberof Portfolio
     */
    portfolioPlanUsers?: PortfolioPlanUsers;
    /**
     * 
     * @type {Attributes}
     * @memberof Portfolio
     */
    attributes?: Attributes;
    /**
     * 
     * @type {boolean}
     * @memberof Portfolio
     */
    isCombined?: boolean;
    /**
     * user registration token string
     * @type {string}
     * @memberof Portfolio
     */
    userRegistrationToken?: string;
    /**
     * 
     * @type {Array<Portfolio>}
     * @memberof Portfolio
     */
    subPortfolios?: Array<Portfolio>;
    /**
     * 
     * @type {Array<Portfolio>}
     * @memberof Portfolio
     */
    combinedPortfolios?: Array<Portfolio>;
    /**
     * 
     * @type {ResourcePools}
     * @memberof Portfolio
     */
    resourcePools?: ResourcePools;
    /**
     * 
     * @type {number}
     * @memberof Portfolio
     */
    totalBudget?: number;
    /**
     * 
     * @type {number}
     * @memberof Portfolio
     */
    newNotificationsCount?: number;
    /**
     * 
     * @type {CustomNames}
     * @memberof Portfolio
     */
    customNames?: CustomNames;
}

/**
 * 
 * @export
 * @interface PortfolioPlan
 */
export interface PortfolioPlan extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlan
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortfolioPlan
     */
    isBaseline?: boolean;
    /**
     * 
     * @type {Portfolio}
     * @memberof PortfolioPlan
     */
    portfolio?: Portfolio;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlan
     */
    parentPortfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {PortfolioPlanUsers}
     * @memberof PortfolioPlan
     */
    portfolioPlanUsers?: PortfolioPlanUsers;
    /**
     * 
     * @type {PortfolioPlanUser}
     * @memberof PortfolioPlan
     */
    currentPortfolioPlanUser?: PortfolioPlanUser;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlan
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface PortfolioPlanGrades
 */
export interface PortfolioPlanGrades extends DlCollection {
    /**
     * 
     * @type {Array<PortfolioPlanGrade>}
     * @memberof PortfolioPlanGrades
     */
    items?: Array<PortfolioPlanGrade>;
    /**
     * 
     * @type {Portfolio}
     * @memberof PortfolioPlanGrades
     */
    portfolio?: Portfolio;
    /**
     * 
     * @type {Array<PortfolioPlanGrades>}
     * @memberof PortfolioPlanGrades
     */
    details?: Array<PortfolioPlanGrades>;
    /**
     * 
     * @type {GradingType}
     * @memberof PortfolioPlanGrades
     */
    gradingType?: GradingType;
}

/**
 * 
 * @export
 * @interface PortfolioPlanInsights
 */
export interface PortfolioPlanInsights extends DlResource {
    /**
     * 
     * @type {Portfolio}
     * @memberof PortfolioPlanInsights
     */
    portfolio?: Portfolio;
    /**
     * 
     * @type {Array<PortfolioPlanInsights>}
     * @memberof PortfolioPlanInsights
     */
    subPortfolioInsights?: Array<PortfolioPlanInsights>;
    /**
     * 
     * @type {Array<Insight>}
     * @memberof PortfolioPlanInsights
     */
    insights?: Array<Insight>;
    /**
     * 
     * @type {Array<CategorizationInsight>}
     * @memberof PortfolioPlanInsights
     */
    statusInsights?: Array<CategorizationInsight>;
    /**
     * 
     * @type {number}
     * @memberof PortfolioPlanInsights
     */
    budget?: number;
    /**
     * 
     * @type {number}
     * @memberof PortfolioPlanInsights
     */
    allocation?: number;
    /**
     * 
     * @type {GradingType}
     * @memberof PortfolioPlanInsights
     */
    gradingType?: GradingType;
    /**
     * 
     * @type {Wiwo}
     * @memberof PortfolioPlanInsights
     */
    wiwo?: Wiwo;
}

/**
 * 
 * @export
 * @interface PortfolioPlanUser
 */
export interface PortfolioPlanUser extends DlResource {
    /**
     * 
     * @type {User}
     * @memberof PortfolioPlanUser
     */
    user: User;
    /**
     * 
     * @type {PortfolioPlan}
     * @memberof PortfolioPlanUser
     */
    portfolioPlan?: PortfolioPlan;
    /**
     * 
     * @type {Array<PortfolioPlanUserRole>}
     * @memberof PortfolioPlanUser
     */
    roles?: Array<PortfolioPlanUserRole>;
    /**
     * 
     * @type {Permissions}
     * @memberof PortfolioPlanUser
     */
    fieldPermissions?: Permissions;
    /**
     * 
     * @type {Permissions}
     * @memberof PortfolioPlanUser
     */
    projectPermissions?: Permissions;
    /**
     * 
     * @type {string}
     * @memberof PortfolioPlanUser
     */
    portfolioLastUpdatedAt?: string;
}

/**
 * 
 * @export
 * @interface PortfolioPlanUsers
 */
export interface PortfolioPlanUsers extends DlCollection {
    /**
     * 
     * @type {Array<PortfolioPlanUser>}
     * @memberof PortfolioPlanUsers
     */
    items?: Array<PortfolioPlanUser>;
}

/**
 * 
 * @export
 * @interface PortfolioPlans
 */
export interface PortfolioPlans extends DlCollection {
    /**
     * 
     * @type {Array<PortfolioPlan>}
     * @memberof PortfolioPlans
     */
    items?: Array<PortfolioPlan>;
}

/**
 * 
 * @export
 * @interface Portfolios
 */
export interface Portfolios extends DlCollection {
    /**
     * 
     * @type {Array<Portfolio>}
     * @memberof Portfolios
     */
    items?: Array<Portfolio>;
}

/**
 * 
 * @export
 * @interface Project
 */
export interface Project extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    position?: number;
    /**
     * 
     * @type {FieldValues}
     * @memberof Project
     */
    fieldValues?: FieldValues;
    /**
     * 
     * @type {Array<string>}
     * @memberof Project
     */
    dependsOnProjectIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Project
     */
    hasDependentProjectIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Project
     */
    contributingUserIds?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Project
     */
    isDraft?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    rank?: number;
}

/**
 * 
 * @export
 * @interface Projects
 */
export interface Projects extends DlCollection {
    /**
     * 
     * @type {Array<Project>}
     * @memberof Projects
     */
    items?: Array<Project>;
}

/**
 * 
 * @export
 * @interface Properties
 */
export interface Properties extends DlCollection {
    /**
     * 
     * @type {Array<Property>}
     * @memberof Properties
     */
    items?: Array<Property>;
}

/**
 * 
 * @export
 * @interface Recommendations
 */
export interface Recommendations extends DlCollection {
    /**
     * 
     * @type {string}
     * @memberof Recommendations
     */
    portfolioPlanId?: string;
    /**
     * 
     * @type {Array<Recommendation>}
     * @memberof Recommendations
     */
    items?: Array<Recommendation>;
    /**
     * 
     * @type {PortfolioPlanInsights}
     * @memberof Recommendations
     */
    initialPortfolioPlanInsights?: PortfolioPlanInsights;
    /**
     * 
     * @type {string}
     * @memberof Recommendations
     */
    scheduleResultInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof Recommendations
     */
    overconstrainedMessage?: string;
}

/**
 * 
 * @export
 * @interface ResourcePool
 */
export interface ResourcePool extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof ResourcePool
     */
    name?: string;
    /**
     * 
     * @type {ResourcePoolBudgetAmounts}
     * @memberof ResourcePool
     */
    budgetAmounts?: ResourcePoolBudgetAmounts;
    /**
     * 
     * @type {Field}
     * @memberof ResourcePool
     */
    field?: Field;
    /**
     * 
     * @type {Array<ResourcePoolFieldValue>}
     * @memberof ResourcePool
     */
    fieldValues?: Array<ResourcePoolFieldValue>;
}

/**
 * 
 * @export
 * @interface ResourcePoolBudgetAmounts
 */
export interface ResourcePoolBudgetAmounts extends DlCollection {
    /**
     * 
     * @type {Array<ResourcePoolBudgetAmount>}
     * @memberof ResourcePoolBudgetAmounts
     */
    items?: Array<ResourcePoolBudgetAmount>;
}

/**
 * 
 * @export
 * @interface ResourcePoolFieldValue
 */
export interface ResourcePoolFieldValue extends FieldValue {
    /**
     * 
     * @type {ResourcePool}
     * @memberof ResourcePoolFieldValue
     */
    resourcePool?: ResourcePool;
}

/**
 * 
 * @export
 * @interface ResourcePools
 */
export interface ResourcePools extends DlCollection {
    /**
     * 
     * @type {Array<ResourcePool>}
     * @memberof ResourcePools
     */
    items?: Array<ResourcePool>;
}

/**
 * 
 * @export
 * @interface ScoreWeight
 */
export interface ScoreWeight extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof ScoreWeight
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScoreWeight
     */
    isDefault?: boolean;
    /**
     * 
     * @type {Array<FieldWeight>}
     * @memberof ScoreWeight
     */
    fieldWeights?: Array<FieldWeight>;
}

/**
 * 
 * @export
 * @interface ScoreWeights
 */
export interface ScoreWeights extends DlCollection {
    /**
     * 
     * @type {Array<ScoreWeight>}
     * @memberof ScoreWeights
     */
    items?: Array<ScoreWeight>;
}

/**
 * 
 * @export
 * @interface ServiceInfoDetails
 */
export interface ServiceInfoDetails extends DlCollection {
    /**
     * 
     * @type {Array<ServiceInfo>}
     * @memberof ServiceInfoDetails
     */
    details?: Array<ServiceInfo>;
}

/**
 * 
 * @export
 * @interface Sheets
 */
export interface Sheets extends DlCollection {
    /**
     * 
     * @type {Array<Sheet>}
     * @memberof Sheets
     */
    items?: Array<Sheet>;
}

/**
 * 
 * @export
 * @interface Source
 */
export interface Source extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    name?: string;
    /**
     * 
     * @type {SourceType}
     * @memberof Source
     */
    type: SourceType;
    /**
     * 
     * @type {Portfolio}
     * @memberof Source
     */
    portfolio?: Portfolio;
    /**
     * 
     * @type {Fields}
     * @memberof Source
     */
    fields?: Fields;
    /**
     * 
     * @type {Projects}
     * @memberof Source
     */
    projects?: Projects;
    /**
     * 
     * @type {DlcPortfolio}
     * @memberof Source
     */
    dlcPortfolio?: DlcPortfolio;
}

/**
 * 
 * @export
 * @interface Spreadsheet
 */
export interface Spreadsheet extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof Spreadsheet
     */
    name?: string;
    /**
     * 
     * @type {Sheets}
     * @memberof Spreadsheet
     */
    sheets?: Sheets;
}

/**
 * 
 * @export
 * @interface SpreadsheetFields
 */
export interface SpreadsheetFields extends DlCollection {
    /**
     * 
     * @type {Array<SpreadsheetField>}
     * @memberof SpreadsheetFields
     */
    items?: Array<SpreadsheetField>;
    /**
     * 
     * @type {number}
     * @memberof SpreadsheetFields
     */
    newFieldsSize?: number;
}

/**
 * 
 * @export
 * @interface SpreadsheetWarnings
 */
export interface SpreadsheetWarnings extends DlCollection {
    /**
     * 
     * @type {Array<SpreadsheetWarning>}
     * @memberof SpreadsheetWarnings
     */
    items?: Array<SpreadsheetWarning>;
}

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    parentId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Tag
     */
    isDefault?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    portfolioId?: string;
}

/**
 * 
 * @export
 * @interface Tags
 */
export interface Tags extends DlCollection {
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Tags
     */
    items?: Array<Tag>;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User extends DlResource {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof User
     */
    status?: UserStatus;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    lastLoginAt?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    invitationUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    invitationUrlExpiration?: number;
    /**
     * 
     * @type {RoleType}
     * @memberof User
     */
    role?: RoleType;
}

/**
 * 
 * @export
 * @interface Users
 */
export interface Users extends DlCollection {
    /**
     * 
     * @type {Array<User>}
     * @memberof Users
     */
    items?: Array<User>;
}

/**
 * 
 * @export
 * @interface ValueCounts
 */
export interface ValueCounts extends DlCollection {
    /**
     * 
     * @type {Array<ValueCount>}
     * @memberof ValueCounts
     */
    items?: Array<ValueCount>;
}


/**
 * ActivitiesApi - fetch parameter creator
 * @export
 */
export const ActivitiesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Reindex activities. System Administator operation.
         * @param {Array<string>} [domains] List of domains for where activities need to be reindexed, if not provided reindex will be done for all domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reindexActivities(domains?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/reindex/activities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (domains) {
                localVarQueryParameter['domains'] = domains.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Reindex activities. System Administator operation.
         * @param {Array<string>} [domains] List of domains for where activities need to be reindexed, if not provided reindex will be done for all domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reindexActivities(domains?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).reindexActivities(domains, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Reindex activities. System Administator operation.
         * @param {Array<string>} [domains] List of domains for where activities need to be reindexed, if not provided reindex will be done for all domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reindexActivities(domains?: Array<string>, options?: any) {
            return ActivitiesApiFp(configuration).reindexActivities(domains, options)(fetch, basePath);
        },
    };
};

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * 
     * @summary Reindex activities. System Administator operation.
     * @param {Array<string>} [domains] List of domains for where activities need to be reindexed, if not provided reindex will be done for all domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public reindexActivities(domains?: Array<string>, options?: any) {
        return ActivitiesApiFp(this.configuration).reindexActivities(domains, options)(this.fetch, this.basePath);
    }

}

/**
 * ApiActivityApi - fetch parameter creator
 * @export
 */
export const ApiActivityApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Reset last API Acitivity time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetApiActivityTime(options: any = {}): FetchArgs {
            const localVarPath = `/apiActivity/reset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiActivityApi - functional programming interface
 * @export
 */
export const ApiActivityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Reset last API Acitivity time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetApiActivityTime(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ApiActivityApiFetchParamCreator(configuration).resetApiActivityTime(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ApiActivityApi - factory interface
 * @export
 */
export const ApiActivityApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Reset last API Acitivity time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetApiActivityTime(options?: any) {
            return ApiActivityApiFp(configuration).resetApiActivityTime(options)(fetch, basePath);
        },
    };
};

/**
 * ApiActivityApi - object-oriented interface
 * @export
 * @class ApiActivityApi
 * @extends {BaseAPI}
 */
export class ApiActivityApi extends BaseAPI {
    /**
     * 
     * @summary Reset last API Acitivity time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiActivityApi
     */
    public resetApiActivityTime(options?: any) {
        return ApiActivityApiFp(this.configuration).resetApiActivityTime(options)(this.fetch, this.basePath);
    }

}

/**
 * AttachmentsApi - fetch parameter creator
 * @export
 */
export const AttachmentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new attachment from a file upload
         * @param {any} file File to be uploaded
         * @param {string} portfolioId the portfolio id that the attachment belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment(file: any, portfolioId: string, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling createAttachment.');
            }
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling createAttachment.');
            }
            const localVarPath = `/attachments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads the file content of an Attachment
         * @param {string} id Attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling downloadAttachment.');
            }
            const localVarPath = `/attachments/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Attachment by id
         * @param {string} id Attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAttachment.');
            }
            const localVarPath = `/attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Attachment by portfolio id
         * @param {string} portfolioId Portfolio id
         * @param {number} [offset] Pagination offset
         * @param {number} [limit] Pagination limit
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(portfolioId: string, offset?: number, limit?: number, orderBy?: string, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getAttachments.');
            }
            const localVarPath = `/attachments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single attachment
         * @param {string} id Attachment ID
         * @param {Operations} body JSON Patch operations to update value field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachment(id: string, body: Operations, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAttachment.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateAttachment.');
            }
            const localVarPath = `/attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Operations" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttachmentsApi - functional programming interface
 * @export
 */
export const AttachmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new attachment from a file upload
         * @param {any} file File to be uploaded
         * @param {string} portfolioId the portfolio id that the attachment belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment(file: any, portfolioId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Attachment> {
            const localVarFetchArgs = AttachmentsApiFetchParamCreator(configuration).createAttachment(file, portfolioId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Downloads the file content of an Attachment
         * @param {string} id Attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AttachmentsApiFetchParamCreator(configuration).downloadAttachment(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Attachment by id
         * @param {string} id Attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Attachment> {
            const localVarFetchArgs = AttachmentsApiFetchParamCreator(configuration).getAttachment(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Attachment by portfolio id
         * @param {string} portfolioId Portfolio id
         * @param {number} [offset] Pagination offset
         * @param {number} [limit] Pagination limit
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(portfolioId: string, offset?: number, limit?: number, orderBy?: string, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Attachments> {
            const localVarFetchArgs = AttachmentsApiFetchParamCreator(configuration).getAttachments(portfolioId, offset, limit, orderBy, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a single attachment
         * @param {string} id Attachment ID
         * @param {Operations} body JSON Patch operations to update value field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachment(id: string, body: Operations, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Attachment> {
            const localVarFetchArgs = AttachmentsApiFetchParamCreator(configuration).updateAttachment(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AttachmentsApi - factory interface
 * @export
 */
export const AttachmentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Creates a new attachment from a file upload
         * @param {any} file File to be uploaded
         * @param {string} portfolioId the portfolio id that the attachment belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment(file: any, portfolioId: string, options?: any) {
            return AttachmentsApiFp(configuration).createAttachment(file, portfolioId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Downloads the file content of an Attachment
         * @param {string} id Attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(id: string, options?: any) {
            return AttachmentsApiFp(configuration).downloadAttachment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Attachment by id
         * @param {string} id Attachment id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(id: string, options?: any) {
            return AttachmentsApiFp(configuration).getAttachment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Attachment by portfolio id
         * @param {string} portfolioId Portfolio id
         * @param {number} [offset] Pagination offset
         * @param {number} [limit] Pagination limit
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(portfolioId: string, offset?: number, limit?: number, orderBy?: string, match?: string, options?: any) {
            return AttachmentsApiFp(configuration).getAttachments(portfolioId, offset, limit, orderBy, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a single attachment
         * @param {string} id Attachment ID
         * @param {Operations} body JSON Patch operations to update value field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachment(id: string, body: Operations, options?: any) {
            return AttachmentsApiFp(configuration).updateAttachment(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
export class AttachmentsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new attachment from a file upload
     * @param {any} file File to be uploaded
     * @param {string} portfolioId the portfolio id that the attachment belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public createAttachment(file: any, portfolioId: string, options?: any) {
        return AttachmentsApiFp(this.configuration).createAttachment(file, portfolioId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Downloads the file content of an Attachment
     * @param {string} id Attachment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public downloadAttachment(id: string, options?: any) {
        return AttachmentsApiFp(this.configuration).downloadAttachment(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Attachment by id
     * @param {string} id Attachment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public getAttachment(id: string, options?: any) {
        return AttachmentsApiFp(this.configuration).getAttachment(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Attachment by portfolio id
     * @param {string} portfolioId Portfolio id
     * @param {number} [offset] Pagination offset
     * @param {number} [limit] Pagination limit
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public getAttachments(portfolioId: string, offset?: number, limit?: number, orderBy?: string, match?: string, options?: any) {
        return AttachmentsApiFp(this.configuration).getAttachments(portfolioId, offset, limit, orderBy, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a single attachment
     * @param {string} id Attachment ID
     * @param {Operations} body JSON Patch operations to update value field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public updateAttachment(id: string, body: Operations, options?: any) {
        return AttachmentsApiFp(this.configuration).updateAttachment(id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * BudgetFieldsApi - fetch parameter creator
 * @export
 */
export const BudgetFieldsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new budget field
         * @param {Field} body Budget field to create
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBudgetField(body: Field, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createBudgetField.');
            }
            const localVarPath = `/fields/budgets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Field" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a budget field
         * @param {string} id Budget field id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudgetField(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteBudgetField.');
            }
            const localVarPath = `/fields/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a budget field
         * @param {string} id Budget field id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetField(id: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getBudgetField.');
            }
            const localVarPath = `/fields/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves budget fields for a portfolio.
         * @param {string} portfolioId Portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetFieldsForPortfolio(portfolioId: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getBudgetFieldsForPortfolio.');
            }
            const localVarPath = `/fields/budgets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a budget field utilizing JSON Patch Operations.
         * @param {string} id Budget field id
         * @param {Operations} body JSON Patch Operations to update budget field.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetField(id: string, body: Operations, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateBudgetField.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateBudgetField.');
            }
            const localVarPath = `/fields/budgets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Operations" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update budget fields
         * @param {Array<PatchItem>} body JSON Patch Operations to update multiple budgeet fields.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetFields(body: Array<PatchItem>, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateBudgetFields.');
            }
            const localVarPath = `/fields/budgets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;PatchItem&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetFieldsApi - functional programming interface
 * @export
 */
export const BudgetFieldsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new budget field
         * @param {Field} body Budget field to create
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBudgetField(body: Field, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Field>> {
            const localVarFetchArgs = BudgetFieldsApiFetchParamCreator(configuration).createBudgetField(body, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a budget field
         * @param {string} id Budget field id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudgetField(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BudgetFieldsApiFetchParamCreator(configuration).deleteBudgetField(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves a budget field
         * @param {string} id Budget field id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetField(id: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Field> {
            const localVarFetchArgs = BudgetFieldsApiFetchParamCreator(configuration).getBudgetField(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves budget fields for a portfolio.
         * @param {string} portfolioId Portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetFieldsForPortfolio(portfolioId: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Fields> {
            const localVarFetchArgs = BudgetFieldsApiFetchParamCreator(configuration).getBudgetFieldsForPortfolio(portfolioId, expand, limit, offset, orderBy, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a budget field utilizing JSON Patch Operations.
         * @param {string} id Budget field id
         * @param {Operations} body JSON Patch Operations to update budget field.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetField(id: string, body: Operations, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Field>> {
            const localVarFetchArgs = BudgetFieldsApiFetchParamCreator(configuration).updateBudgetField(id, body, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update budget fields
         * @param {Array<PatchItem>} body JSON Patch Operations to update multiple budgeet fields.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetFields(body: Array<PatchItem>, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Field>> {
            const localVarFetchArgs = BudgetFieldsApiFetchParamCreator(configuration).updateBudgetFields(body, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BudgetFieldsApi - factory interface
 * @export
 */
export const BudgetFieldsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Creates a new budget field
         * @param {Field} body Budget field to create
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBudgetField(body: Field, expand?: string, options?: any) {
            return BudgetFieldsApiFp(configuration).createBudgetField(body, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a budget field
         * @param {string} id Budget field id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudgetField(id: string, options?: any) {
            return BudgetFieldsApiFp(configuration).deleteBudgetField(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves a budget field
         * @param {string} id Budget field id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetField(id: string, expand?: string, options?: any) {
            return BudgetFieldsApiFp(configuration).getBudgetField(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves budget fields for a portfolio.
         * @param {string} portfolioId Portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetFieldsForPortfolio(portfolioId: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
            return BudgetFieldsApiFp(configuration).getBudgetFieldsForPortfolio(portfolioId, expand, limit, offset, orderBy, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a budget field utilizing JSON Patch Operations.
         * @param {string} id Budget field id
         * @param {Operations} body JSON Patch Operations to update budget field.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetField(id: string, body: Operations, expand?: string, options?: any) {
            return BudgetFieldsApiFp(configuration).updateBudgetField(id, body, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update budget fields
         * @param {Array<PatchItem>} body JSON Patch Operations to update multiple budgeet fields.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudgetFields(body: Array<PatchItem>, expand?: string, options?: any) {
            return BudgetFieldsApiFp(configuration).updateBudgetFields(body, expand, options)(fetch, basePath);
        },
    };
};

/**
 * BudgetFieldsApi - object-oriented interface
 * @export
 * @class BudgetFieldsApi
 * @extends {BaseAPI}
 */
export class BudgetFieldsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new budget field
     * @param {Field} body Budget field to create
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetFieldsApi
     */
    public createBudgetField(body: Field, expand?: string, options?: any) {
        return BudgetFieldsApiFp(this.configuration).createBudgetField(body, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a budget field
     * @param {string} id Budget field id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetFieldsApi
     */
    public deleteBudgetField(id: string, options?: any) {
        return BudgetFieldsApiFp(this.configuration).deleteBudgetField(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves a budget field
     * @param {string} id Budget field id
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetFieldsApi
     */
    public getBudgetField(id: string, expand?: string, options?: any) {
        return BudgetFieldsApiFp(this.configuration).getBudgetField(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves budget fields for a portfolio.
     * @param {string} portfolioId Portfolio id
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetFieldsApi
     */
    public getBudgetFieldsForPortfolio(portfolioId: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
        return BudgetFieldsApiFp(this.configuration).getBudgetFieldsForPortfolio(portfolioId, expand, limit, offset, orderBy, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a budget field utilizing JSON Patch Operations.
     * @param {string} id Budget field id
     * @param {Operations} body JSON Patch Operations to update budget field.
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetFieldsApi
     */
    public updateBudgetField(id: string, body: Operations, expand?: string, options?: any) {
        return BudgetFieldsApiFp(this.configuration).updateBudgetField(id, body, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update budget fields
     * @param {Array<PatchItem>} body JSON Patch Operations to update multiple budgeet fields.
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetFieldsApi
     */
    public updateBudgetFields(body: Array<PatchItem>, expand?: string, options?: any) {
        return BudgetFieldsApiFp(this.configuration).updateBudgetFields(body, expand, options)(this.fetch, this.basePath);
    }

}

/**
 * CommentsApi - fetch parameter creator
 * @export
 */
export const CommentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new comment
         * @param {Comment} body Comment to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(body: Comment, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createComment.');
            }
            const localVarPath = `/comments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Comment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single comment
         * @param {string} id Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteComment.');
            }
            const localVarPath = `/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves comments based on params
         * @param {string} [portfolioId] Use when you want all comments from all projects inside this portfolio
         * @param {string} [projectId] Use when you want comments for a specific project
         * @param {number} [offset] The page number from where the search will be done
         * @param {number} [limit] Max number of comments which will be returned
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(portfolioId?: string, projectId?: string, offset?: number, limit?: number, orderBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/comments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single comment
         * @param {string} id Comment ID
         * @param {Operations} body JSON Patch operations to update value field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComment(id: string, body: Operations, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateComment.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateComment.');
            }
            const localVarPath = `/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Operations" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentsApi - functional programming interface
 * @export
 */
export const CommentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new comment
         * @param {Comment} body Comment to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(body: Comment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Comment> {
            const localVarFetchArgs = CommentsApiFetchParamCreator(configuration).createComment(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a single comment
         * @param {string} id Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CommentsApiFetchParamCreator(configuration).deleteComment(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves comments based on params
         * @param {string} [portfolioId] Use when you want all comments from all projects inside this portfolio
         * @param {string} [projectId] Use when you want comments for a specific project
         * @param {number} [offset] The page number from where the search will be done
         * @param {number} [limit] Max number of comments which will be returned
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(portfolioId?: string, projectId?: string, offset?: number, limit?: number, orderBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Comments> {
            const localVarFetchArgs = CommentsApiFetchParamCreator(configuration).getComments(portfolioId, projectId, offset, limit, orderBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a single comment
         * @param {string} id Comment ID
         * @param {Operations} body JSON Patch operations to update value field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComment(id: string, body: Operations, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Comment> {
            const localVarFetchArgs = CommentsApiFetchParamCreator(configuration).updateComment(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CommentsApi - factory interface
 * @export
 */
export const CommentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Creates a new comment
         * @param {Comment} body Comment to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(body: Comment, options?: any) {
            return CommentsApiFp(configuration).createComment(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a single comment
         * @param {string} id Comment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(id: string, options?: any) {
            return CommentsApiFp(configuration).deleteComment(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves comments based on params
         * @param {string} [portfolioId] Use when you want all comments from all projects inside this portfolio
         * @param {string} [projectId] Use when you want comments for a specific project
         * @param {number} [offset] The page number from where the search will be done
         * @param {number} [limit] Max number of comments which will be returned
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(portfolioId?: string, projectId?: string, offset?: number, limit?: number, orderBy?: string, options?: any) {
            return CommentsApiFp(configuration).getComments(portfolioId, projectId, offset, limit, orderBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a single comment
         * @param {string} id Comment ID
         * @param {Operations} body JSON Patch operations to update value field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComment(id: string, body: Operations, options?: any) {
            return CommentsApiFp(configuration).updateComment(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * CommentsApi - object-oriented interface
 * @export
 * @class CommentsApi
 * @extends {BaseAPI}
 */
export class CommentsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new comment
     * @param {Comment} body Comment to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public createComment(body: Comment, options?: any) {
        return CommentsApiFp(this.configuration).createComment(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a single comment
     * @param {string} id Comment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public deleteComment(id: string, options?: any) {
        return CommentsApiFp(this.configuration).deleteComment(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves comments based on params
     * @param {string} [portfolioId] Use when you want all comments from all projects inside this portfolio
     * @param {string} [projectId] Use when you want comments for a specific project
     * @param {number} [offset] The page number from where the search will be done
     * @param {number} [limit] Max number of comments which will be returned
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public getComments(portfolioId?: string, projectId?: string, offset?: number, limit?: number, orderBy?: string, options?: any) {
        return CommentsApiFp(this.configuration).getComments(portfolioId, projectId, offset, limit, orderBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a single comment
     * @param {string} id Comment ID
     * @param {Operations} body JSON Patch operations to update value field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public updateComment(id: string, body: Operations, options?: any) {
        return CommentsApiFp(this.configuration).updateComment(id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new category
         * @param {CategoryOption} body Category option to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategoryOption(body: CategoryOption, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCategoryOption.');
            }
            const localVarPath = `/fields/{fieldId}/categoryOption`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CategoryOption" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new category options
         * @param {CategoryOptions} body Category options to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategoryOptions(body: CategoryOptions, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCategoryOptions.');
            }
            const localVarPath = `/fields/{fieldId}/categoryOptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CategoryOptions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single category option
         * @param {string} fieldId Field id
         * @param {string} categoryOptionId Category Option ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryOption(fieldId: string, categoryOptionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'fieldId' is not null or undefined
            if (fieldId === null || fieldId === undefined) {
                throw new RequiredError('fieldId','Required parameter fieldId was null or undefined when calling deleteCategoryOption.');
            }
            // verify required parameter 'categoryOptionId' is not null or undefined
            if (categoryOptionId === null || categoryOptionId === undefined) {
                throw new RequiredError('categoryOptionId','Required parameter categoryOptionId was null or undefined when calling deleteCategoryOption.');
            }
            const localVarPath = `/fields/{fieldId}/categoryOptions/{categoryOptionId}`
                .replace(`{${"fieldId"}}`, encodeURIComponent(String(fieldId)))
                .replace(`{${"categoryOptionId"}}`, encodeURIComponent(String(categoryOptionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a category
         * @param {string} fieldId Field id
         * @param {string} categoryOptionId Category Option id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryOption(fieldId: string, categoryOptionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'fieldId' is not null or undefined
            if (fieldId === null || fieldId === undefined) {
                throw new RequiredError('fieldId','Required parameter fieldId was null or undefined when calling getCategoryOption.');
            }
            // verify required parameter 'categoryOptionId' is not null or undefined
            if (categoryOptionId === null || categoryOptionId === undefined) {
                throw new RequiredError('categoryOptionId','Required parameter categoryOptionId was null or undefined when calling getCategoryOption.');
            }
            const localVarPath = `/fields/{fieldId}/categoryOptions/{categoryOptionId}`
                .replace(`{${"fieldId"}}`, encodeURIComponent(String(fieldId)))
                .replace(`{${"categoryOptionId"}}`, encodeURIComponent(String(categoryOptionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves categories for a field
         * @param {string} fieldId Field id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryOptionsForField(fieldId: string, options: any = {}): FetchArgs {
            // verify required parameter 'fieldId' is not null or undefined
            if (fieldId === null || fieldId === undefined) {
                throw new RequiredError('fieldId','Required parameter fieldId was null or undefined when calling getCategoryOptionsForField.');
            }
            const localVarPath = `/fields/{fieldId}/categoryOptions`
                .replace(`{${"fieldId"}}`, encodeURIComponent(String(fieldId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single category
         * @param {string} fieldId Field id
         * @param {string} categoryOptionId Category Option id
         * @param {CategoryOption} body JSON Patch operations to update value field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategoryOption(fieldId: string, categoryOptionId: string, body: CategoryOption, options: any = {}): FetchArgs {
            // verify required parameter 'fieldId' is not null or undefined
            if (fieldId === null || fieldId === undefined) {
                throw new RequiredError('fieldId','Required parameter fieldId was null or undefined when calling updateCategoryOption.');
            }
            // verify required parameter 'categoryOptionId' is not null or undefined
            if (categoryOptionId === null || categoryOptionId === undefined) {
                throw new RequiredError('categoryOptionId','Required parameter categoryOptionId was null or undefined when calling updateCategoryOption.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCategoryOption.');
            }
            const localVarPath = `/fields/{fieldId}/categoryOptions/{categoryOptionId}`
                .replace(`{${"fieldId"}}`, encodeURIComponent(String(fieldId)))
                .replace(`{${"categoryOptionId"}}`, encodeURIComponent(String(categoryOptionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CategoryOption" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new category
         * @param {CategoryOption} body Category option to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategoryOption(body: CategoryOption, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryOption> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).createCategoryOption(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new category options
         * @param {CategoryOptions} body Category options to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategoryOptions(body: CategoryOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryOptions> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).createCategoryOptions(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a single category option
         * @param {string} fieldId Field id
         * @param {string} categoryOptionId Category Option ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryOption(fieldId: string, categoryOptionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).deleteCategoryOption(fieldId, categoryOptionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves a category
         * @param {string} fieldId Field id
         * @param {string} categoryOptionId Category Option id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryOption(fieldId: string, categoryOptionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryOption> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getCategoryOption(fieldId, categoryOptionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves categories for a field
         * @param {string} fieldId Field id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryOptionsForField(fieldId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryOptions> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getCategoryOptionsForField(fieldId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a single category
         * @param {string} fieldId Field id
         * @param {string} categoryOptionId Category Option id
         * @param {CategoryOption} body JSON Patch operations to update value field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategoryOption(fieldId: string, categoryOptionId: string, body: CategoryOption, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryOption> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).updateCategoryOption(fieldId, categoryOptionId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Creates a new category
         * @param {CategoryOption} body Category option to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategoryOption(body: CategoryOption, options?: any) {
            return DefaultApiFp(configuration).createCategoryOption(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new category options
         * @param {CategoryOptions} body Category options to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategoryOptions(body: CategoryOptions, options?: any) {
            return DefaultApiFp(configuration).createCategoryOptions(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a single category option
         * @param {string} fieldId Field id
         * @param {string} categoryOptionId Category Option ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryOption(fieldId: string, categoryOptionId: string, options?: any) {
            return DefaultApiFp(configuration).deleteCategoryOption(fieldId, categoryOptionId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves a category
         * @param {string} fieldId Field id
         * @param {string} categoryOptionId Category Option id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryOption(fieldId: string, categoryOptionId: string, options?: any) {
            return DefaultApiFp(configuration).getCategoryOption(fieldId, categoryOptionId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves categories for a field
         * @param {string} fieldId Field id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryOptionsForField(fieldId: string, options?: any) {
            return DefaultApiFp(configuration).getCategoryOptionsForField(fieldId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a single category
         * @param {string} fieldId Field id
         * @param {string} categoryOptionId Category Option id
         * @param {CategoryOption} body JSON Patch operations to update value field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategoryOption(fieldId: string, categoryOptionId: string, body: CategoryOption, options?: any) {
            return DefaultApiFp(configuration).updateCategoryOption(fieldId, categoryOptionId, body, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new category
     * @param {CategoryOption} body Category option to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createCategoryOption(body: CategoryOption, options?: any) {
        return DefaultApiFp(this.configuration).createCategoryOption(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new category options
     * @param {CategoryOptions} body Category options to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createCategoryOptions(body: CategoryOptions, options?: any) {
        return DefaultApiFp(this.configuration).createCategoryOptions(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a single category option
     * @param {string} fieldId Field id
     * @param {string} categoryOptionId Category Option ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteCategoryOption(fieldId: string, categoryOptionId: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteCategoryOption(fieldId, categoryOptionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves a category
     * @param {string} fieldId Field id
     * @param {string} categoryOptionId Category Option id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCategoryOption(fieldId: string, categoryOptionId: string, options?: any) {
        return DefaultApiFp(this.configuration).getCategoryOption(fieldId, categoryOptionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves categories for a field
     * @param {string} fieldId Field id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCategoryOptionsForField(fieldId: string, options?: any) {
        return DefaultApiFp(this.configuration).getCategoryOptionsForField(fieldId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a single category
     * @param {string} fieldId Field id
     * @param {string} categoryOptionId Category Option id
     * @param {CategoryOption} body JSON Patch operations to update value field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateCategoryOption(fieldId: string, categoryOptionId: string, body: CategoryOption, options?: any) {
        return DefaultApiFp(this.configuration).updateCategoryOption(fieldId, categoryOptionId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * FieldsApi - fetch parameter creator
 * @export
 */
export const FieldsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new field in a portfolio.
         * @param {Field} body Field to create
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createField(body: Field, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createField.');
            }
            const localVarPath = `/fields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Field" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new fields in a portfolio.
         * @param {Array<Field>} fields Field to create
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFields(fields: Array<Field>, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fields' is not null or undefined
            if (fields === null || fields === undefined) {
                throw new RequiredError('fields','Required parameter fields was null or undefined when calling createFields.');
            }
            const localVarPath = `/fields/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Field&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(fields || {}) : (fields || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a field. Also deletes the values for every project.
         * @param {string} id Field id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteField(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteField.');
            }
            const localVarPath = `/fields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a field.
         * @param {string} id Field id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getField(id: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getField.');
            }
            const localVarPath = `/fields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves fields for a portfolio.
         * @param {string} portfolioId Portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldsForPortfolio(portfolioId: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getFieldsForPortfolio.');
            }
            const localVarPath = `/fields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set idea form fields for a portfolio.
         * @param {IdeaFormFieldRequest} body Idea form field request
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setIdeaFormFields(body: IdeaFormFieldRequest, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setIdeaFormFields.');
            }
            const localVarPath = `/fields/ideaForm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IdeaFormFieldRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a field utilizing JSON Patch Operations. If the update logic makes changes to other fields, all updated fields will be returned in the response. 
         * @param {string} id Field id
         * @param {Operations} body JSON Patch Operations to update field.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateField(id: string, body: Operations, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateField.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateField.');
            }
            const localVarPath = `/fields/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Operations" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update fields associated with a portfolio.
         * @param {Array<PatchItem>} body JSON Patch Operations to update multiple fields.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFields(body: Array<PatchItem>, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateFields.');
            }
            const localVarPath = `/fields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;PatchItem&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FieldsApi - functional programming interface
 * @export
 */
export const FieldsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new field in a portfolio.
         * @param {Field} body Field to create
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createField(body: Field, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Field>> {
            const localVarFetchArgs = FieldsApiFetchParamCreator(configuration).createField(body, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new fields in a portfolio.
         * @param {Array<Field>} fields Field to create
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFields(fields: Array<Field>, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Field>> {
            const localVarFetchArgs = FieldsApiFetchParamCreator(configuration).createFields(fields, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a field. Also deletes the values for every project.
         * @param {string} id Field id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteField(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FieldsApiFetchParamCreator(configuration).deleteField(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves a field.
         * @param {string} id Field id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getField(id: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Field> {
            const localVarFetchArgs = FieldsApiFetchParamCreator(configuration).getField(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves fields for a portfolio.
         * @param {string} portfolioId Portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldsForPortfolio(portfolioId: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Fields> {
            const localVarFetchArgs = FieldsApiFetchParamCreator(configuration).getFieldsForPortfolio(portfolioId, expand, limit, offset, orderBy, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set idea form fields for a portfolio.
         * @param {IdeaFormFieldRequest} body Idea form field request
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setIdeaFormFields(body: IdeaFormFieldRequest, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Field>> {
            const localVarFetchArgs = FieldsApiFetchParamCreator(configuration).setIdeaFormFields(body, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a field utilizing JSON Patch Operations. If the update logic makes changes to other fields, all updated fields will be returned in the response. 
         * @param {string} id Field id
         * @param {Operations} body JSON Patch Operations to update field.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateField(id: string, body: Operations, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Field>> {
            const localVarFetchArgs = FieldsApiFetchParamCreator(configuration).updateField(id, body, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update fields associated with a portfolio.
         * @param {Array<PatchItem>} body JSON Patch Operations to update multiple fields.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFields(body: Array<PatchItem>, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Field>> {
            const localVarFetchArgs = FieldsApiFetchParamCreator(configuration).updateFields(body, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FieldsApi - factory interface
 * @export
 */
export const FieldsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Creates a new field in a portfolio.
         * @param {Field} body Field to create
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createField(body: Field, expand?: string, options?: any) {
            return FieldsApiFp(configuration).createField(body, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new fields in a portfolio.
         * @param {Array<Field>} fields Field to create
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFields(fields: Array<Field>, expand?: string, options?: any) {
            return FieldsApiFp(configuration).createFields(fields, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a field. Also deletes the values for every project.
         * @param {string} id Field id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteField(id: string, options?: any) {
            return FieldsApiFp(configuration).deleteField(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves a field.
         * @param {string} id Field id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getField(id: string, expand?: string, options?: any) {
            return FieldsApiFp(configuration).getField(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves fields for a portfolio.
         * @param {string} portfolioId Portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldsForPortfolio(portfolioId: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
            return FieldsApiFp(configuration).getFieldsForPortfolio(portfolioId, expand, limit, offset, orderBy, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set idea form fields for a portfolio.
         * @param {IdeaFormFieldRequest} body Idea form field request
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setIdeaFormFields(body: IdeaFormFieldRequest, expand?: string, options?: any) {
            return FieldsApiFp(configuration).setIdeaFormFields(body, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a field utilizing JSON Patch Operations. If the update logic makes changes to other fields, all updated fields will be returned in the response. 
         * @param {string} id Field id
         * @param {Operations} body JSON Patch Operations to update field.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateField(id: string, body: Operations, expand?: string, options?: any) {
            return FieldsApiFp(configuration).updateField(id, body, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update fields associated with a portfolio.
         * @param {Array<PatchItem>} body JSON Patch Operations to update multiple fields.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFields(body: Array<PatchItem>, expand?: string, options?: any) {
            return FieldsApiFp(configuration).updateFields(body, expand, options)(fetch, basePath);
        },
    };
};

/**
 * FieldsApi - object-oriented interface
 * @export
 * @class FieldsApi
 * @extends {BaseAPI}
 */
export class FieldsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new field in a portfolio.
     * @param {Field} body Field to create
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public createField(body: Field, expand?: string, options?: any) {
        return FieldsApiFp(this.configuration).createField(body, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new fields in a portfolio.
     * @param {Array<Field>} fields Field to create
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public createFields(fields: Array<Field>, expand?: string, options?: any) {
        return FieldsApiFp(this.configuration).createFields(fields, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a field. Also deletes the values for every project.
     * @param {string} id Field id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public deleteField(id: string, options?: any) {
        return FieldsApiFp(this.configuration).deleteField(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves a field.
     * @param {string} id Field id
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public getField(id: string, expand?: string, options?: any) {
        return FieldsApiFp(this.configuration).getField(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves fields for a portfolio.
     * @param {string} portfolioId Portfolio id
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public getFieldsForPortfolio(portfolioId: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
        return FieldsApiFp(this.configuration).getFieldsForPortfolio(portfolioId, expand, limit, offset, orderBy, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set idea form fields for a portfolio.
     * @param {IdeaFormFieldRequest} body Idea form field request
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public setIdeaFormFields(body: IdeaFormFieldRequest, expand?: string, options?: any) {
        return FieldsApiFp(this.configuration).setIdeaFormFields(body, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a field utilizing JSON Patch Operations. If the update logic makes changes to other fields, all updated fields will be returned in the response. 
     * @param {string} id Field id
     * @param {Operations} body JSON Patch Operations to update field.
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public updateField(id: string, body: Operations, expand?: string, options?: any) {
        return FieldsApiFp(this.configuration).updateField(id, body, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update fields associated with a portfolio.
     * @param {Array<PatchItem>} body JSON Patch Operations to update multiple fields.
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public updateFields(body: Array<PatchItem>, expand?: string, options?: any) {
        return FieldsApiFp(this.configuration).updateFields(body, expand, options)(this.fetch, this.basePath);
    }

}

/**
 * GoalsApi - fetch parameter creator
 * @export
 */
export const GoalsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Goals by portfolio id
         * @param {string} portfolioId Portfolio id
         * @param {number} [offset] Pagination offset
         * @param {number} [limit] Pagination limit
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsForPortfolio(portfolioId: string, offset?: number, limit?: number, orderBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getGoalsForPortfolio.');
            }
            const localVarPath = `/goals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Goals for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {Array<Goal>} goals Goals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsForPortfolio(portfolioId: string, goals: Array<Goal>, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling updateGoalsForPortfolio.');
            }
            // verify required parameter 'goals' is not null or undefined
            if (goals === null || goals === undefined) {
                throw new RequiredError('goals','Required parameter goals was null or undefined when calling updateGoalsForPortfolio.');
            }
            const localVarPath = `/goals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/merge-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Goal&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(goals || {}) : (goals || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoalsApi - functional programming interface
 * @export
 */
export const GoalsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Goals by portfolio id
         * @param {string} portfolioId Portfolio id
         * @param {number} [offset] Pagination offset
         * @param {number} [limit] Pagination limit
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsForPortfolio(portfolioId: string, offset?: number, limit?: number, orderBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Goals> {
            const localVarFetchArgs = GoalsApiFetchParamCreator(configuration).getGoalsForPortfolio(portfolioId, offset, limit, orderBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates Goals for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {Array<Goal>} goals Goals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsForPortfolio(portfolioId: string, goals: Array<Goal>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Goal>> {
            const localVarFetchArgs = GoalsApiFetchParamCreator(configuration).updateGoalsForPortfolio(portfolioId, goals, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GoalsApi - factory interface
 * @export
 */
export const GoalsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get Goals by portfolio id
         * @param {string} portfolioId Portfolio id
         * @param {number} [offset] Pagination offset
         * @param {number} [limit] Pagination limit
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoalsForPortfolio(portfolioId: string, offset?: number, limit?: number, orderBy?: string, options?: any) {
            return GoalsApiFp(configuration).getGoalsForPortfolio(portfolioId, offset, limit, orderBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates Goals for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {Array<Goal>} goals Goals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalsForPortfolio(portfolioId: string, goals: Array<Goal>, options?: any) {
            return GoalsApiFp(configuration).updateGoalsForPortfolio(portfolioId, goals, options)(fetch, basePath);
        },
    };
};

/**
 * GoalsApi - object-oriented interface
 * @export
 * @class GoalsApi
 * @extends {BaseAPI}
 */
export class GoalsApi extends BaseAPI {
    /**
     * 
     * @summary Get Goals by portfolio id
     * @param {string} portfolioId Portfolio id
     * @param {number} [offset] Pagination offset
     * @param {number} [limit] Pagination limit
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public getGoalsForPortfolio(portfolioId: string, offset?: number, limit?: number, orderBy?: string, options?: any) {
        return GoalsApiFp(this.configuration).getGoalsForPortfolio(portfolioId, offset, limit, orderBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates Goals for portfolio
     * @param {string} portfolioId Portfolio id
     * @param {Array<Goal>} goals Goals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public updateGoalsForPortfolio(portfolioId: string, goals: Array<Goal>, options?: any) {
        return GoalsApiFp(this.configuration).updateGoalsForPortfolio(portfolioId, goals, options)(this.fetch, this.basePath);
    }

}

/**
 * GroupsApi - fetch parameter creator
 * @export
 */
export const GroupsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new group. System Administrator operation.
         * @param {Group} group Group to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: Group, options: any = {}): FetchArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling createGroup.');
            }
            const localVarPath = `/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Group" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(group || {}) : (group || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export Group
         * @param {any} id Group id
         * @param {any} [exportType] export type (GROUP)
         * @param {any} [exportFormat] export format type (XLSX)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportGroup(id: any, exportType?: any, exportFormat?: any, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling exportGroup.');
            }
            const localVarPath = `/groups/{id}/export`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (exportType !== undefined) {
                localVarQueryParameter['exportType'] = exportType;
            }

            if (exportFormat !== undefined) {
                localVarQueryParameter['exportFormat'] = exportFormat;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get activities for group. System Administator operation.
         * @param {string} id Group id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivitiesForGroup(id: string, limit?: number, offset?: number, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getActivitiesForGroup.');
            }
            const localVarPath = `/groups/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get groups. System Administator operation.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(expand?: string, limit?: number, offset?: number, match?: string, options: any = {}): FetchArgs {
            const localVarPath = `/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get portfolios for group. Group administrator operation.
         * @param {string} id Group id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfoliosForGroup(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPortfoliosForGroup.');
            }
            const localVarPath = `/groups/{id}/portfolios`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get users for group. System Administator operation.
         * @param {string} id Group id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForGroup(id: string, expand?: string, limit?: number, offset?: number, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUsersForGroup.');
            }
            const localVarPath = `/groups/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provision a group (tenant).
         * @param {ProvisionGroupRequest} provisionGroupRequest Provision a Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionGroup(provisionGroupRequest: ProvisionGroupRequest, options: any = {}): FetchArgs {
            // verify required parameter 'provisionGroupRequest' is not null or undefined
            if (provisionGroupRequest === null || provisionGroupRequest === undefined) {
                throw new RequiredError('provisionGroupRequest','Required parameter provisionGroupRequest was null or undefined when calling provisionGroup.');
            }
            const localVarPath = `/groups/provision`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProvisionGroupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(provisionGroupRequest || {}) : (provisionGroupRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new group. System Administrator operation.
         * @param {Group} group Group to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: Group, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Group> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).createGroup(group, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Export Group
         * @param {any} id Group id
         * @param {any} [exportType] export type (GROUP)
         * @param {any} [exportFormat] export format type (XLSX)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportGroup(id: any, exportType?: any, exportFormat?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).exportGroup(id, exportType, exportFormat, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get activities for group. System Administator operation.
         * @param {string} id Group id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivitiesForGroup(id: string, limit?: number, offset?: number, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Activities> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).getActivitiesForGroup(id, limit, offset, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get groups. System Administator operation.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(expand?: string, limit?: number, offset?: number, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Groups> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).getGroups(expand, limit, offset, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get portfolios for group. Group administrator operation.
         * @param {string} id Group id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfoliosForGroup(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Portfolios> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).getPortfoliosForGroup(id, expand, limit, offset, orderBy, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get users for group. System Administator operation.
         * @param {string} id Group id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForGroup(id: string, expand?: string, limit?: number, offset?: number, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Users> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).getUsersForGroup(id, expand, limit, offset, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Provision a group (tenant).
         * @param {ProvisionGroupRequest} provisionGroupRequest Provision a Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionGroup(provisionGroupRequest: ProvisionGroupRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProvisionGroupResponse> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).provisionGroup(provisionGroupRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Creates a new group. System Administrator operation.
         * @param {Group} group Group to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: Group, options?: any) {
            return GroupsApiFp(configuration).createGroup(group, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Export Group
         * @param {any} id Group id
         * @param {any} [exportType] export type (GROUP)
         * @param {any} [exportFormat] export format type (XLSX)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportGroup(id: any, exportType?: any, exportFormat?: any, options?: any) {
            return GroupsApiFp(configuration).exportGroup(id, exportType, exportFormat, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get activities for group. System Administator operation.
         * @param {string} id Group id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivitiesForGroup(id: string, limit?: number, offset?: number, match?: string, options?: any) {
            return GroupsApiFp(configuration).getActivitiesForGroup(id, limit, offset, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get groups. System Administator operation.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(expand?: string, limit?: number, offset?: number, match?: string, options?: any) {
            return GroupsApiFp(configuration).getGroups(expand, limit, offset, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get portfolios for group. Group administrator operation.
         * @param {string} id Group id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfoliosForGroup(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
            return GroupsApiFp(configuration).getPortfoliosForGroup(id, expand, limit, offset, orderBy, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get users for group. System Administator operation.
         * @param {string} id Group id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForGroup(id: string, expand?: string, limit?: number, offset?: number, match?: string, options?: any) {
            return GroupsApiFp(configuration).getUsersForGroup(id, expand, limit, offset, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Provision a group (tenant).
         * @param {ProvisionGroupRequest} provisionGroupRequest Provision a Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionGroup(provisionGroupRequest: ProvisionGroupRequest, options?: any) {
            return GroupsApiFp(configuration).provisionGroup(provisionGroupRequest, options)(fetch, basePath);
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new group. System Administrator operation.
     * @param {Group} group Group to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(group: Group, options?: any) {
        return GroupsApiFp(this.configuration).createGroup(group, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Export Group
     * @param {any} id Group id
     * @param {any} [exportType] export type (GROUP)
     * @param {any} [exportFormat] export format type (XLSX)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public exportGroup(id: any, exportType?: any, exportFormat?: any, options?: any) {
        return GroupsApiFp(this.configuration).exportGroup(id, exportType, exportFormat, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get activities for group. System Administator operation.
     * @param {string} id Group id
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getActivitiesForGroup(id: string, limit?: number, offset?: number, match?: string, options?: any) {
        return GroupsApiFp(this.configuration).getActivitiesForGroup(id, limit, offset, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get groups. System Administator operation.
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroups(expand?: string, limit?: number, offset?: number, match?: string, options?: any) {
        return GroupsApiFp(this.configuration).getGroups(expand, limit, offset, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get portfolios for group. Group administrator operation.
     * @param {string} id Group id
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getPortfoliosForGroup(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
        return GroupsApiFp(this.configuration).getPortfoliosForGroup(id, expand, limit, offset, orderBy, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get users for group. System Administator operation.
     * @param {string} id Group id
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getUsersForGroup(id: string, expand?: string, limit?: number, offset?: number, match?: string, options?: any) {
        return GroupsApiFp(this.configuration).getUsersForGroup(id, expand, limit, offset, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Provision a group (tenant).
     * @param {ProvisionGroupRequest} provisionGroupRequest Provision a Group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public provisionGroup(provisionGroupRequest: ProvisionGroupRequest, options?: any) {
        return GroupsApiFp(this.configuration).provisionGroup(provisionGroupRequest, options)(this.fetch, this.basePath);
    }

}

/**
 * InfoApi - fetch parameter creator
 * @export
 */
export const InfoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get service build information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options: any = {}): FetchArgs {
            const localVarPath = `/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 * @export
 */
export const InfoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get service build information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ServiceInfoDetails> {
            const localVarFetchArgs = InfoApiFetchParamCreator(configuration).getInfo(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InfoApi - factory interface
 * @export
 */
export const InfoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get service build information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any) {
            return InfoApiFp(configuration).getInfo(options)(fetch, basePath);
        },
    };
};

/**
 * InfoApi - object-oriented interface
 * @export
 * @class InfoApi
 * @extends {BaseAPI}
 */
export class InfoApi extends BaseAPI {
    /**
     * 
     * @summary Get service build information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public getInfo(options?: any) {
        return InfoApiFp(this.configuration).getInfo(options)(this.fetch, this.basePath);
    }

}

/**
 * JiraApi - fetch parameter creator
 * @export
 */
export const JiraApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a comment in Decision Lens based on a Jira comment.
         * @param {string} id jira instance id
         * @param {JiraComment} body Comment to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCommentFromJira(id: string, body: JiraComment, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createCommentFromJira.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCommentFromJira.');
            }
            const localVarPath = `/jira/instance/{id}/comment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JiraComment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates jira field mapping.
         * @param {string} id jira instance id
         * @param {JiraFieldMapping} body Field mapping to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJiraFieldMapping(id: string, body: JiraFieldMapping, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createJiraFieldMapping.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createJiraFieldMapping.');
            }
            const localVarPath = `/jira/instance/{id}/mapping`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JiraFieldMapping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates jira instance.
         * @param {JiraInstance} body Jira instance to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJiraInstance(body: JiraInstance, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createJiraInstance.');
            }
            const localVarPath = `/jira/instance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"JiraInstance" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete jira field mapping
         * @param {string} id jira field mapping id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFieldMapping(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFieldMapping.');
            }
            const localVarPath = `/jira/instance/{id}/mapping/{mappingId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete jira instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJiraInstance(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteJiraInstance.');
            }
            const localVarPath = `/jira/instance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable Jira Instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableJiraInstance(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling disableJiraInstance.');
            }
            const localVarPath = `/jira/instance/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable Jira Instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableJiraInstance(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling enableJiraInstance.');
            }
            const localVarPath = `/jira/instance/{id}/enable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Jira field mapping
         * @param {string} id jira integration instance id
         * @param {string} mappingId jira field mapping id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldMapping(id: string, mappingId: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFieldMapping.');
            }
            // verify required parameter 'mappingId' is not null or undefined
            if (mappingId === null || mappingId === undefined) {
                throw new RequiredError('mappingId','Required parameter mappingId was null or undefined when calling getFieldMapping.');
            }
            const localVarPath = `/jira/instance/{id}/mapping/{mappingId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"mappingId"}}`, encodeURIComponent(String(mappingId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Jira field mappings for an instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldMappings(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFieldMappings.');
            }
            const localVarPath = `/jira/instance/{id}/mappings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Jira Instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJiraInstance(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getJiraInstance.');
            }
            const localVarPath = `/jira/instance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return mapped Decision Lens project for a Jira epic
         * @param {string} id Jira integration instance id
         * @param {string} epicId Epic key from Jira
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMappedProjectForEpic(id: string, epicId: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getMappedProjectForEpic.');
            }
            // verify required parameter 'epicId' is not null or undefined
            if (epicId === null || epicId === undefined) {
                throw new RequiredError('epicId','Required parameter epicId was null or undefined when calling getMappedProjectForEpic.');
            }
            const localVarPath = `/jira/instance/{id}/mappedProject/{epicId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"epicId"}}`, encodeURIComponent(String(epicId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run synchronization process for Jira Instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSyncForJiraInstance(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling startSyncForJiraInstance.');
            }
            const localVarPath = `/jira/instance/{id}/sync`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JiraApi - functional programming interface
 * @export
 */
export const JiraApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a comment in Decision Lens based on a Jira comment.
         * @param {string} id jira instance id
         * @param {JiraComment} body Comment to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCommentFromJira(id: string, body: JiraComment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = JiraApiFetchParamCreator(configuration).createCommentFromJira(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates jira field mapping.
         * @param {string} id jira instance id
         * @param {JiraFieldMapping} body Field mapping to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJiraFieldMapping(id: string, body: JiraFieldMapping, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JiraFieldMapping> {
            const localVarFetchArgs = JiraApiFetchParamCreator(configuration).createJiraFieldMapping(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates jira instance.
         * @param {JiraInstance} body Jira instance to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJiraInstance(body: JiraInstance, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JiraInstance> {
            const localVarFetchArgs = JiraApiFetchParamCreator(configuration).createJiraInstance(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete jira field mapping
         * @param {string} id jira field mapping id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFieldMapping(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = JiraApiFetchParamCreator(configuration).deleteFieldMapping(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete jira instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJiraInstance(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = JiraApiFetchParamCreator(configuration).deleteJiraInstance(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Disable Jira Instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableJiraInstance(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = JiraApiFetchParamCreator(configuration).disableJiraInstance(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enable Jira Instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableJiraInstance(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = JiraApiFetchParamCreator(configuration).enableJiraInstance(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Jira field mapping
         * @param {string} id jira integration instance id
         * @param {string} mappingId jira field mapping id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldMapping(id: string, mappingId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JiraFieldMapping> {
            const localVarFetchArgs = JiraApiFetchParamCreator(configuration).getFieldMapping(id, mappingId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Jira field mappings for an instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldMappings(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JiraFieldMappings> {
            const localVarFetchArgs = JiraApiFetchParamCreator(configuration).getFieldMappings(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Jira Instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJiraInstance(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<JiraInstance> {
            const localVarFetchArgs = JiraApiFetchParamCreator(configuration).getJiraInstance(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return mapped Decision Lens project for a Jira epic
         * @param {string} id Jira integration instance id
         * @param {string} epicId Epic key from Jira
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMappedProjectForEpic(id: string, epicId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MappedProject> {
            const localVarFetchArgs = JiraApiFetchParamCreator(configuration).getMappedProjectForEpic(id, epicId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Run synchronization process for Jira Instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSyncForJiraInstance(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = JiraApiFetchParamCreator(configuration).startSyncForJiraInstance(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * JiraApi - factory interface
 * @export
 */
export const JiraApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a comment in Decision Lens based on a Jira comment.
         * @param {string} id jira instance id
         * @param {JiraComment} body Comment to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCommentFromJira(id: string, body: JiraComment, options?: any) {
            return JiraApiFp(configuration).createCommentFromJira(id, body, options)(fetch, basePath);
        },
        /**
         * Creates jira field mapping.
         * @param {string} id jira instance id
         * @param {JiraFieldMapping} body Field mapping to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJiraFieldMapping(id: string, body: JiraFieldMapping, options?: any) {
            return JiraApiFp(configuration).createJiraFieldMapping(id, body, options)(fetch, basePath);
        },
        /**
         * Creates jira instance.
         * @param {JiraInstance} body Jira instance to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJiraInstance(body: JiraInstance, options?: any) {
            return JiraApiFp(configuration).createJiraInstance(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete jira field mapping
         * @param {string} id jira field mapping id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFieldMapping(id: string, options?: any) {
            return JiraApiFp(configuration).deleteFieldMapping(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete jira instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJiraInstance(id: string, options?: any) {
            return JiraApiFp(configuration).deleteJiraInstance(id, options)(fetch, basePath);
        },
        /**
         * Disable Jira Instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableJiraInstance(id: string, options?: any) {
            return JiraApiFp(configuration).disableJiraInstance(id, options)(fetch, basePath);
        },
        /**
         * Enable Jira Instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableJiraInstance(id: string, options?: any) {
            return JiraApiFp(configuration).enableJiraInstance(id, options)(fetch, basePath);
        },
        /**
         * Get Jira field mapping
         * @param {string} id jira integration instance id
         * @param {string} mappingId jira field mapping id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldMapping(id: string, mappingId: string, options?: any) {
            return JiraApiFp(configuration).getFieldMapping(id, mappingId, options)(fetch, basePath);
        },
        /**
         * Get Jira field mappings for an instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldMappings(id: string, options?: any) {
            return JiraApiFp(configuration).getFieldMappings(id, options)(fetch, basePath);
        },
        /**
         * Get Jira Instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJiraInstance(id: string, options?: any) {
            return JiraApiFp(configuration).getJiraInstance(id, options)(fetch, basePath);
        },
        /**
         * Return mapped Decision Lens project for a Jira epic
         * @param {string} id Jira integration instance id
         * @param {string} epicId Epic key from Jira
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMappedProjectForEpic(id: string, epicId: string, options?: any) {
            return JiraApiFp(configuration).getMappedProjectForEpic(id, epicId, options)(fetch, basePath);
        },
        /**
         * Run synchronization process for Jira Instance
         * @param {string} id jira instance id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSyncForJiraInstance(id: string, options?: any) {
            return JiraApiFp(configuration).startSyncForJiraInstance(id, options)(fetch, basePath);
        },
    };
};

/**
 * JiraApi - object-oriented interface
 * @export
 * @class JiraApi
 * @extends {BaseAPI}
 */
export class JiraApi extends BaseAPI {
    /**
     * Creates a comment in Decision Lens based on a Jira comment.
     * @param {string} id jira instance id
     * @param {JiraComment} body Comment to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public createCommentFromJira(id: string, body: JiraComment, options?: any) {
        return JiraApiFp(this.configuration).createCommentFromJira(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Creates jira field mapping.
     * @param {string} id jira instance id
     * @param {JiraFieldMapping} body Field mapping to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public createJiraFieldMapping(id: string, body: JiraFieldMapping, options?: any) {
        return JiraApiFp(this.configuration).createJiraFieldMapping(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Creates jira instance.
     * @param {JiraInstance} body Jira instance to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public createJiraInstance(body: JiraInstance, options?: any) {
        return JiraApiFp(this.configuration).createJiraInstance(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete jira field mapping
     * @param {string} id jira field mapping id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public deleteFieldMapping(id: string, options?: any) {
        return JiraApiFp(this.configuration).deleteFieldMapping(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete jira instance
     * @param {string} id jira instance id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public deleteJiraInstance(id: string, options?: any) {
        return JiraApiFp(this.configuration).deleteJiraInstance(id, options)(this.fetch, this.basePath);
    }

    /**
     * Disable Jira Instance
     * @param {string} id jira instance id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public disableJiraInstance(id: string, options?: any) {
        return JiraApiFp(this.configuration).disableJiraInstance(id, options)(this.fetch, this.basePath);
    }

    /**
     * Enable Jira Instance
     * @param {string} id jira instance id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public enableJiraInstance(id: string, options?: any) {
        return JiraApiFp(this.configuration).enableJiraInstance(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get Jira field mapping
     * @param {string} id jira integration instance id
     * @param {string} mappingId jira field mapping id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public getFieldMapping(id: string, mappingId: string, options?: any) {
        return JiraApiFp(this.configuration).getFieldMapping(id, mappingId, options)(this.fetch, this.basePath);
    }

    /**
     * Get Jira field mappings for an instance
     * @param {string} id jira instance id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public getFieldMappings(id: string, options?: any) {
        return JiraApiFp(this.configuration).getFieldMappings(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get Jira Instance
     * @param {string} id jira instance id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public getJiraInstance(id: string, options?: any) {
        return JiraApiFp(this.configuration).getJiraInstance(id, options)(this.fetch, this.basePath);
    }

    /**
     * Return mapped Decision Lens project for a Jira epic
     * @param {string} id Jira integration instance id
     * @param {string} epicId Epic key from Jira
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public getMappedProjectForEpic(id: string, epicId: string, options?: any) {
        return JiraApiFp(this.configuration).getMappedProjectForEpic(id, epicId, options)(this.fetch, this.basePath);
    }

    /**
     * Run synchronization process for Jira Instance
     * @param {string} id jira instance id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JiraApi
     */
    public startSyncForJiraInstance(id: string, options?: any) {
        return JiraApiFp(this.configuration).startSyncForJiraInstance(id, options)(this.fetch, this.basePath);
    }

}

/**
 * LogoutApi - fetch parameter creator
 * @export
 */
export const LogoutApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Logout
         * @param {string} targetUrl Target url to redirect after login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(targetUrl: string, options: any = {}): FetchArgs {
            // verify required parameter 'targetUrl' is not null or undefined
            if (targetUrl === null || targetUrl === undefined) {
                throw new RequiredError('targetUrl','Required parameter targetUrl was null or undefined when calling logout.');
            }
            const localVarPath = `/oauth/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (targetUrl !== undefined) {
                localVarQueryParameter['targetUrl'] = targetUrl;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogoutApi - functional programming interface
 * @export
 */
export const LogoutApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Logout
         * @param {string} targetUrl Target url to redirect after login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(targetUrl: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LogoutApiFetchParamCreator(configuration).logout(targetUrl, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LogoutApi - factory interface
 * @export
 */
export const LogoutApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Logout
         * @param {string} targetUrl Target url to redirect after login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(targetUrl: string, options?: any) {
            return LogoutApiFp(configuration).logout(targetUrl, options)(fetch, basePath);
        },
    };
};

/**
 * LogoutApi - object-oriented interface
 * @export
 * @class LogoutApi
 * @extends {BaseAPI}
 */
export class LogoutApi extends BaseAPI {
    /**
     * 
     * @summary Logout
     * @param {string} targetUrl Target url to redirect after login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogoutApi
     */
    public logout(targetUrl: string, options?: any) {
        return LogoutApiFp(this.configuration).logout(targetUrl, options)(this.fetch, this.basePath);
    }

}

/**
 * MailApi - fetch parameter creator
 * @export
 */
export const MailApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send mail
         * @param {Mail} mail mail request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMail(mail: Mail, options: any = {}): FetchArgs {
            // verify required parameter 'mail' is not null or undefined
            if (mail === null || mail === undefined) {
                throw new RequiredError('mail','Required parameter mail was null or undefined when calling sendMail.');
            }
            const localVarPath = `/mail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Mail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(mail || {}) : (mail || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send registration mail
         * @param {Mail} mail mail request
         * @param {string} [accessToken] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRegistrationMail(mail: Mail, accessToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'mail' is not null or undefined
            if (mail === null || mail === undefined) {
                throw new RequiredError('mail','Required parameter mail was null or undefined when calling sendRegistrationMail.');
            }
            const localVarPath = `/registrationMail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (accessToken !== undefined) {
                localVarQueryParameter['accessToken'] = accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Mail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(mail || {}) : (mail || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MailApi - functional programming interface
 * @export
 */
export const MailApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send mail
         * @param {Mail} mail mail request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMail(mail: Mail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MailApiFetchParamCreator(configuration).sendMail(mail, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Send registration mail
         * @param {Mail} mail mail request
         * @param {string} [accessToken] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRegistrationMail(mail: Mail, accessToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MailApiFetchParamCreator(configuration).sendRegistrationMail(mail, accessToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MailApi - factory interface
 * @export
 */
export const MailApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Send mail
         * @param {Mail} mail mail request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMail(mail: Mail, options?: any) {
            return MailApiFp(configuration).sendMail(mail, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send registration mail
         * @param {Mail} mail mail request
         * @param {string} [accessToken] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRegistrationMail(mail: Mail, accessToken?: string, options?: any) {
            return MailApiFp(configuration).sendRegistrationMail(mail, accessToken, options)(fetch, basePath);
        },
    };
};

/**
 * MailApi - object-oriented interface
 * @export
 * @class MailApi
 * @extends {BaseAPI}
 */
export class MailApi extends BaseAPI {
    /**
     * 
     * @summary Send mail
     * @param {Mail} mail mail request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public sendMail(mail: Mail, options?: any) {
        return MailApiFp(this.configuration).sendMail(mail, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Send registration mail
     * @param {Mail} mail mail request
     * @param {string} [accessToken] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public sendRegistrationMail(mail: Mail, accessToken?: string, options?: any) {
        return MailApiFp(this.configuration).sendRegistrationMail(mail, accessToken, options)(this.fetch, this.basePath);
    }

}

/**
 * MappingsApi - fetch parameter creator
 * @export
 */
export const MappingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Maps the fields in the spreadsheet to appropriate buckets
         * @summary Accepts upload of spreadsheet and converts data into mappings.
         * @param {any} file maybe put supported file types here?
         * @param {boolean} [columnsOnly] return columns only the case for cost import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spreadsheetToMappings(file: any, columnsOnly?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling spreadsheetToMappings.');
            }
            const localVarPath = `/mappings/spreadsheet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (columnsOnly !== undefined) {
                localVarQueryParameter['columnsOnly'] = columnsOnly;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update mapping
         * @param {string} id Mapping id
         * @param {Operations} body JSON Patch Operations to update mapping.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMapping(id: string, body: Operations, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateMapping.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateMapping.');
            }
            const localVarPath = `/mappings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Operations" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MappingsApi - functional programming interface
 * @export
 */
export const MappingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Maps the fields in the spreadsheet to appropriate buckets
         * @summary Accepts upload of spreadsheet and converts data into mappings.
         * @param {any} file maybe put supported file types here?
         * @param {boolean} [columnsOnly] return columns only the case for cost import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spreadsheetToMappings(file: any, columnsOnly?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Mappings> {
            const localVarFetchArgs = MappingsApiFetchParamCreator(configuration).spreadsheetToMappings(file, columnsOnly, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update mapping
         * @param {string} id Mapping id
         * @param {Operations} body JSON Patch Operations to update mapping.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMapping(id: string, body: Operations, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Mapping>> {
            const localVarFetchArgs = MappingsApiFetchParamCreator(configuration).updateMapping(id, body, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MappingsApi - factory interface
 * @export
 */
export const MappingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Maps the fields in the spreadsheet to appropriate buckets
         * @summary Accepts upload of spreadsheet and converts data into mappings.
         * @param {any} file maybe put supported file types here?
         * @param {boolean} [columnsOnly] return columns only the case for cost import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spreadsheetToMappings(file: any, columnsOnly?: boolean, options?: any) {
            return MappingsApiFp(configuration).spreadsheetToMappings(file, columnsOnly, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update mapping
         * @param {string} id Mapping id
         * @param {Operations} body JSON Patch Operations to update mapping.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMapping(id: string, body: Operations, expand?: string, options?: any) {
            return MappingsApiFp(configuration).updateMapping(id, body, expand, options)(fetch, basePath);
        },
    };
};

/**
 * MappingsApi - object-oriented interface
 * @export
 * @class MappingsApi
 * @extends {BaseAPI}
 */
export class MappingsApi extends BaseAPI {
    /**
     * Maps the fields in the spreadsheet to appropriate buckets
     * @summary Accepts upload of spreadsheet and converts data into mappings.
     * @param {any} file maybe put supported file types here?
     * @param {boolean} [columnsOnly] return columns only the case for cost import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MappingsApi
     */
    public spreadsheetToMappings(file: any, columnsOnly?: boolean, options?: any) {
        return MappingsApiFp(this.configuration).spreadsheetToMappings(file, columnsOnly, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update mapping
     * @param {string} id Mapping id
     * @param {Operations} body JSON Patch Operations to update mapping.
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MappingsApi
     */
    public updateMapping(id: string, body: Operations, expand?: string, options?: any) {
        return MappingsApiFp(this.configuration).updateMapping(id, body, expand, options)(this.fetch, this.basePath);
    }

}

/**
 * MessageTokensApi - fetch parameter creator
 * @export
 */
export const MessageTokensApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get message authorization token for a destination
         * @param {any} destinationType Message destination type
         * @param {string} [portfolioId] Portfolio id for PORTFOLIO destination type
         * @param {string} [portfolioPlanId] Portfolio plan id for PORTFOLIOPLAN destination type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageToken(destinationType: any, portfolioId?: string, portfolioPlanId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'destinationType' is not null or undefined
            if (destinationType === null || destinationType === undefined) {
                throw new RequiredError('destinationType','Required parameter destinationType was null or undefined when calling getMessageToken.');
            }
            const localVarPath = `/messageTokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (destinationType !== undefined) {
                localVarQueryParameter['destinationType'] = destinationType;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            if (portfolioPlanId !== undefined) {
                localVarQueryParameter['portfolioPlanId'] = portfolioPlanId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageTokensApi - functional programming interface
 * @export
 */
export const MessageTokensApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get message authorization token for a destination
         * @param {any} destinationType Message destination type
         * @param {string} [portfolioId] Portfolio id for PORTFOLIO destination type
         * @param {string} [portfolioPlanId] Portfolio plan id for PORTFOLIOPLAN destination type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageToken(destinationType: any, portfolioId?: string, portfolioPlanId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MessageToken> {
            const localVarFetchArgs = MessageTokensApiFetchParamCreator(configuration).getMessageToken(destinationType, portfolioId, portfolioPlanId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MessageTokensApi - factory interface
 * @export
 */
export const MessageTokensApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get message authorization token for a destination
         * @param {any} destinationType Message destination type
         * @param {string} [portfolioId] Portfolio id for PORTFOLIO destination type
         * @param {string} [portfolioPlanId] Portfolio plan id for PORTFOLIOPLAN destination type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageToken(destinationType: any, portfolioId?: string, portfolioPlanId?: string, options?: any) {
            return MessageTokensApiFp(configuration).getMessageToken(destinationType, portfolioId, portfolioPlanId, options)(fetch, basePath);
        },
    };
};

/**
 * MessageTokensApi - object-oriented interface
 * @export
 * @class MessageTokensApi
 * @extends {BaseAPI}
 */
export class MessageTokensApi extends BaseAPI {
    /**
     * 
     * @summary Get message authorization token for a destination
     * @param {any} destinationType Message destination type
     * @param {string} [portfolioId] Portfolio id for PORTFOLIO destination type
     * @param {string} [portfolioPlanId] Portfolio plan id for PORTFOLIOPLAN destination type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageTokensApi
     */
    public getMessageToken(destinationType: any, portfolioId?: string, portfolioPlanId?: string, options?: any) {
        return MessageTokensApiFp(this.configuration).getMessageToken(destinationType, portfolioId, portfolioPlanId, options)(this.fetch, this.basePath);
    }

}

/**
 * MessagesApi - fetch parameter creator
 * @export
 */
export const MessagesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send Message(s)
         * @param {Array<Message>} messages 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessages(messages: Array<Message>, options: any = {}): FetchArgs {
            // verify required parameter 'messages' is not null or undefined
            if (messages === null || messages === undefined) {
                throw new RequiredError('messages','Required parameter messages was null or undefined when calling sendMessages.');
            }
            const localVarPath = `/messages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Message&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(messages || {}) : (messages || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send Message(s)
         * @param {Array<Message>} messages 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessages(messages: Array<Message>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).sendMessages(messages, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Send Message(s)
         * @param {Array<Message>} messages 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessages(messages: Array<Message>, options?: any) {
            return MessagesApiFp(configuration).sendMessages(messages, options)(fetch, basePath);
        },
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * 
     * @summary Send Message(s)
     * @param {Array<Message>} messages 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public sendMessages(messages: Array<Message>, options?: any) {
        return MessagesApiFp(this.configuration).sendMessages(messages, options)(this.fetch, this.basePath);
    }

}

/**
 * NotificationsApi - fetch parameter creator
 * @export
 */
export const NotificationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves portfolio notifications log.
         * @param {string} portfolioId Portfolio id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(portfolioId: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getNotifications.');
            }
            const localVarPath = `/notifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reindex notifications. System Administator operation.
         * @param {Array<string>} [domains] List of domains for where notifications need to be reindexed, if not provided reindex will be done for all domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reindexNotifications(domains?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/reindex/notifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (domains) {
                localVarQueryParameter['domains'] = domains.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves portfolio notifications log.
         * @param {string} portfolioId Portfolio id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(portfolioId: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Activities> {
            const localVarFetchArgs = NotificationsApiFetchParamCreator(configuration).getNotifications(portfolioId, limit, offset, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Reindex notifications. System Administator operation.
         * @param {Array<string>} [domains] List of domains for where notifications need to be reindexed, if not provided reindex will be done for all domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reindexNotifications(domains?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = NotificationsApiFetchParamCreator(configuration).reindexNotifications(domains, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Retrieves portfolio notifications log.
         * @param {string} portfolioId Portfolio id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(portfolioId: string, limit?: number, offset?: number, options?: any) {
            return NotificationsApiFp(configuration).getNotifications(portfolioId, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reindex notifications. System Administator operation.
         * @param {Array<string>} [domains] List of domains for where notifications need to be reindexed, if not provided reindex will be done for all domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reindexNotifications(domains?: Array<string>, options?: any) {
            return NotificationsApiFp(configuration).reindexNotifications(domains, options)(fetch, basePath);
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieves portfolio notifications log.
     * @param {string} portfolioId Portfolio id
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotifications(portfolioId: string, limit?: number, offset?: number, options?: any) {
        return NotificationsApiFp(this.configuration).getNotifications(portfolioId, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Reindex notifications. System Administator operation.
     * @param {Array<string>} [domains] List of domains for where notifications need to be reindexed, if not provided reindex will be done for all domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public reindexNotifications(domains?: Array<string>, options?: any) {
        return NotificationsApiFp(this.configuration).reindexNotifications(domains, options)(this.fetch, this.basePath);
    }

}

/**
 * PlansApi - fetch parameter creator
 * @export
 */
export const PlansApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Export Whats In Comparison
         * @param {string} portfolioId portfolioId
         * @param {string} portfolioPlanIds portfolioPlanIds to be exported
         * @param {any} exportFormat export format type (XLSX)
         * @param {number} startDate Start time period for which the grades are computed for.
         * @param {number} endDate End time period for which the grades are computed for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportWhatsIn(portfolioId: string, portfolioPlanIds: string, exportFormat: any, startDate: number, endDate: number, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling exportWhatsIn.');
            }
            // verify required parameter 'portfolioPlanIds' is not null or undefined
            if (portfolioPlanIds === null || portfolioPlanIds === undefined) {
                throw new RequiredError('portfolioPlanIds','Required parameter portfolioPlanIds was null or undefined when calling exportWhatsIn.');
            }
            // verify required parameter 'exportFormat' is not null or undefined
            if (exportFormat === null || exportFormat === undefined) {
                throw new RequiredError('exportFormat','Required parameter exportFormat was null or undefined when calling exportWhatsIn.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling exportWhatsIn.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling exportWhatsIn.');
            }
            const localVarPath = `/portfolioPlans/whatsin/export`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            if (portfolioPlanIds !== undefined) {
                localVarQueryParameter['portfolioPlanIds'] = portfolioPlanIds;
            }

            if (exportFormat !== undefined) {
                localVarQueryParameter['exportFormat'] = exportFormat;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves insights for portfolio plan.
         * @param {string} id Portfolio Plan id
         * @param {number} startDate Start time period for which the insights are computed for.
         * @param {number} endDate End time period for which the insights are computed for.
         * @param {boolean} includeGrades Whether to include grades in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsightsForPortfolioPlan(id: string, startDate: number, endDate: number, includeGrades: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInsightsForPortfolioPlan.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getInsightsForPortfolioPlan.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getInsightsForPortfolioPlan.');
            }
            // verify required parameter 'includeGrades' is not null or undefined
            if (includeGrades === null || includeGrades === undefined) {
                throw new RequiredError('includeGrades','Required parameter includeGrades was null or undefined when calling getInsightsForPortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{id}/insights`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (includeGrades !== undefined) {
                localVarQueryParameter['includeGrades'] = includeGrades;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves value insights for portfolio plan.
         * @param {string} id Portfolio Plan id
         * @param {number} startDate Start time period for which the grades are computed for.
         * @param {number} endDate End time period for which the grades are computed for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueInsightsForPortfolioPlan(id: string, startDate: number, endDate: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getValueInsightsForPortfolioPlan.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getValueInsightsForPortfolioPlan.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getValueInsightsForPortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{id}/insights/value`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves portfolioPlans with projects for WhatsIn
         * @param {string} portfolioId portfolioId
         * @param {string} portfolioPlanIds portfolioPlanIds for which projects are returned
         * @param {number} startDate Start time period for which the grades are computed for.
         * @param {number} endDate End time period for which the grades are computed for.
         * @param {number} maxLimit Maximum limit for project; 0 &lt; number of returned project(is variable, NOT fixed) &lt; maxLimit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhatsIn(portfolioId: string, portfolioPlanIds: string, startDate: number, endDate: number, maxLimit: number, offset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getWhatsIn.');
            }
            // verify required parameter 'portfolioPlanIds' is not null or undefined
            if (portfolioPlanIds === null || portfolioPlanIds === undefined) {
                throw new RequiredError('portfolioPlanIds','Required parameter portfolioPlanIds was null or undefined when calling getWhatsIn.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling getWhatsIn.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling getWhatsIn.');
            }
            // verify required parameter 'maxLimit' is not null or undefined
            if (maxLimit === null || maxLimit === undefined) {
                throw new RequiredError('maxLimit','Required parameter maxLimit was null or undefined when calling getWhatsIn.');
            }
            const localVarPath = `/portfolioPlans/whatsin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            if (portfolioPlanIds !== undefined) {
                localVarQueryParameter['portfolioPlanIds'] = portfolioPlanIds;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (maxLimit !== undefined) {
                localVarQueryParameter['maxLimit'] = maxLimit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlansApi - functional programming interface
 * @export
 */
export const PlansApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Export Whats In Comparison
         * @param {string} portfolioId portfolioId
         * @param {string} portfolioPlanIds portfolioPlanIds to be exported
         * @param {any} exportFormat export format type (XLSX)
         * @param {number} startDate Start time period for which the grades are computed for.
         * @param {number} endDate End time period for which the grades are computed for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportWhatsIn(portfolioId: string, portfolioPlanIds: string, exportFormat: any, startDate: number, endDate: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = PlansApiFetchParamCreator(configuration).exportWhatsIn(portfolioId, portfolioPlanIds, exportFormat, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves insights for portfolio plan.
         * @param {string} id Portfolio Plan id
         * @param {number} startDate Start time period for which the insights are computed for.
         * @param {number} endDate End time period for which the insights are computed for.
         * @param {boolean} includeGrades Whether to include grades in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsightsForPortfolioPlan(id: string, startDate: number, endDate: number, includeGrades: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortfolioPlanInsights> {
            const localVarFetchArgs = PlansApiFetchParamCreator(configuration).getInsightsForPortfolioPlan(id, startDate, endDate, includeGrades, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves value insights for portfolio plan.
         * @param {string} id Portfolio Plan id
         * @param {number} startDate Start time period for which the grades are computed for.
         * @param {number} endDate End time period for which the grades are computed for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueInsightsForPortfolioPlan(id: string, startDate: number, endDate: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortfolioPlanInsights> {
            const localVarFetchArgs = PlansApiFetchParamCreator(configuration).getValueInsightsForPortfolioPlan(id, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves portfolioPlans with projects for WhatsIn
         * @param {string} portfolioId portfolioId
         * @param {string} portfolioPlanIds portfolioPlanIds for which projects are returned
         * @param {number} startDate Start time period for which the grades are computed for.
         * @param {number} endDate End time period for which the grades are computed for.
         * @param {number} maxLimit Maximum limit for project; 0 &lt; number of returned project(is variable, NOT fixed) &lt; maxLimit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhatsIn(portfolioId: string, portfolioPlanIds: string, startDate: number, endDate: number, maxLimit: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WhatsIn> {
            const localVarFetchArgs = PlansApiFetchParamCreator(configuration).getWhatsIn(portfolioId, portfolioPlanIds, startDate, endDate, maxLimit, offset, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PlansApi - factory interface
 * @export
 */
export const PlansApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Export Whats In Comparison
         * @param {string} portfolioId portfolioId
         * @param {string} portfolioPlanIds portfolioPlanIds to be exported
         * @param {any} exportFormat export format type (XLSX)
         * @param {number} startDate Start time period for which the grades are computed for.
         * @param {number} endDate End time period for which the grades are computed for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportWhatsIn(portfolioId: string, portfolioPlanIds: string, exportFormat: any, startDate: number, endDate: number, options?: any) {
            return PlansApiFp(configuration).exportWhatsIn(portfolioId, portfolioPlanIds, exportFormat, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves insights for portfolio plan.
         * @param {string} id Portfolio Plan id
         * @param {number} startDate Start time period for which the insights are computed for.
         * @param {number} endDate End time period for which the insights are computed for.
         * @param {boolean} includeGrades Whether to include grades in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsightsForPortfolioPlan(id: string, startDate: number, endDate: number, includeGrades: boolean, options?: any) {
            return PlansApiFp(configuration).getInsightsForPortfolioPlan(id, startDate, endDate, includeGrades, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves value insights for portfolio plan.
         * @param {string} id Portfolio Plan id
         * @param {number} startDate Start time period for which the grades are computed for.
         * @param {number} endDate End time period for which the grades are computed for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValueInsightsForPortfolioPlan(id: string, startDate: number, endDate: number, options?: any) {
            return PlansApiFp(configuration).getValueInsightsForPortfolioPlan(id, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves portfolioPlans with projects for WhatsIn
         * @param {string} portfolioId portfolioId
         * @param {string} portfolioPlanIds portfolioPlanIds for which projects are returned
         * @param {number} startDate Start time period for which the grades are computed for.
         * @param {number} endDate End time period for which the grades are computed for.
         * @param {number} maxLimit Maximum limit for project; 0 &lt; number of returned project(is variable, NOT fixed) &lt; maxLimit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhatsIn(portfolioId: string, portfolioPlanIds: string, startDate: number, endDate: number, maxLimit: number, offset?: number, options?: any) {
            return PlansApiFp(configuration).getWhatsIn(portfolioId, portfolioPlanIds, startDate, endDate, maxLimit, offset, options)(fetch, basePath);
        },
    };
};

/**
 * PlansApi - object-oriented interface
 * @export
 * @class PlansApi
 * @extends {BaseAPI}
 */
export class PlansApi extends BaseAPI {
    /**
     * 
     * @summary Export Whats In Comparison
     * @param {string} portfolioId portfolioId
     * @param {string} portfolioPlanIds portfolioPlanIds to be exported
     * @param {any} exportFormat export format type (XLSX)
     * @param {number} startDate Start time period for which the grades are computed for.
     * @param {number} endDate End time period for which the grades are computed for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public exportWhatsIn(portfolioId: string, portfolioPlanIds: string, exportFormat: any, startDate: number, endDate: number, options?: any) {
        return PlansApiFp(this.configuration).exportWhatsIn(portfolioId, portfolioPlanIds, exportFormat, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves insights for portfolio plan.
     * @param {string} id Portfolio Plan id
     * @param {number} startDate Start time period for which the insights are computed for.
     * @param {number} endDate End time period for which the insights are computed for.
     * @param {boolean} includeGrades Whether to include grades in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public getInsightsForPortfolioPlan(id: string, startDate: number, endDate: number, includeGrades: boolean, options?: any) {
        return PlansApiFp(this.configuration).getInsightsForPortfolioPlan(id, startDate, endDate, includeGrades, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves value insights for portfolio plan.
     * @param {string} id Portfolio Plan id
     * @param {number} startDate Start time period for which the grades are computed for.
     * @param {number} endDate End time period for which the grades are computed for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public getValueInsightsForPortfolioPlan(id: string, startDate: number, endDate: number, options?: any) {
        return PlansApiFp(this.configuration).getValueInsightsForPortfolioPlan(id, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves portfolioPlans with projects for WhatsIn
     * @param {string} portfolioId portfolioId
     * @param {string} portfolioPlanIds portfolioPlanIds for which projects are returned
     * @param {number} startDate Start time period for which the grades are computed for.
     * @param {number} endDate End time period for which the grades are computed for.
     * @param {number} maxLimit Maximum limit for project; 0 &lt; number of returned project(is variable, NOT fixed) &lt; maxLimit
     * @param {number} [offset] Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public getWhatsIn(portfolioId: string, portfolioPlanIds: string, startDate: number, endDate: number, maxLimit: number, offset?: number, options?: any) {
        return PlansApiFp(this.configuration).getWhatsIn(portfolioId, portfolioPlanIds, startDate, endDate, maxLimit, offset, options)(this.fetch, this.basePath);
    }

}

/**
 * PodsApi - fetch parameter creator
 * @export
 */
export const PodsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Import pod template in JSON format
         * @param {any} podFile The pod file to upload.
         * @param {string} templateName pod template name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importPodTemplate(podFile: any, templateName: string, options: any = {}): FetchArgs {
            // verify required parameter 'podFile' is not null or undefined
            if (podFile === null || podFile === undefined) {
                throw new RequiredError('podFile','Required parameter podFile was null or undefined when calling importPodTemplate.');
            }
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling importPodTemplate.');
            }
            const localVarPath = `/pods/template`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (podFile !== undefined) {
                localVarFormParams.set('podFile', podFile as any);
            }

            if (templateName !== undefined) {
                localVarFormParams.set('templateName', templateName as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PodsApi - functional programming interface
 * @export
 */
export const PodsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Import pod template in JSON format
         * @param {any} podFile The pod file to upload.
         * @param {string} templateName pod template name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importPodTemplate(podFile: any, templateName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PodsApiFetchParamCreator(configuration).importPodTemplate(podFile, templateName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PodsApi - factory interface
 * @export
 */
export const PodsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Import pod template in JSON format
         * @param {any} podFile The pod file to upload.
         * @param {string} templateName pod template name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importPodTemplate(podFile: any, templateName: string, options?: any) {
            return PodsApiFp(configuration).importPodTemplate(podFile, templateName, options)(fetch, basePath);
        },
    };
};

/**
 * PodsApi - object-oriented interface
 * @export
 * @class PodsApi
 * @extends {BaseAPI}
 */
export class PodsApi extends BaseAPI {
    /**
     * 
     * @summary Import pod template in JSON format
     * @param {any} podFile The pod file to upload.
     * @param {string} templateName pod template name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodsApi
     */
    public importPodTemplate(podFile: any, templateName: string, options?: any) {
        return PodsApiFp(this.configuration).importPodTemplate(podFile, templateName, options)(this.fetch, this.basePath);
    }

}

/**
 * PortfolioPlanUsersApi - fetch parameter creator
 * @export
 */
export const PortfolioPlanUsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a portfolio plan user
         * @param {string} id Portfolio plan user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePortfolioPlanUser(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePortfolioPlanUser.');
            }
            const localVarPath = `/portfolioPlanUsers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update portfolio plan users
         * @param {Array<PatchItem>} body JSON Patch Operations to update multiple portfolio plan users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlanUsers(body: Array<PatchItem>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePortfolioPlanUsers.');
            }
            const localVarPath = `/portfolioPlanUsers/{id}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;PatchItem&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioPlanUsersApi - functional programming interface
 * @export
 */
export const PortfolioPlanUsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a portfolio plan user
         * @param {string} id Portfolio plan user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePortfolioPlanUser(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PortfolioPlanUsersApiFetchParamCreator(configuration).deletePortfolioPlanUser(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update portfolio plan users
         * @param {Array<PatchItem>} body JSON Patch Operations to update multiple portfolio plan users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlanUsers(body: Array<PatchItem>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortfolioPlanUser>> {
            const localVarFetchArgs = PortfolioPlanUsersApiFetchParamCreator(configuration).updatePortfolioPlanUsers(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PortfolioPlanUsersApi - factory interface
 * @export
 */
export const PortfolioPlanUsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Delete a portfolio plan user
         * @param {string} id Portfolio plan user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePortfolioPlanUser(id: string, options?: any) {
            return PortfolioPlanUsersApiFp(configuration).deletePortfolioPlanUser(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update portfolio plan users
         * @param {Array<PatchItem>} body JSON Patch Operations to update multiple portfolio plan users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlanUsers(body: Array<PatchItem>, options?: any) {
            return PortfolioPlanUsersApiFp(configuration).updatePortfolioPlanUsers(body, options)(fetch, basePath);
        },
    };
};

/**
 * PortfolioPlanUsersApi - object-oriented interface
 * @export
 * @class PortfolioPlanUsersApi
 * @extends {BaseAPI}
 */
export class PortfolioPlanUsersApi extends BaseAPI {
    /**
     * 
     * @summary Delete a portfolio plan user
     * @param {string} id Portfolio plan user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlanUsersApi
     */
    public deletePortfolioPlanUser(id: string, options?: any) {
        return PortfolioPlanUsersApiFp(this.configuration).deletePortfolioPlanUser(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update portfolio plan users
     * @param {Array<PatchItem>} body JSON Patch Operations to update multiple portfolio plan users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlanUsersApi
     */
    public updatePortfolioPlanUsers(body: Array<PatchItem>, options?: any) {
        return PortfolioPlanUsersApiFp(this.configuration).updatePortfolioPlanUsers(body, options)(this.fetch, this.basePath);
    }

}

/**
 * PortfolioPlansApi - fetch parameter creator
 * @export
 */
export const PortfolioPlansApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary add field values for the fields, and remove all field values for fields, for the supplied project
         * @param {any} portfolioPlanId Portfolio plan id
         * @param {any} projectId Project id
         * @param {AddAndDeleteFieldValuesForFieldsRequest} body TimePeriods cost fields to add, cost fields to remove
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAndDeleteFieldValuesForFields(portfolioPlanId: any, projectId: any, body: AddAndDeleteFieldValuesForFieldsRequest, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioPlanId' is not null or undefined
            if (portfolioPlanId === null || portfolioPlanId === undefined) {
                throw new RequiredError('portfolioPlanId','Required parameter portfolioPlanId was null or undefined when calling addAndDeleteFieldValuesForFields.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling addAndDeleteFieldValuesForFields.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addAndDeleteFieldValuesForFields.');
            }
            const localVarPath = `/portfolioPlans/{portfolioPlanId}/project/{projectId}/addRemoveCosts`
                .replace(`{${"portfolioPlanId"}}`, encodeURIComponent(String(portfolioPlanId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddAndDeleteFieldValuesForFieldsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add users to a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {AddUsersRequest} [body] Email ids and personal message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioPlanUsers(id: string, body?: AddUsersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addPortfolioPlanUsers.');
            }
            const localVarPath = `/portfolioPlans/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddUsersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply recommendations of a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {Array<Recommendation>} body JSON Recommendation Objects to apply to a portfolio plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyRecommendationsForPortfolioPlan(id: string, body: Array<Recommendation>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling applyRecommendationsForPortfolioPlan.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling applyRecommendationsForPortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{id}/recommendations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Recommendation&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a portfolio plan
         * @param {PortfolioPlan} body portfolio plan
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolioPlan(body: PortfolioPlan, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PortfolioPlan" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new projects
         * @param {string} id Portfolio plan id
         * @param {Array<Project>} body Projects to create
         * @param {boolean} [doNotExpand] Whether to return collections for each project in the response. Default is to return saved field values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectsInPortfolioPlan(id: string, body: Array<Project>, doNotExpand?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createProjectsInPortfolioPlan.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProjectsInPortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{id}/projects`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (doNotExpand !== undefined) {
                localVarQueryParameter['doNotExpand'] = doNotExpand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Project&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes portfolio plan
         * @param {string} id portfolio plan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePortfolioPlan(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export portfolio plan
         * @param {string} id portfolio plan id
         * @param {any} exportType export type (PROJECT, SCHEDULE, SPEND_PLAN)
         * @param {any} exportFormat export format type (XLSX)
         * @param {ExportConfig} [exportConfig] export configuration object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPortfolioPlan(id: string, exportType: any, exportFormat: any, exportConfig?: ExportConfig, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling exportPortfolioPlan.');
            }
            // verify required parameter 'exportType' is not null or undefined
            if (exportType === null || exportType === undefined) {
                throw new RequiredError('exportType','Required parameter exportType was null or undefined when calling exportPortfolioPlan.');
            }
            // verify required parameter 'exportFormat' is not null or undefined
            if (exportFormat === null || exportFormat === undefined) {
                throw new RequiredError('exportFormat','Required parameter exportFormat was null or undefined when calling exportPortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{id}/export`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (exportType !== undefined) {
                localVarQueryParameter['exportType'] = exportType;
            }

            if (exportFormat !== undefined) {
                localVarQueryParameter['exportFormat'] = exportFormat;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExportConfig" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(exportConfig || {}) : (exportConfig || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves budget allocations for a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {number} [startTime] Start time for the requested data
         * @param {number} [endTime] End time for the requested data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetAllocationsForPortfolioPlan(id: string, startTime?: number, endTime?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getBudgetAllocationsForPortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{id}/budgetAllocations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch field values data for portfolio plan and data id.
         * @param {string} portfolioPlanId Portfolio plan ID
         * @param {string} dataId Data ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldValuesDataForPortfolioPlan(portfolioPlanId: string, dataId: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioPlanId' is not null or undefined
            if (portfolioPlanId === null || portfolioPlanId === undefined) {
                throw new RequiredError('portfolioPlanId','Required parameter portfolioPlanId was null or undefined when calling getFieldValuesDataForPortfolioPlan.');
            }
            // verify required parameter 'dataId' is not null or undefined
            if (dataId === null || dataId === undefined) {
                throw new RequiredError('dataId','Required parameter dataId was null or undefined when calling getFieldValuesDataForPortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{portfolioPlanId}/data/{dataId}`
                .replace(`{${"portfolioPlanId"}}`, encodeURIComponent(String(portfolioPlanId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves minified projects contained within a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMinifiedProjectsForPortfolioPlan(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getMinifiedProjectsForPortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{id}/projects/minify`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves portfolio plan
         * @param {string} id portfolio plan id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlan(id: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves portfolio plan activities log.
         * @param {string} id Portfolio plan id
         * @param {string} [projectId] Use when you want to filter activities for a specific project
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlanActivities(id: string, projectId?: string, limit?: number, offset?: number, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPortfolioPlanActivities.');
            }
            const localVarPath = `/portfolioPlans/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves users in a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlanUsers(id: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPortfolioPlanUsers.');
            }
            const localVarPath = `/portfolioPlans/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves portfolio plans
         * @param {string} portfolioId portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlans(portfolioId: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getPortfolioPlans.');
            }
            const localVarPath = `/portfolioPlans`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves project contained within a portfolio plan.
         * @param {string} portfolioPlanId Portfolio plan id
         * @param {string} projectId project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectForPortfolioPlan(portfolioPlanId: string, projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioPlanId' is not null or undefined
            if (portfolioPlanId === null || portfolioPlanId === undefined) {
                throw new RequiredError('portfolioPlanId','Required parameter portfolioPlanId was null or undefined when calling getProjectForPortfolioPlan.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling getProjectForPortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{portfolioPlanId}/projects/{projectId}`
                .replace(`{${"portfolioPlanId"}}`, encodeURIComponent(String(portfolioPlanId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves projects for portfolio plan
         * @param {string} portfolioId Portfolio id
         * @param {string} portfolioPlanId Portfolio Plan id
         * @param {number} positionFrom positionFrom for projects
         * @param {number} positionTo positionTo for projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPortfolioPlansForPortfolioPlanAndPortfolio(portfolioId: string, portfolioPlanId: string, positionFrom: number, positionTo: number, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getProjectPortfolioPlansForPortfolioPlanAndPortfolio.');
            }
            // verify required parameter 'portfolioPlanId' is not null or undefined
            if (portfolioPlanId === null || portfolioPlanId === undefined) {
                throw new RequiredError('portfolioPlanId','Required parameter portfolioPlanId was null or undefined when calling getProjectPortfolioPlansForPortfolioPlanAndPortfolio.');
            }
            // verify required parameter 'positionFrom' is not null or undefined
            if (positionFrom === null || positionFrom === undefined) {
                throw new RequiredError('positionFrom','Required parameter positionFrom was null or undefined when calling getProjectPortfolioPlansForPortfolioPlanAndPortfolio.');
            }
            // verify required parameter 'positionTo' is not null or undefined
            if (positionTo === null || positionTo === undefined) {
                throw new RequiredError('positionTo','Required parameter positionTo was null or undefined when calling getProjectPortfolioPlansForPortfolioPlanAndPortfolio.');
            }
            const localVarPath = `/portfolioPlans/{portfolioPlanId}/portfolios/{portfolioId}/projectPortfolioPlans`
                .replace(`{${"portfolioId"}}`, encodeURIComponent(String(portfolioId)))
                .replace(`{${"portfolioPlanId"}}`, encodeURIComponent(String(portfolioPlanId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (positionFrom !== undefined) {
                localVarQueryParameter['positionFrom'] = positionFrom;
            }

            if (positionTo !== undefined) {
                localVarQueryParameter['positionTo'] = positionTo;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves projects contained within a portfolio plan. Possible expand paths - (items.fieldValues, contributingUserIds)
         * @param {string} id Portfolio plan id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForPortfolioPlan(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProjectsForPortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{id}/projects`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves recommendations for a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {number} [startDate] Start time period for the time horizon.
         * @param {number} [endDate] End time period for the time horizon.
         * @param {any} [planType] Plan type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendationsForPortfolioPlan(id: string, startDate?: number, endDate?: number, planType?: any, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRecommendationsForPortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{id}/recommendations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (planType !== undefined) {
                localVarQueryParameter['planType'] = planType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves schedule for portfolio plan. The schedule is stored in a new portfolio plan.
         * @param {string} id Portfolio Plan id
         * @param {number} [startDate] Start time period for the time horizon.
         * @param {number} [endDate] End time period for the time horizon.
         * @param {number} [toleranceLevelPercentage] Percentage parameter to allow scheduling values within a deviation, defined by [target*(1 - tolerance), target*(1 + tolerance] bounds. Value should be between 0 and 1. Defaults to 0.1
         * @param {any} [schedulingCriteria] Criteria used to function to evaluate different schedules. Defaults to TimePeriodOverBudgetPercent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleForPortfolioPlan(id: string, startDate?: number, endDate?: number, toleranceLevelPercentage?: number, schedulingCriteria?: any, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getScheduleForPortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{id}/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (toleranceLevelPercentage !== undefined) {
                localVarQueryParameter['toleranceLevelPercentage'] = toleranceLevelPercentage;
            }

            if (schedulingCriteria !== undefined) {
                localVarQueryParameter['schedulingCriteria'] = schedulingCriteria;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rebaseline a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebaselinePortfolioPlan(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rebaselinePortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{id}/rebaseline`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a portfolio plan utilizing JSON Patch Operations. 
         * @param {string} id PortfolioPlan id
         * @param {Operations} body JSON Patch Operations to update portfolio plan.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlan(id: string, body: Operations, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePortfolioPlan.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePortfolioPlan.');
            }
            const localVarPath = `/portfolioPlans/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Operations" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update field values in a portfolio plan
         * @param {any} id Portfolio plan id
         * @param {Array<ResourcePoolFieldValuePatchItem>} body JSON Patch Operations to update multiple field values.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlanBudgetFieldValues(id: any, body: Array<ResourcePoolFieldValuePatchItem>, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePortfolioPlanBudgetFieldValues.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePortfolioPlanBudgetFieldValues.');
            }
            const localVarPath = `/portfolioPlans/{id}/fieldValues/budgets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ResourcePoolFieldValuePatchItem&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update field values in a portfolio plan
         * @param {any} id Portfolio plan id
         * @param {Array<FieldValuePatchItem>} body JSON Patch Operations to update multiple field values.
         * @param {boolean} [applyRank] Whether the update signifies an Apply Rank action.
         * @param {boolean} [preserveProjectAccess] Making sure projects access is retained in case that the current change would affect permissions
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlanFieldValues(id: any, body: Array<FieldValuePatchItem>, applyRank?: boolean, preserveProjectAccess?: boolean, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePortfolioPlanFieldValues.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePortfolioPlanFieldValues.');
            }
            const localVarPath = `/portfolioPlans/{id}/fieldValues`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (applyRank !== undefined) {
                localVarQueryParameter['applyRank'] = applyRank;
            }

            if (preserveProjectAccess !== undefined) {
                localVarQueryParameter['preserveProjectAccess'] = preserveProjectAccess;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;FieldValuePatchItem&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update users in a portfolio plan
         * @param {any} id Portfolio plan id
         * @param {Array<PatchItem>} body JSON Patch Operations to update multiple portfolio plan users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlanUsers(id: any, body: Array<PatchItem>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePortfolioPlanUsers.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePortfolioPlanUsers.');
            }
            const localVarPath = `/portfolioPlans/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;PatchItem&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioPlansApi - functional programming interface
 * @export
 */
export const PortfolioPlansApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary add field values for the fields, and remove all field values for fields, for the supplied project
         * @param {any} portfolioPlanId Portfolio plan id
         * @param {any} projectId Project id
         * @param {AddAndDeleteFieldValuesForFieldsRequest} body TimePeriods cost fields to add, cost fields to remove
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAndDeleteFieldValuesForFields(portfolioPlanId: any, projectId: any, body: AddAndDeleteFieldValuesForFieldsRequest, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FieldValue>> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).addAndDeleteFieldValuesForFields(portfolioPlanId, projectId, body, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Add users to a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {AddUsersRequest} [body] Email ids and personal message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioPlanUsers(id: string, body?: AddUsersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortfolioPlanUser>> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).addPortfolioPlanUsers(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Apply recommendations of a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {Array<Recommendation>} body JSON Recommendation Objects to apply to a portfolio plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyRecommendationsForPortfolioPlan(id: string, body: Array<Recommendation>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FieldValue>> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).applyRecommendationsForPortfolioPlan(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a portfolio plan
         * @param {PortfolioPlan} body portfolio plan
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolioPlan(body: PortfolioPlan, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortfolioPlan> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).createPortfolioPlan(body, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new projects
         * @param {string} id Portfolio plan id
         * @param {Array<Project>} body Projects to create
         * @param {boolean} [doNotExpand] Whether to return collections for each project in the response. Default is to return saved field values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectsInPortfolioPlan(id: string, body: Array<Project>, doNotExpand?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Project>> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).createProjectsInPortfolioPlan(id, body, doNotExpand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes portfolio plan
         * @param {string} id portfolio plan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePortfolioPlan(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).deletePortfolioPlan(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Export portfolio plan
         * @param {string} id portfolio plan id
         * @param {any} exportType export type (PROJECT, SCHEDULE, SPEND_PLAN)
         * @param {any} exportFormat export format type (XLSX)
         * @param {ExportConfig} [exportConfig] export configuration object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPortfolioPlan(id: string, exportType: any, exportFormat: any, exportConfig?: ExportConfig, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).exportPortfolioPlan(id, exportType, exportFormat, exportConfig, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves budget allocations for a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {number} [startTime] Start time for the requested data
         * @param {number} [endTime] End time for the requested data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetAllocationsForPortfolioPlan(id: string, startTime?: number, endTime?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BudgetAllocations> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).getBudgetAllocationsForPortfolioPlan(id, startTime, endTime, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Fetch field values data for portfolio plan and data id.
         * @param {string} portfolioPlanId Portfolio plan ID
         * @param {string} dataId Data ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldValuesDataForPortfolioPlan(portfolioPlanId: string, dataId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FieldValue>> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).getFieldValuesDataForPortfolioPlan(portfolioPlanId, dataId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves minified projects contained within a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMinifiedProjectsForPortfolioPlan(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MinifiedProjects> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).getMinifiedProjectsForPortfolioPlan(id, expand, limit, offset, orderBy, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves portfolio plan
         * @param {string} id portfolio plan id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlan(id: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortfolioPlan> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).getPortfolioPlan(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves portfolio plan activities log.
         * @param {string} id Portfolio plan id
         * @param {string} [projectId] Use when you want to filter activities for a specific project
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlanActivities(id: string, projectId?: string, limit?: number, offset?: number, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Activities> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).getPortfolioPlanActivities(id, projectId, limit, offset, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves users in a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlanUsers(id: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortfolioPlanUsers> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).getPortfolioPlanUsers(id, limit, offset, orderBy, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves portfolio plans
         * @param {string} portfolioId portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlans(portfolioId: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortfolioPlans> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).getPortfolioPlans(portfolioId, expand, limit, offset, orderBy, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves project contained within a portfolio plan.
         * @param {string} portfolioPlanId Portfolio plan id
         * @param {string} projectId project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectForPortfolioPlan(portfolioPlanId: string, projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).getProjectForPortfolioPlan(portfolioPlanId, projectId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves projects for portfolio plan
         * @param {string} portfolioId Portfolio id
         * @param {string} portfolioPlanId Portfolio Plan id
         * @param {number} positionFrom positionFrom for projects
         * @param {number} positionTo positionTo for projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPortfolioPlansForPortfolioPlanAndPortfolio(portfolioId: string, portfolioPlanId: string, positionFrom: number, positionTo: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Projects> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).getProjectPortfolioPlansForPortfolioPlanAndPortfolio(portfolioId, portfolioPlanId, positionFrom, positionTo, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves projects contained within a portfolio plan. Possible expand paths - (items.fieldValues, contributingUserIds)
         * @param {string} id Portfolio plan id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForPortfolioPlan(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Projects> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).getProjectsForPortfolioPlan(id, expand, limit, offset, orderBy, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves recommendations for a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {number} [startDate] Start time period for the time horizon.
         * @param {number} [endDate] End time period for the time horizon.
         * @param {any} [planType] Plan type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendationsForPortfolioPlan(id: string, startDate?: number, endDate?: number, planType?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Recommendations> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).getRecommendationsForPortfolioPlan(id, startDate, endDate, planType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves schedule for portfolio plan. The schedule is stored in a new portfolio plan.
         * @param {string} id Portfolio Plan id
         * @param {number} [startDate] Start time period for the time horizon.
         * @param {number} [endDate] End time period for the time horizon.
         * @param {number} [toleranceLevelPercentage] Percentage parameter to allow scheduling values within a deviation, defined by [target*(1 - tolerance), target*(1 + tolerance] bounds. Value should be between 0 and 1. Defaults to 0.1
         * @param {any} [schedulingCriteria] Criteria used to function to evaluate different schedules. Defaults to TimePeriodOverBudgetPercent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleForPortfolioPlan(id: string, startDate?: number, endDate?: number, toleranceLevelPercentage?: number, schedulingCriteria?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Recommendations> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).getScheduleForPortfolioPlan(id, startDate, endDate, toleranceLevelPercentage, schedulingCriteria, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Rebaseline a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebaselinePortfolioPlan(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortfolioPlan> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).rebaselinePortfolioPlan(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a portfolio plan utilizing JSON Patch Operations. 
         * @param {string} id PortfolioPlan id
         * @param {Operations} body JSON Patch Operations to update portfolio plan.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlan(id: string, body: Operations, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortfolioPlan> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).updatePortfolioPlan(id, body, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update field values in a portfolio plan
         * @param {any} id Portfolio plan id
         * @param {Array<ResourcePoolFieldValuePatchItem>} body JSON Patch Operations to update multiple field values.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlanBudgetFieldValues(id: any, body: Array<ResourcePoolFieldValuePatchItem>, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ResourcePoolFieldValue>> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).updatePortfolioPlanBudgetFieldValues(id, body, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update field values in a portfolio plan
         * @param {any} id Portfolio plan id
         * @param {Array<FieldValuePatchItem>} body JSON Patch Operations to update multiple field values.
         * @param {boolean} [applyRank] Whether the update signifies an Apply Rank action.
         * @param {boolean} [preserveProjectAccess] Making sure projects access is retained in case that the current change would affect permissions
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlanFieldValues(id: any, body: Array<FieldValuePatchItem>, applyRank?: boolean, preserveProjectAccess?: boolean, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FieldValue>> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).updatePortfolioPlanFieldValues(id, body, applyRank, preserveProjectAccess, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update users in a portfolio plan
         * @param {any} id Portfolio plan id
         * @param {Array<PatchItem>} body JSON Patch Operations to update multiple portfolio plan users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlanUsers(id: any, body: Array<PatchItem>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortfolioPlanUser>> {
            const localVarFetchArgs = PortfolioPlansApiFetchParamCreator(configuration).updatePortfolioPlanUsers(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PortfolioPlansApi - factory interface
 * @export
 */
export const PortfolioPlansApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary add field values for the fields, and remove all field values for fields, for the supplied project
         * @param {any} portfolioPlanId Portfolio plan id
         * @param {any} projectId Project id
         * @param {AddAndDeleteFieldValuesForFieldsRequest} body TimePeriods cost fields to add, cost fields to remove
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAndDeleteFieldValuesForFields(portfolioPlanId: any, projectId: any, body: AddAndDeleteFieldValuesForFieldsRequest, expand?: string, options?: any) {
            return PortfolioPlansApiFp(configuration).addAndDeleteFieldValuesForFields(portfolioPlanId, projectId, body, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add users to a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {AddUsersRequest} [body] Email ids and personal message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioPlanUsers(id: string, body?: AddUsersRequest, options?: any) {
            return PortfolioPlansApiFp(configuration).addPortfolioPlanUsers(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Apply recommendations of a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {Array<Recommendation>} body JSON Recommendation Objects to apply to a portfolio plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyRecommendationsForPortfolioPlan(id: string, body: Array<Recommendation>, options?: any) {
            return PortfolioPlansApiFp(configuration).applyRecommendationsForPortfolioPlan(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a portfolio plan
         * @param {PortfolioPlan} body portfolio plan
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolioPlan(body: PortfolioPlan, expand?: string, options?: any) {
            return PortfolioPlansApiFp(configuration).createPortfolioPlan(body, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new projects
         * @param {string} id Portfolio plan id
         * @param {Array<Project>} body Projects to create
         * @param {boolean} [doNotExpand] Whether to return collections for each project in the response. Default is to return saved field values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectsInPortfolioPlan(id: string, body: Array<Project>, doNotExpand?: boolean, options?: any) {
            return PortfolioPlansApiFp(configuration).createProjectsInPortfolioPlan(id, body, doNotExpand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes portfolio plan
         * @param {string} id portfolio plan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePortfolioPlan(id: string, options?: any) {
            return PortfolioPlansApiFp(configuration).deletePortfolioPlan(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Export portfolio plan
         * @param {string} id portfolio plan id
         * @param {any} exportType export type (PROJECT, SCHEDULE, SPEND_PLAN)
         * @param {any} exportFormat export format type (XLSX)
         * @param {ExportConfig} [exportConfig] export configuration object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPortfolioPlan(id: string, exportType: any, exportFormat: any, exportConfig?: ExportConfig, options?: any) {
            return PortfolioPlansApiFp(configuration).exportPortfolioPlan(id, exportType, exportFormat, exportConfig, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves budget allocations for a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {number} [startTime] Start time for the requested data
         * @param {number} [endTime] End time for the requested data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBudgetAllocationsForPortfolioPlan(id: string, startTime?: number, endTime?: number, options?: any) {
            return PortfolioPlansApiFp(configuration).getBudgetAllocationsForPortfolioPlan(id, startTime, endTime, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetch field values data for portfolio plan and data id.
         * @param {string} portfolioPlanId Portfolio plan ID
         * @param {string} dataId Data ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldValuesDataForPortfolioPlan(portfolioPlanId: string, dataId: string, options?: any) {
            return PortfolioPlansApiFp(configuration).getFieldValuesDataForPortfolioPlan(portfolioPlanId, dataId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves minified projects contained within a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMinifiedProjectsForPortfolioPlan(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
            return PortfolioPlansApiFp(configuration).getMinifiedProjectsForPortfolioPlan(id, expand, limit, offset, orderBy, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves portfolio plan
         * @param {string} id portfolio plan id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlan(id: string, expand?: string, options?: any) {
            return PortfolioPlansApiFp(configuration).getPortfolioPlan(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves portfolio plan activities log.
         * @param {string} id Portfolio plan id
         * @param {string} [projectId] Use when you want to filter activities for a specific project
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlanActivities(id: string, projectId?: string, limit?: number, offset?: number, match?: string, options?: any) {
            return PortfolioPlansApiFp(configuration).getPortfolioPlanActivities(id, projectId, limit, offset, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves users in a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlanUsers(id: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
            return PortfolioPlansApiFp(configuration).getPortfolioPlanUsers(id, limit, offset, orderBy, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves portfolio plans
         * @param {string} portfolioId portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlans(portfolioId: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
            return PortfolioPlansApiFp(configuration).getPortfolioPlans(portfolioId, expand, limit, offset, orderBy, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves project contained within a portfolio plan.
         * @param {string} portfolioPlanId Portfolio plan id
         * @param {string} projectId project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectForPortfolioPlan(portfolioPlanId: string, projectId: string, options?: any) {
            return PortfolioPlansApiFp(configuration).getProjectForPortfolioPlan(portfolioPlanId, projectId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves projects for portfolio plan
         * @param {string} portfolioId Portfolio id
         * @param {string} portfolioPlanId Portfolio Plan id
         * @param {number} positionFrom positionFrom for projects
         * @param {number} positionTo positionTo for projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPortfolioPlansForPortfolioPlanAndPortfolio(portfolioId: string, portfolioPlanId: string, positionFrom: number, positionTo: number, options?: any) {
            return PortfolioPlansApiFp(configuration).getProjectPortfolioPlansForPortfolioPlanAndPortfolio(portfolioId, portfolioPlanId, positionFrom, positionTo, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves projects contained within a portfolio plan. Possible expand paths - (items.fieldValues, contributingUserIds)
         * @param {string} id Portfolio plan id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForPortfolioPlan(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
            return PortfolioPlansApiFp(configuration).getProjectsForPortfolioPlan(id, expand, limit, offset, orderBy, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves recommendations for a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {number} [startDate] Start time period for the time horizon.
         * @param {number} [endDate] End time period for the time horizon.
         * @param {any} [planType] Plan type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendationsForPortfolioPlan(id: string, startDate?: number, endDate?: number, planType?: any, options?: any) {
            return PortfolioPlansApiFp(configuration).getRecommendationsForPortfolioPlan(id, startDate, endDate, planType, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves schedule for portfolio plan. The schedule is stored in a new portfolio plan.
         * @param {string} id Portfolio Plan id
         * @param {number} [startDate] Start time period for the time horizon.
         * @param {number} [endDate] End time period for the time horizon.
         * @param {number} [toleranceLevelPercentage] Percentage parameter to allow scheduling values within a deviation, defined by [target*(1 - tolerance), target*(1 + tolerance] bounds. Value should be between 0 and 1. Defaults to 0.1
         * @param {any} [schedulingCriteria] Criteria used to function to evaluate different schedules. Defaults to TimePeriodOverBudgetPercent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleForPortfolioPlan(id: string, startDate?: number, endDate?: number, toleranceLevelPercentage?: number, schedulingCriteria?: any, options?: any) {
            return PortfolioPlansApiFp(configuration).getScheduleForPortfolioPlan(id, startDate, endDate, toleranceLevelPercentage, schedulingCriteria, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Rebaseline a portfolio plan.
         * @param {string} id Portfolio plan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebaselinePortfolioPlan(id: string, options?: any) {
            return PortfolioPlansApiFp(configuration).rebaselinePortfolioPlan(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a portfolio plan utilizing JSON Patch Operations. 
         * @param {string} id PortfolioPlan id
         * @param {Operations} body JSON Patch Operations to update portfolio plan.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlan(id: string, body: Operations, expand?: string, options?: any) {
            return PortfolioPlansApiFp(configuration).updatePortfolioPlan(id, body, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update field values in a portfolio plan
         * @param {any} id Portfolio plan id
         * @param {Array<ResourcePoolFieldValuePatchItem>} body JSON Patch Operations to update multiple field values.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlanBudgetFieldValues(id: any, body: Array<ResourcePoolFieldValuePatchItem>, expand?: string, options?: any) {
            return PortfolioPlansApiFp(configuration).updatePortfolioPlanBudgetFieldValues(id, body, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update field values in a portfolio plan
         * @param {any} id Portfolio plan id
         * @param {Array<FieldValuePatchItem>} body JSON Patch Operations to update multiple field values.
         * @param {boolean} [applyRank] Whether the update signifies an Apply Rank action.
         * @param {boolean} [preserveProjectAccess] Making sure projects access is retained in case that the current change would affect permissions
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlanFieldValues(id: any, body: Array<FieldValuePatchItem>, applyRank?: boolean, preserveProjectAccess?: boolean, expand?: string, options?: any) {
            return PortfolioPlansApiFp(configuration).updatePortfolioPlanFieldValues(id, body, applyRank, preserveProjectAccess, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update users in a portfolio plan
         * @param {any} id Portfolio plan id
         * @param {Array<PatchItem>} body JSON Patch Operations to update multiple portfolio plan users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioPlanUsers(id: any, body: Array<PatchItem>, options?: any) {
            return PortfolioPlansApiFp(configuration).updatePortfolioPlanUsers(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * PortfolioPlansApi - object-oriented interface
 * @export
 * @class PortfolioPlansApi
 * @extends {BaseAPI}
 */
export class PortfolioPlansApi extends BaseAPI {
    /**
     * 
     * @summary add field values for the fields, and remove all field values for fields, for the supplied project
     * @param {any} portfolioPlanId Portfolio plan id
     * @param {any} projectId Project id
     * @param {AddAndDeleteFieldValuesForFieldsRequest} body TimePeriods cost fields to add, cost fields to remove
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public addAndDeleteFieldValuesForFields(portfolioPlanId: any, projectId: any, body: AddAndDeleteFieldValuesForFieldsRequest, expand?: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).addAndDeleteFieldValuesForFields(portfolioPlanId, projectId, body, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Add users to a portfolio plan.
     * @param {string} id Portfolio plan id
     * @param {AddUsersRequest} [body] Email ids and personal message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public addPortfolioPlanUsers(id: string, body?: AddUsersRequest, options?: any) {
        return PortfolioPlansApiFp(this.configuration).addPortfolioPlanUsers(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Apply recommendations of a portfolio plan.
     * @param {string} id Portfolio plan id
     * @param {Array<Recommendation>} body JSON Recommendation Objects to apply to a portfolio plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public applyRecommendationsForPortfolioPlan(id: string, body: Array<Recommendation>, options?: any) {
        return PortfolioPlansApiFp(this.configuration).applyRecommendationsForPortfolioPlan(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a portfolio plan
     * @param {PortfolioPlan} body portfolio plan
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public createPortfolioPlan(body: PortfolioPlan, expand?: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).createPortfolioPlan(body, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new projects
     * @param {string} id Portfolio plan id
     * @param {Array<Project>} body Projects to create
     * @param {boolean} [doNotExpand] Whether to return collections for each project in the response. Default is to return saved field values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public createProjectsInPortfolioPlan(id: string, body: Array<Project>, doNotExpand?: boolean, options?: any) {
        return PortfolioPlansApiFp(this.configuration).createProjectsInPortfolioPlan(id, body, doNotExpand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes portfolio plan
     * @param {string} id portfolio plan id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public deletePortfolioPlan(id: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).deletePortfolioPlan(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Export portfolio plan
     * @param {string} id portfolio plan id
     * @param {any} exportType export type (PROJECT, SCHEDULE, SPEND_PLAN)
     * @param {any} exportFormat export format type (XLSX)
     * @param {ExportConfig} [exportConfig] export configuration object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public exportPortfolioPlan(id: string, exportType: any, exportFormat: any, exportConfig?: ExportConfig, options?: any) {
        return PortfolioPlansApiFp(this.configuration).exportPortfolioPlan(id, exportType, exportFormat, exportConfig, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves budget allocations for a portfolio plan.
     * @param {string} id Portfolio plan id
     * @param {number} [startTime] Start time for the requested data
     * @param {number} [endTime] End time for the requested data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public getBudgetAllocationsForPortfolioPlan(id: string, startTime?: number, endTime?: number, options?: any) {
        return PortfolioPlansApiFp(this.configuration).getBudgetAllocationsForPortfolioPlan(id, startTime, endTime, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Fetch field values data for portfolio plan and data id.
     * @param {string} portfolioPlanId Portfolio plan ID
     * @param {string} dataId Data ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public getFieldValuesDataForPortfolioPlan(portfolioPlanId: string, dataId: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).getFieldValuesDataForPortfolioPlan(portfolioPlanId, dataId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves minified projects contained within a portfolio plan.
     * @param {string} id Portfolio plan id
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public getMinifiedProjectsForPortfolioPlan(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).getMinifiedProjectsForPortfolioPlan(id, expand, limit, offset, orderBy, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves portfolio plan
     * @param {string} id portfolio plan id
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public getPortfolioPlan(id: string, expand?: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).getPortfolioPlan(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves portfolio plan activities log.
     * @param {string} id Portfolio plan id
     * @param {string} [projectId] Use when you want to filter activities for a specific project
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public getPortfolioPlanActivities(id: string, projectId?: string, limit?: number, offset?: number, match?: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).getPortfolioPlanActivities(id, projectId, limit, offset, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves users in a portfolio plan.
     * @param {string} id Portfolio plan id
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public getPortfolioPlanUsers(id: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).getPortfolioPlanUsers(id, limit, offset, orderBy, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves portfolio plans
     * @param {string} portfolioId portfolio id
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public getPortfolioPlans(portfolioId: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).getPortfolioPlans(portfolioId, expand, limit, offset, orderBy, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves project contained within a portfolio plan.
     * @param {string} portfolioPlanId Portfolio plan id
     * @param {string} projectId project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public getProjectForPortfolioPlan(portfolioPlanId: string, projectId: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).getProjectForPortfolioPlan(portfolioPlanId, projectId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves projects for portfolio plan
     * @param {string} portfolioId Portfolio id
     * @param {string} portfolioPlanId Portfolio Plan id
     * @param {number} positionFrom positionFrom for projects
     * @param {number} positionTo positionTo for projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public getProjectPortfolioPlansForPortfolioPlanAndPortfolio(portfolioId: string, portfolioPlanId: string, positionFrom: number, positionTo: number, options?: any) {
        return PortfolioPlansApiFp(this.configuration).getProjectPortfolioPlansForPortfolioPlanAndPortfolio(portfolioId, portfolioPlanId, positionFrom, positionTo, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves projects contained within a portfolio plan. Possible expand paths - (items.fieldValues, contributingUserIds)
     * @param {string} id Portfolio plan id
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public getProjectsForPortfolioPlan(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).getProjectsForPortfolioPlan(id, expand, limit, offset, orderBy, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves recommendations for a portfolio plan.
     * @param {string} id Portfolio plan id
     * @param {number} [startDate] Start time period for the time horizon.
     * @param {number} [endDate] End time period for the time horizon.
     * @param {any} [planType] Plan type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public getRecommendationsForPortfolioPlan(id: string, startDate?: number, endDate?: number, planType?: any, options?: any) {
        return PortfolioPlansApiFp(this.configuration).getRecommendationsForPortfolioPlan(id, startDate, endDate, planType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves schedule for portfolio plan. The schedule is stored in a new portfolio plan.
     * @param {string} id Portfolio Plan id
     * @param {number} [startDate] Start time period for the time horizon.
     * @param {number} [endDate] End time period for the time horizon.
     * @param {number} [toleranceLevelPercentage] Percentage parameter to allow scheduling values within a deviation, defined by [target*(1 - tolerance), target*(1 + tolerance] bounds. Value should be between 0 and 1. Defaults to 0.1
     * @param {any} [schedulingCriteria] Criteria used to function to evaluate different schedules. Defaults to TimePeriodOverBudgetPercent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public getScheduleForPortfolioPlan(id: string, startDate?: number, endDate?: number, toleranceLevelPercentage?: number, schedulingCriteria?: any, options?: any) {
        return PortfolioPlansApiFp(this.configuration).getScheduleForPortfolioPlan(id, startDate, endDate, toleranceLevelPercentage, schedulingCriteria, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Rebaseline a portfolio plan.
     * @param {string} id Portfolio plan id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public rebaselinePortfolioPlan(id: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).rebaselinePortfolioPlan(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a portfolio plan utilizing JSON Patch Operations. 
     * @param {string} id PortfolioPlan id
     * @param {Operations} body JSON Patch Operations to update portfolio plan.
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public updatePortfolioPlan(id: string, body: Operations, expand?: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).updatePortfolioPlan(id, body, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update field values in a portfolio plan
     * @param {any} id Portfolio plan id
     * @param {Array<ResourcePoolFieldValuePatchItem>} body JSON Patch Operations to update multiple field values.
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public updatePortfolioPlanBudgetFieldValues(id: any, body: Array<ResourcePoolFieldValuePatchItem>, expand?: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).updatePortfolioPlanBudgetFieldValues(id, body, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update field values in a portfolio plan
     * @param {any} id Portfolio plan id
     * @param {Array<FieldValuePatchItem>} body JSON Patch Operations to update multiple field values.
     * @param {boolean} [applyRank] Whether the update signifies an Apply Rank action.
     * @param {boolean} [preserveProjectAccess] Making sure projects access is retained in case that the current change would affect permissions
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public updatePortfolioPlanFieldValues(id: any, body: Array<FieldValuePatchItem>, applyRank?: boolean, preserveProjectAccess?: boolean, expand?: string, options?: any) {
        return PortfolioPlansApiFp(this.configuration).updatePortfolioPlanFieldValues(id, body, applyRank, preserveProjectAccess, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update users in a portfolio plan
     * @param {any} id Portfolio plan id
     * @param {Array<PatchItem>} body JSON Patch Operations to update multiple portfolio plan users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioPlansApi
     */
    public updatePortfolioPlanUsers(id: any, body: Array<PatchItem>, options?: any) {
        return PortfolioPlansApiFp(this.configuration).updatePortfolioPlanUsers(id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * PortfoliosApi - fetch parameter creator
 * @export
 */
export const PortfoliosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive a portfolio.
         * @param {string} id Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archivePortfolio(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling archivePortfolio.');
            }
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new portfolio.
         * @param {Portfolio} body Portfolio to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolio(body: Portfolio, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPortfolio.');
            }
            const localVarPath = `/portfolios`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Portfolio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the spreadsheet report for a portfolio
         * @param {string} portfolioId Portfolio id
         * @param {string} spreadsheetId Spreadsheet id
         * @param {string} sheetName Spreadsheet name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpreadsheetReportForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling deleteSpreadsheetReportForPortfolio.');
            }
            // verify required parameter 'spreadsheetId' is not null or undefined
            if (spreadsheetId === null || spreadsheetId === undefined) {
                throw new RequiredError('spreadsheetId','Required parameter spreadsheetId was null or undefined when calling deleteSpreadsheetReportForPortfolio.');
            }
            // verify required parameter 'sheetName' is not null or undefined
            if (sheetName === null || sheetName === undefined) {
                throw new RequiredError('sheetName','Required parameter sheetName was null or undefined when calling deleteSpreadsheetReportForPortfolio.');
            }
            const localVarPath = `/portfolios/{portfolioId}/spreadsheet/{spreadsheetId}/report`
                .replace(`{${"portfolioId"}}`, encodeURIComponent(String(portfolioId)))
                .replace(`{${"spreadsheetId"}}`, encodeURIComponent(String(spreadsheetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sheetName !== undefined) {
                localVarQueryParameter['sheetName'] = sheetName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download spreadsheet template for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSpreadsheetTemplate(portfolioId: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling downloadSpreadsheetTemplate.');
            }
            const localVarPath = `/portfolios/{portfolioId}/spreadsheet/template`
                .replace(`{${"portfolioId"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export portfolio data in JSON format
         * @param {string} id Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPortfolioData(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling exportPortfolioData.');
            }
            const localVarPath = `/portfolios/{id}/pod`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a portfolio.
         * @param {string} id Portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolio(id: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPortfolio.');
            }
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves portfolio activities log.
         * @param {string} id Portfolio id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioActivities(id: string, limit?: number, offset?: number, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPortfolioActivities.');
            }
            const localVarPath = `/portfolios/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves portfolio plan users for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlanUsersForPortfolio(portfolioId: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getPortfolioPlanUsersForPortfolio.');
            }
            const localVarPath = `/portfolios/{portfolioId}/portfolioPlanUsers`
                .replace(`{${"portfolioId"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary (Deprecated. Use getResourcePoolsForPortfolioPlan) Retrieves resource pools in a portfolio.
         * @param {string} id Portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioResourcePools(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPortfolioResourcePools.');
            }
            const localVarPath = `/portfolios/{id}/resourcePools`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get portfolios.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolios(expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}): FetchArgs {
            const localVarPath = `/portfolios`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves portfolios for specific user.
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfoliosForUser(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPortfoliosForUser.');
            }
            const localVarPath = `/portfolios/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves projects for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForPortfolio(portfolioId: string, limit?: number, offset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getProjectsForPortfolio.');
            }
            const localVarPath = `/portfolios/{portfolioId}/projects`
                .replace(`{${"portfolioId"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves spreadsheet report for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {string} spreadsheetId Spreadsheet id
         * @param {string} sheetName Spreadsheet name
         * @param {any} [importType] Import type
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpreadsheetReportForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, importType?: any, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getSpreadsheetReportForPortfolio.');
            }
            // verify required parameter 'spreadsheetId' is not null or undefined
            if (spreadsheetId === null || spreadsheetId === undefined) {
                throw new RequiredError('spreadsheetId','Required parameter spreadsheetId was null or undefined when calling getSpreadsheetReportForPortfolio.');
            }
            // verify required parameter 'sheetName' is not null or undefined
            if (sheetName === null || sheetName === undefined) {
                throw new RequiredError('sheetName','Required parameter sheetName was null or undefined when calling getSpreadsheetReportForPortfolio.');
            }
            const localVarPath = `/portfolios/{portfolioId}/spreadsheet/{spreadsheetId}/report`
                .replace(`{${"portfolioId"}}`, encodeURIComponent(String(portfolioId)))
                .replace(`{${"spreadsheetId"}}`, encodeURIComponent(String(spreadsheetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sheetName !== undefined) {
                localVarQueryParameter['sheetName'] = sheetName;
            }

            if (importType !== undefined) {
                localVarQueryParameter['importType'] = importType;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import portfolio data in JSON format
         * @param {string} id Portfolio id
         * @param {any} [podFile] The pod file to upload.
         * @param {string} [templateName] pod template name to load
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importPortfolioData(id: string, podFile?: any, templateName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling importPortfolioData.');
            }
            const localVarPath = `/portfolios/{id}/pod`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (templateName !== undefined) {
                localVarQueryParameter['templateName'] = templateName;
            }

            if (podFile !== undefined) {
                localVarFormParams.set('podFile', podFile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generates a new registration token
         * @param {string} id Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateUserRegistrationToken(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling regenerateUserRegistrationToken.');
            }
            const localVarPath = `/portfolios/{id}/regenerateUserRegistrationToken`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Saves spreadsheet for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {string} spreadsheetId Spreadsheet id
         * @param {string} sheetName Spreadsheet name
         * @param {any} [importType] Import type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSpreadsheetForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, importType?: any, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling saveSpreadsheetForPortfolio.');
            }
            // verify required parameter 'spreadsheetId' is not null or undefined
            if (spreadsheetId === null || spreadsheetId === undefined) {
                throw new RequiredError('spreadsheetId','Required parameter spreadsheetId was null or undefined when calling saveSpreadsheetForPortfolio.');
            }
            // verify required parameter 'sheetName' is not null or undefined
            if (sheetName === null || sheetName === undefined) {
                throw new RequiredError('sheetName','Required parameter sheetName was null or undefined when calling saveSpreadsheetForPortfolio.');
            }
            const localVarPath = `/portfolios/{portfolioId}/spreadsheet/{spreadsheetId}`
                .replace(`{${"portfolioId"}}`, encodeURIComponent(String(portfolioId)))
                .replace(`{${"spreadsheetId"}}`, encodeURIComponent(String(spreadsheetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sheetName !== undefined) {
                localVarQueryParameter['sheetName'] = sheetName;
            }

            if (importType !== undefined) {
                localVarQueryParameter['importType'] = importType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save spreadsheet source for a portfolio
         * @param {string} id Portfolio id
         * @param {any} file 
         * @param {string} [sheetName] Spreadsheet name. Defaults to first sheet.
         * @param {any} [importType] Import type. Defaults to PROJECT.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSpreadsheetSourceForPortfolio(id: string, file: any, sheetName?: string, importType?: any, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling saveSpreadsheetSourceForPortfolio.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling saveSpreadsheetSourceForPortfolio.');
            }
            const localVarPath = `/portfolios/{id}/sources/spreadsheet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sheetName !== undefined) {
                localVarQueryParameter['sheetName'] = sheetName;
            }

            if (importType !== undefined) {
                localVarQueryParameter['importType'] = importType;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates custom names for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {Array<CustomName>} customNames Custom names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomNames(portfolioId: string, customNames: Array<CustomName>, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling setCustomNames.');
            }
            // verify required parameter 'customNames' is not null or undefined
            if (customNames === null || customNames === undefined) {
                throw new RequiredError('customNames','Required parameter customNames was null or undefined when calling setCustomNames.');
            }
            const localVarPath = `/portfolios/{portfolioId}/customNames`
                .replace(`{${"portfolioId"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;CustomName&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customNames || {}) : (customNames || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a portfolio.
         * @param {string} id Portfolio id
         * @param {Operations} body JSON Patch Operations to update a portfolio.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolio(id: string, body: Operations, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePortfolio.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePortfolio.');
            }
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Operations" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update field values in a portfolio
         * @param {any} id Portfolio id
         * @param {Array<FieldValuePatchItem>} body JSON Patch Operations to update multiple field values.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioFieldValues(id: any, body: Array<FieldValuePatchItem>, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePortfolioFieldValues.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePortfolioFieldValues.');
            }
            const localVarPath = `/portfolios/{id}/fieldValues`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;FieldValuePatchItem&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary (Deprecated. Use updateResourcePoolBudgetAmountsForPortfolioPlan) Update resource pool budget amounts in a portfolio
         * @param {any} id Portfolio id
         * @param {Array<ResourcePoolBudgetAmountPatchItem>} body JSON Patch Operations to update multiple resource pool budget amounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioResourcePoolBudgetAmounts(id: any, body: Array<ResourcePoolBudgetAmountPatchItem>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePortfolioResourcePoolBudgetAmounts.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePortfolioResourcePoolBudgetAmounts.');
            }
            const localVarPath = `/portfolios/{id}/resourcePoolBudgetAmounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ResourcePoolBudgetAmountPatchItem&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the spreadsheet report for a portfolio
         * @param {string} portfolioId Portfolio id
         * @param {string} spreadsheetId Spreadsheet id
         * @param {string} sheetName Spreadsheet name
         * @param {Array<SpreadsheetField>} fields Spreadsheet fields
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpreadsheetReportForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, fields: Array<SpreadsheetField>, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling updateSpreadsheetReportForPortfolio.');
            }
            // verify required parameter 'spreadsheetId' is not null or undefined
            if (spreadsheetId === null || spreadsheetId === undefined) {
                throw new RequiredError('spreadsheetId','Required parameter spreadsheetId was null or undefined when calling updateSpreadsheetReportForPortfolio.');
            }
            // verify required parameter 'sheetName' is not null or undefined
            if (sheetName === null || sheetName === undefined) {
                throw new RequiredError('sheetName','Required parameter sheetName was null or undefined when calling updateSpreadsheetReportForPortfolio.');
            }
            // verify required parameter 'fields' is not null or undefined
            if (fields === null || fields === undefined) {
                throw new RequiredError('fields','Required parameter fields was null or undefined when calling updateSpreadsheetReportForPortfolio.');
            }
            const localVarPath = `/portfolios/{portfolioId}/spreadsheet/{spreadsheetId}/report`
                .replace(`{${"portfolioId"}}`, encodeURIComponent(String(portfolioId)))
                .replace(`{${"spreadsheetId"}}`, encodeURIComponent(String(spreadsheetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sheetName !== undefined) {
                localVarQueryParameter['sheetName'] = sheetName;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/merge-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;SpreadsheetField&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(fields || {}) : (fields || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfoliosApi - functional programming interface
 * @export
 */
export const PortfoliosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive a portfolio.
         * @param {string} id Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archivePortfolio(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Portfolio> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).archivePortfolio(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new portfolio.
         * @param {Portfolio} body Portfolio to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolio(body: Portfolio, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Portfolio> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).createPortfolio(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the spreadsheet report for a portfolio
         * @param {string} portfolioId Portfolio id
         * @param {string} spreadsheetId Spreadsheet id
         * @param {string} sheetName Spreadsheet name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpreadsheetReportForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpreadsheetReport> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).deleteSpreadsheetReportForPortfolio(portfolioId, spreadsheetId, sheetName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Download spreadsheet template for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSpreadsheetTemplate(portfolioId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).downloadSpreadsheetTemplate(portfolioId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Export portfolio data in JSON format
         * @param {string} id Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPortfolioData(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).exportPortfolioData(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves a portfolio.
         * @param {string} id Portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolio(id: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Portfolio> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).getPortfolio(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves portfolio activities log.
         * @param {string} id Portfolio id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioActivities(id: string, limit?: number, offset?: number, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Activities> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).getPortfolioActivities(id, limit, offset, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves portfolio plan users for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlanUsersForPortfolio(portfolioId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortfolioPlanUsers> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).getPortfolioPlanUsersForPortfolio(portfolioId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary (Deprecated. Use getResourcePoolsForPortfolioPlan) Retrieves resource pools in a portfolio.
         * @param {string} id Portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioResourcePools(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResourcePools> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).getPortfolioResourcePools(id, expand, limit, offset, orderBy, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get portfolios.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolios(expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Portfolios> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).getPortfolios(expand, limit, offset, orderBy, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves portfolios for specific user.
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfoliosForUser(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Portfolios> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).getPortfoliosForUser(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves projects for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForPortfolio(portfolioId: string, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Projects> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).getProjectsForPortfolio(portfolioId, limit, offset, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves spreadsheet report for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {string} spreadsheetId Spreadsheet id
         * @param {string} sheetName Spreadsheet name
         * @param {any} [importType] Import type
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpreadsheetReportForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, importType?: any, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpreadsheetReport> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).getSpreadsheetReportForPortfolio(portfolioId, spreadsheetId, sheetName, importType, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Import portfolio data in JSON format
         * @param {string} id Portfolio id
         * @param {any} [podFile] The pod file to upload.
         * @param {string} [templateName] pod template name to load
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importPortfolioData(id: string, podFile?: any, templateName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Portfolio> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).importPortfolioData(id, podFile, templateName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Generates a new registration token
         * @param {string} id Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateUserRegistrationToken(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Portfolio> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).regenerateUserRegistrationToken(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Saves spreadsheet for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {string} spreadsheetId Spreadsheet id
         * @param {string} sheetName Spreadsheet name
         * @param {any} [importType] Import type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSpreadsheetForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, importType?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpreadsheetReport> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).saveSpreadsheetForPortfolio(portfolioId, spreadsheetId, sheetName, importType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Save spreadsheet source for a portfolio
         * @param {string} id Portfolio id
         * @param {any} file 
         * @param {string} [sheetName] Spreadsheet name. Defaults to first sheet.
         * @param {any} [importType] Import type. Defaults to PROJECT.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSpreadsheetSourceForPortfolio(id: string, file: any, sheetName?: string, importType?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Source> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).saveSpreadsheetSourceForPortfolio(id, file, sheetName, importType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates custom names for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {Array<CustomName>} customNames Custom names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomNames(portfolioId: string, customNames: Array<CustomName>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomName>> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).setCustomNames(portfolioId, customNames, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a portfolio.
         * @param {string} id Portfolio id
         * @param {Operations} body JSON Patch Operations to update a portfolio.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolio(id: string, body: Operations, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Portfolio> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).updatePortfolio(id, body, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update field values in a portfolio
         * @param {any} id Portfolio id
         * @param {Array<FieldValuePatchItem>} body JSON Patch Operations to update multiple field values.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioFieldValues(id: any, body: Array<FieldValuePatchItem>, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FieldValue>> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).updatePortfolioFieldValues(id, body, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary (Deprecated. Use updateResourcePoolBudgetAmountsForPortfolioPlan) Update resource pool budget amounts in a portfolio
         * @param {any} id Portfolio id
         * @param {Array<ResourcePoolBudgetAmountPatchItem>} body JSON Patch Operations to update multiple resource pool budget amounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioResourcePoolBudgetAmounts(id: any, body: Array<ResourcePoolBudgetAmountPatchItem>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ResourcePool>> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).updatePortfolioResourcePoolBudgetAmounts(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the spreadsheet report for a portfolio
         * @param {string} portfolioId Portfolio id
         * @param {string} spreadsheetId Spreadsheet id
         * @param {string} sheetName Spreadsheet name
         * @param {Array<SpreadsheetField>} fields Spreadsheet fields
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpreadsheetReportForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, fields: Array<SpreadsheetField>, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpreadsheetReport> {
            const localVarFetchArgs = PortfoliosApiFetchParamCreator(configuration).updateSpreadsheetReportForPortfolio(portfolioId, spreadsheetId, sheetName, fields, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PortfoliosApi - factory interface
 * @export
 */
export const PortfoliosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Archive a portfolio.
         * @param {string} id Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archivePortfolio(id: string, options?: any) {
            return PortfoliosApiFp(configuration).archivePortfolio(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new portfolio.
         * @param {Portfolio} body Portfolio to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolio(body: Portfolio, options?: any) {
            return PortfoliosApiFp(configuration).createPortfolio(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the spreadsheet report for a portfolio
         * @param {string} portfolioId Portfolio id
         * @param {string} spreadsheetId Spreadsheet id
         * @param {string} sheetName Spreadsheet name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpreadsheetReportForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, options?: any) {
            return PortfoliosApiFp(configuration).deleteSpreadsheetReportForPortfolio(portfolioId, spreadsheetId, sheetName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Download spreadsheet template for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSpreadsheetTemplate(portfolioId: string, options?: any) {
            return PortfoliosApiFp(configuration).downloadSpreadsheetTemplate(portfolioId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Export portfolio data in JSON format
         * @param {string} id Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPortfolioData(id: string, options?: any) {
            return PortfoliosApiFp(configuration).exportPortfolioData(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves a portfolio.
         * @param {string} id Portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolio(id: string, expand?: string, options?: any) {
            return PortfoliosApiFp(configuration).getPortfolio(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves portfolio activities log.
         * @param {string} id Portfolio id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioActivities(id: string, limit?: number, offset?: number, match?: string, options?: any) {
            return PortfoliosApiFp(configuration).getPortfolioActivities(id, limit, offset, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves portfolio plan users for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlanUsersForPortfolio(portfolioId: string, options?: any) {
            return PortfoliosApiFp(configuration).getPortfolioPlanUsersForPortfolio(portfolioId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary (Deprecated. Use getResourcePoolsForPortfolioPlan) Retrieves resource pools in a portfolio.
         * @param {string} id Portfolio id
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioResourcePools(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
            return PortfoliosApiFp(configuration).getPortfolioResourcePools(id, expand, limit, offset, orderBy, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get portfolios.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolios(expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
            return PortfoliosApiFp(configuration).getPortfolios(expand, limit, offset, orderBy, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves portfolios for specific user.
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfoliosForUser(id: string, options?: any) {
            return PortfoliosApiFp(configuration).getPortfoliosForUser(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves projects for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForPortfolio(portfolioId: string, limit?: number, offset?: number, options?: any) {
            return PortfoliosApiFp(configuration).getProjectsForPortfolio(portfolioId, limit, offset, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves spreadsheet report for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {string} spreadsheetId Spreadsheet id
         * @param {string} sheetName Spreadsheet name
         * @param {any} [importType] Import type
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpreadsheetReportForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, importType?: any, expand?: string, options?: any) {
            return PortfoliosApiFp(configuration).getSpreadsheetReportForPortfolio(portfolioId, spreadsheetId, sheetName, importType, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Import portfolio data in JSON format
         * @param {string} id Portfolio id
         * @param {any} [podFile] The pod file to upload.
         * @param {string} [templateName] pod template name to load
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importPortfolioData(id: string, podFile?: any, templateName?: string, options?: any) {
            return PortfoliosApiFp(configuration).importPortfolioData(id, podFile, templateName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Generates a new registration token
         * @param {string} id Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateUserRegistrationToken(id: string, options?: any) {
            return PortfoliosApiFp(configuration).regenerateUserRegistrationToken(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Saves spreadsheet for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {string} spreadsheetId Spreadsheet id
         * @param {string} sheetName Spreadsheet name
         * @param {any} [importType] Import type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSpreadsheetForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, importType?: any, options?: any) {
            return PortfoliosApiFp(configuration).saveSpreadsheetForPortfolio(portfolioId, spreadsheetId, sheetName, importType, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Save spreadsheet source for a portfolio
         * @param {string} id Portfolio id
         * @param {any} file 
         * @param {string} [sheetName] Spreadsheet name. Defaults to first sheet.
         * @param {any} [importType] Import type. Defaults to PROJECT.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSpreadsheetSourceForPortfolio(id: string, file: any, sheetName?: string, importType?: any, options?: any) {
            return PortfoliosApiFp(configuration).saveSpreadsheetSourceForPortfolio(id, file, sheetName, importType, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates custom names for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {Array<CustomName>} customNames Custom names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomNames(portfolioId: string, customNames: Array<CustomName>, options?: any) {
            return PortfoliosApiFp(configuration).setCustomNames(portfolioId, customNames, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a portfolio.
         * @param {string} id Portfolio id
         * @param {Operations} body JSON Patch Operations to update a portfolio.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolio(id: string, body: Operations, expand?: string, options?: any) {
            return PortfoliosApiFp(configuration).updatePortfolio(id, body, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update field values in a portfolio
         * @param {any} id Portfolio id
         * @param {Array<FieldValuePatchItem>} body JSON Patch Operations to update multiple field values.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioFieldValues(id: any, body: Array<FieldValuePatchItem>, expand?: string, options?: any) {
            return PortfoliosApiFp(configuration).updatePortfolioFieldValues(id, body, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary (Deprecated. Use updateResourcePoolBudgetAmountsForPortfolioPlan) Update resource pool budget amounts in a portfolio
         * @param {any} id Portfolio id
         * @param {Array<ResourcePoolBudgetAmountPatchItem>} body JSON Patch Operations to update multiple resource pool budget amounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioResourcePoolBudgetAmounts(id: any, body: Array<ResourcePoolBudgetAmountPatchItem>, options?: any) {
            return PortfoliosApiFp(configuration).updatePortfolioResourcePoolBudgetAmounts(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the spreadsheet report for a portfolio
         * @param {string} portfolioId Portfolio id
         * @param {string} spreadsheetId Spreadsheet id
         * @param {string} sheetName Spreadsheet name
         * @param {Array<SpreadsheetField>} fields Spreadsheet fields
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpreadsheetReportForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, fields: Array<SpreadsheetField>, expand?: string, options?: any) {
            return PortfoliosApiFp(configuration).updateSpreadsheetReportForPortfolio(portfolioId, spreadsheetId, sheetName, fields, expand, options)(fetch, basePath);
        },
    };
};

/**
 * PortfoliosApi - object-oriented interface
 * @export
 * @class PortfoliosApi
 * @extends {BaseAPI}
 */
export class PortfoliosApi extends BaseAPI {
    /**
     * 
     * @summary Archive a portfolio.
     * @param {string} id Portfolio id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public archivePortfolio(id: string, options?: any) {
        return PortfoliosApiFp(this.configuration).archivePortfolio(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new portfolio.
     * @param {Portfolio} body Portfolio to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public createPortfolio(body: Portfolio, options?: any) {
        return PortfoliosApiFp(this.configuration).createPortfolio(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the spreadsheet report for a portfolio
     * @param {string} portfolioId Portfolio id
     * @param {string} spreadsheetId Spreadsheet id
     * @param {string} sheetName Spreadsheet name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public deleteSpreadsheetReportForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, options?: any) {
        return PortfoliosApiFp(this.configuration).deleteSpreadsheetReportForPortfolio(portfolioId, spreadsheetId, sheetName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Download spreadsheet template for portfolio
     * @param {string} portfolioId Portfolio id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public downloadSpreadsheetTemplate(portfolioId: string, options?: any) {
        return PortfoliosApiFp(this.configuration).downloadSpreadsheetTemplate(portfolioId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Export portfolio data in JSON format
     * @param {string} id Portfolio id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public exportPortfolioData(id: string, options?: any) {
        return PortfoliosApiFp(this.configuration).exportPortfolioData(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves a portfolio.
     * @param {string} id Portfolio id
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public getPortfolio(id: string, expand?: string, options?: any) {
        return PortfoliosApiFp(this.configuration).getPortfolio(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves portfolio activities log.
     * @param {string} id Portfolio id
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public getPortfolioActivities(id: string, limit?: number, offset?: number, match?: string, options?: any) {
        return PortfoliosApiFp(this.configuration).getPortfolioActivities(id, limit, offset, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves portfolio plan users for portfolio
     * @param {string} portfolioId Portfolio id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public getPortfolioPlanUsersForPortfolio(portfolioId: string, options?: any) {
        return PortfoliosApiFp(this.configuration).getPortfolioPlanUsersForPortfolio(portfolioId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary (Deprecated. Use getResourcePoolsForPortfolioPlan) Retrieves resource pools in a portfolio.
     * @param {string} id Portfolio id
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public getPortfolioResourcePools(id: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
        return PortfoliosApiFp(this.configuration).getPortfolioResourcePools(id, expand, limit, offset, orderBy, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get portfolios.
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public getPortfolios(expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
        return PortfoliosApiFp(this.configuration).getPortfolios(expand, limit, offset, orderBy, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves portfolios for specific user.
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public getPortfoliosForUser(id: string, options?: any) {
        return PortfoliosApiFp(this.configuration).getPortfoliosForUser(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves projects for portfolio
     * @param {string} portfolioId Portfolio id
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public getProjectsForPortfolio(portfolioId: string, limit?: number, offset?: number, options?: any) {
        return PortfoliosApiFp(this.configuration).getProjectsForPortfolio(portfolioId, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves spreadsheet report for portfolio
     * @param {string} portfolioId Portfolio id
     * @param {string} spreadsheetId Spreadsheet id
     * @param {string} sheetName Spreadsheet name
     * @param {any} [importType] Import type
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public getSpreadsheetReportForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, importType?: any, expand?: string, options?: any) {
        return PortfoliosApiFp(this.configuration).getSpreadsheetReportForPortfolio(portfolioId, spreadsheetId, sheetName, importType, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Import portfolio data in JSON format
     * @param {string} id Portfolio id
     * @param {any} [podFile] The pod file to upload.
     * @param {string} [templateName] pod template name to load
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public importPortfolioData(id: string, podFile?: any, templateName?: string, options?: any) {
        return PortfoliosApiFp(this.configuration).importPortfolioData(id, podFile, templateName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Generates a new registration token
     * @param {string} id Portfolio id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public regenerateUserRegistrationToken(id: string, options?: any) {
        return PortfoliosApiFp(this.configuration).regenerateUserRegistrationToken(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Saves spreadsheet for portfolio
     * @param {string} portfolioId Portfolio id
     * @param {string} spreadsheetId Spreadsheet id
     * @param {string} sheetName Spreadsheet name
     * @param {any} [importType] Import type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public saveSpreadsheetForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, importType?: any, options?: any) {
        return PortfoliosApiFp(this.configuration).saveSpreadsheetForPortfolio(portfolioId, spreadsheetId, sheetName, importType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Save spreadsheet source for a portfolio
     * @param {string} id Portfolio id
     * @param {any} file 
     * @param {string} [sheetName] Spreadsheet name. Defaults to first sheet.
     * @param {any} [importType] Import type. Defaults to PROJECT.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public saveSpreadsheetSourceForPortfolio(id: string, file: any, sheetName?: string, importType?: any, options?: any) {
        return PortfoliosApiFp(this.configuration).saveSpreadsheetSourceForPortfolio(id, file, sheetName, importType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates custom names for portfolio
     * @param {string} portfolioId Portfolio id
     * @param {Array<CustomName>} customNames Custom names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public setCustomNames(portfolioId: string, customNames: Array<CustomName>, options?: any) {
        return PortfoliosApiFp(this.configuration).setCustomNames(portfolioId, customNames, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a portfolio.
     * @param {string} id Portfolio id
     * @param {Operations} body JSON Patch Operations to update a portfolio.
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public updatePortfolio(id: string, body: Operations, expand?: string, options?: any) {
        return PortfoliosApiFp(this.configuration).updatePortfolio(id, body, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update field values in a portfolio
     * @param {any} id Portfolio id
     * @param {Array<FieldValuePatchItem>} body JSON Patch Operations to update multiple field values.
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public updatePortfolioFieldValues(id: any, body: Array<FieldValuePatchItem>, expand?: string, options?: any) {
        return PortfoliosApiFp(this.configuration).updatePortfolioFieldValues(id, body, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary (Deprecated. Use updateResourcePoolBudgetAmountsForPortfolioPlan) Update resource pool budget amounts in a portfolio
     * @param {any} id Portfolio id
     * @param {Array<ResourcePoolBudgetAmountPatchItem>} body JSON Patch Operations to update multiple resource pool budget amounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public updatePortfolioResourcePoolBudgetAmounts(id: any, body: Array<ResourcePoolBudgetAmountPatchItem>, options?: any) {
        return PortfoliosApiFp(this.configuration).updatePortfolioResourcePoolBudgetAmounts(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the spreadsheet report for a portfolio
     * @param {string} portfolioId Portfolio id
     * @param {string} spreadsheetId Spreadsheet id
     * @param {string} sheetName Spreadsheet name
     * @param {Array<SpreadsheetField>} fields Spreadsheet fields
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfoliosApi
     */
    public updateSpreadsheetReportForPortfolio(portfolioId: string, spreadsheetId: string, sheetName: string, fields: Array<SpreadsheetField>, expand?: string, options?: any) {
        return PortfoliosApiFp(this.configuration).updateSpreadsheetReportForPortfolio(portfolioId, spreadsheetId, sheetName, fields, expand, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectsApi - fetch parameter creator
 * @export
 */
export const ProjectsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add users to a project.
         * @param {string} id project id
         * @param {AddUsersRequest} [body] Email ids and personal message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContributingUsersForProject(id: string, body?: AddUsersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addContributingUsersForProject.');
            }
            const localVarPath = `/projects/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddUsersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a copy of the project, including portfolio data, dependencies, attachments
         * @param {string} id project id
         * @param {Project} [body] Info to be included in the new project copy; only name will suffice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyProject(id: string, body?: Project, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling copyProject.');
            }
            const localVarPath = `/projects/{id}/copy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new project.
         * @param {string} portfolioId Portfolio id
         * @param {Project} project Project to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(portfolioId: string, project: Project, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling createProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createProject.');
            }
            const localVarPath = `/projects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(project || {}) : (project || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes all field values for a certain fields for a particular project
         * @param {string} id project id
         * @param {Array<string>} fieldIds field ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFieldValuesForProject(id: string, fieldIds: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFieldValuesForProject.');
            }
            // verify required parameter 'fieldIds' is not null or undefined
            if (fieldIds === null || fieldIds === undefined) {
                throw new RequiredError('fieldIds','Required parameter fieldIds was null or undefined when calling deleteFieldValuesForProject.');
            }
            const localVarPath = `/projects/{id}/fieldValues`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (fieldIds) {
                localVarQueryParameter['fieldIds'] = fieldIds.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a project.
         * @param {string} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProject.');
            }
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete projects.
         * @param {Array<string>} projectIds Project ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjects(projectIds: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'projectIds' is not null or undefined
            if (projectIds === null || projectIds === undefined) {
                throw new RequiredError('projectIds','Required parameter projectIds was null or undefined when calling deleteProjects.');
            }
            const localVarPath = `/projects/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(projectIds || {}) : (projectIds || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a project.
         * @param {string} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProject.');
            }
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a project for a portfolioPlan.
         * @param {string} projectId Project id
         * @param {string} portfolioPlanId PortfolioPlan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectForPortfolioPlan(projectId: string, portfolioPlanId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling getProjectForPortfolioPlan.');
            }
            // verify required parameter 'portfolioPlanId' is not null or undefined
            if (portfolioPlanId === null || portfolioPlanId === undefined) {
                throw new RequiredError('portfolioPlanId','Required parameter portfolioPlanId was null or undefined when calling getProjectForPortfolioPlan.');
            }
            const localVarPath = `/projects/{projectId}/portfolioPlan/{portfolioPlanId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"portfolioPlanId"}}`, encodeURIComponent(String(portfolioPlanId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch project data for portfolio and data id.
         * @param {string} portfolioId Portfolio Id
         * @param {string} dataId Data Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsDataForPortfolio(portfolioId: string, dataId: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getProjectsDataForPortfolio.');
            }
            // verify required parameter 'dataId' is not null or undefined
            if (dataId === null || dataId === undefined) {
                throw new RequiredError('dataId','Required parameter dataId was null or undefined when calling getProjectsDataForPortfolio.');
            }
            const localVarPath = `/projects/data`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            if (dataId !== undefined) {
                localVarQueryParameter['dataId'] = dataId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves projects contained within a portfolio. Possible expand paths are - (items.fieldValues, contributingUserIds)
         * @param {string} portfolioId Portfolio id
         * @param {string} [portfolioPlanId] Portfolio plan id. If not specified the portfolio plan will default to current baseline
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForPortfolio(portfolioId: string, portfolioPlanId?: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getProjectsForPortfolio.');
            }
            const localVarPath = `/projects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            if (portfolioPlanId !== undefined) {
                localVarQueryParameter['portfolioPlanId'] = portfolioPlanId;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove contributing users from a project.
         * @param {string} id project id
         * @param {RemoveContributingUsersRequest} body contributing user ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContributingUsersFromProject(id: string, body: RemoveContributingUsersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removeContributingUsersFromProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling removeContributingUsersFromProject.');
            }
            const localVarPath = `/projects/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RemoveContributingUsersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds or removes dependsOn and/or dependant linked projects to a project.
         * @param {string} id project id
         * @param {SetDependenciesRequest} [body] dependsOn and hasDependent project Ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProjectDependencies(id: string, body?: SetDependenciesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setProjectDependencies.');
            }
            const localVarPath = `/projects/{id}/dependencies`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SetDependenciesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add users to a project.
         * @param {string} id project id
         * @param {AddUsersRequest} [body] Email ids and personal message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContributingUsersForProject(id: string, body?: AddUsersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortfolioPlanUser>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).addContributingUsersForProject(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a copy of the project, including portfolio data, dependencies, attachments
         * @param {string} id project id
         * @param {Project} [body] Info to be included in the new project copy; only name will suffice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyProject(id: string, body?: Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).copyProject(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new project.
         * @param {string} portfolioId Portfolio id
         * @param {Project} project Project to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(portfolioId: string, project: Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).createProject(portfolioId, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes all field values for a certain fields for a particular project
         * @param {string} id project id
         * @param {Array<string>} fieldIds field ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFieldValuesForProject(id: string, fieldIds: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).deleteFieldValuesForProject(id, fieldIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a project.
         * @param {string} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).deleteProject(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete projects.
         * @param {Array<string>} projectIds Project ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjects(projectIds: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).deleteProjects(projectIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves a project.
         * @param {string} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProject(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves a project for a portfolioPlan.
         * @param {string} projectId Project id
         * @param {string} portfolioPlanId PortfolioPlan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectForPortfolioPlan(projectId: string, portfolioPlanId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectForPortfolioPlan(projectId, portfolioPlanId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Fetch project data for portfolio and data id.
         * @param {string} portfolioId Portfolio Id
         * @param {string} dataId Data Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsDataForPortfolio(portfolioId: string, dataId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MinifiedProjects> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectsDataForPortfolio(portfolioId, dataId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves projects contained within a portfolio. Possible expand paths are - (items.fieldValues, contributingUserIds)
         * @param {string} portfolioId Portfolio id
         * @param {string} [portfolioPlanId] Portfolio plan id. If not specified the portfolio plan will default to current baseline
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForPortfolio(portfolioId: string, portfolioPlanId?: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Projects> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectsForPortfolio(portfolioId, portfolioPlanId, expand, limit, offset, orderBy, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove contributing users from a project.
         * @param {string} id project id
         * @param {RemoveContributingUsersRequest} body contributing user ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContributingUsersFromProject(id: string, body: RemoveContributingUsersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).removeContributingUsersFromProject(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds or removes dependsOn and/or dependant linked projects to a project.
         * @param {string} id project id
         * @param {SetDependenciesRequest} [body] dependsOn and hasDependent project Ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProjectDependencies(id: string, body?: SetDependenciesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Projects> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).setProjectDependencies(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add users to a project.
         * @param {string} id project id
         * @param {AddUsersRequest} [body] Email ids and personal message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContributingUsersForProject(id: string, body?: AddUsersRequest, options?: any) {
            return ProjectsApiFp(configuration).addContributingUsersForProject(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a copy of the project, including portfolio data, dependencies, attachments
         * @param {string} id project id
         * @param {Project} [body] Info to be included in the new project copy; only name will suffice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyProject(id: string, body?: Project, options?: any) {
            return ProjectsApiFp(configuration).copyProject(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new project.
         * @param {string} portfolioId Portfolio id
         * @param {Project} project Project to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(portfolioId: string, project: Project, options?: any) {
            return ProjectsApiFp(configuration).createProject(portfolioId, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all field values for a certain fields for a particular project
         * @param {string} id project id
         * @param {Array<string>} fieldIds field ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFieldValuesForProject(id: string, fieldIds: Array<string>, options?: any) {
            return ProjectsApiFp(configuration).deleteFieldValuesForProject(id, fieldIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a project.
         * @param {string} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(id: string, options?: any) {
            return ProjectsApiFp(configuration).deleteProject(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete projects.
         * @param {Array<string>} projectIds Project ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjects(projectIds: Array<string>, options?: any) {
            return ProjectsApiFp(configuration).deleteProjects(projectIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves a project.
         * @param {string} id Project id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(id: string, options?: any) {
            return ProjectsApiFp(configuration).getProject(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves a project for a portfolioPlan.
         * @param {string} projectId Project id
         * @param {string} portfolioPlanId PortfolioPlan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectForPortfolioPlan(projectId: string, portfolioPlanId: string, options?: any) {
            return ProjectsApiFp(configuration).getProjectForPortfolioPlan(projectId, portfolioPlanId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetch project data for portfolio and data id.
         * @param {string} portfolioId Portfolio Id
         * @param {string} dataId Data Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsDataForPortfolio(portfolioId: string, dataId: string, options?: any) {
            return ProjectsApiFp(configuration).getProjectsDataForPortfolio(portfolioId, dataId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves projects contained within a portfolio. Possible expand paths are - (items.fieldValues, contributingUserIds)
         * @param {string} portfolioId Portfolio id
         * @param {string} [portfolioPlanId] Portfolio plan id. If not specified the portfolio plan will default to current baseline
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForPortfolio(portfolioId: string, portfolioPlanId?: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
            return ProjectsApiFp(configuration).getProjectsForPortfolio(portfolioId, portfolioPlanId, expand, limit, offset, orderBy, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove contributing users from a project.
         * @param {string} id project id
         * @param {RemoveContributingUsersRequest} body contributing user ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContributingUsersFromProject(id: string, body: RemoveContributingUsersRequest, options?: any) {
            return ProjectsApiFp(configuration).removeContributingUsersFromProject(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds or removes dependsOn and/or dependant linked projects to a project.
         * @param {string} id project id
         * @param {SetDependenciesRequest} [body] dependsOn and hasDependent project Ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProjectDependencies(id: string, body?: SetDependenciesRequest, options?: any) {
            return ProjectsApiFp(configuration).setProjectDependencies(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Add users to a project.
     * @param {string} id project id
     * @param {AddUsersRequest} [body] Email ids and personal message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public addContributingUsersForProject(id: string, body?: AddUsersRequest, options?: any) {
        return ProjectsApiFp(this.configuration).addContributingUsersForProject(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a copy of the project, including portfolio data, dependencies, attachments
     * @param {string} id project id
     * @param {Project} [body] Info to be included in the new project copy; only name will suffice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public copyProject(id: string, body?: Project, options?: any) {
        return ProjectsApiFp(this.configuration).copyProject(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new project.
     * @param {string} portfolioId Portfolio id
     * @param {Project} project Project to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(portfolioId: string, project: Project, options?: any) {
        return ProjectsApiFp(this.configuration).createProject(portfolioId, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes all field values for a certain fields for a particular project
     * @param {string} id project id
     * @param {Array<string>} fieldIds field ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteFieldValuesForProject(id: string, fieldIds: Array<string>, options?: any) {
        return ProjectsApiFp(this.configuration).deleteFieldValuesForProject(id, fieldIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a project.
     * @param {string} id Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(id: string, options?: any) {
        return ProjectsApiFp(this.configuration).deleteProject(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete projects.
     * @param {Array<string>} projectIds Project ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProjects(projectIds: Array<string>, options?: any) {
        return ProjectsApiFp(this.configuration).deleteProjects(projectIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves a project.
     * @param {string} id Project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(id: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProject(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves a project for a portfolioPlan.
     * @param {string} projectId Project id
     * @param {string} portfolioPlanId PortfolioPlan id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectForPortfolioPlan(projectId: string, portfolioPlanId: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectForPortfolioPlan(projectId, portfolioPlanId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Fetch project data for portfolio and data id.
     * @param {string} portfolioId Portfolio Id
     * @param {string} dataId Data Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectsDataForPortfolio(portfolioId: string, dataId: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectsDataForPortfolio(portfolioId, dataId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves projects contained within a portfolio. Possible expand paths are - (items.fieldValues, contributingUserIds)
     * @param {string} portfolioId Portfolio id
     * @param {string} [portfolioPlanId] Portfolio plan id. If not specified the portfolio plan will default to current baseline
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectsForPortfolio(portfolioId: string, portfolioPlanId?: string, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectsForPortfolio(portfolioId, portfolioPlanId, expand, limit, offset, orderBy, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove contributing users from a project.
     * @param {string} id project id
     * @param {RemoveContributingUsersRequest} body contributing user ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public removeContributingUsersFromProject(id: string, body: RemoveContributingUsersRequest, options?: any) {
        return ProjectsApiFp(this.configuration).removeContributingUsersFromProject(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds or removes dependsOn and/or dependant linked projects to a project.
     * @param {string} id project id
     * @param {SetDependenciesRequest} [body] dependsOn and hasDependent project Ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public setProjectDependencies(id: string, body?: SetDependenciesRequest, options?: any) {
        return ProjectsApiFp(this.configuration).setProjectDependencies(id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * PropertiesApi - fetch parameter creator
 * @export
 */
export const PropertiesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get configuration properties for user if userId and groupId are present, otherwise properties for authenticated user will be returned
         * @param {string} [userId] User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProperties(userId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/properties`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set configuration properties
         * @param {Array<Property>} body Properties that needed to be created/updated for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProperties(body: Array<Property>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setProperties.');
            }
            const localVarPath = `/properties`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Property&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertiesApi - functional programming interface
 * @export
 */
export const PropertiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get configuration properties for user if userId and groupId are present, otherwise properties for authenticated user will be returned
         * @param {string} [userId] User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProperties(userId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Properties> {
            const localVarFetchArgs = PropertiesApiFetchParamCreator(configuration).getProperties(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set configuration properties
         * @param {Array<Property>} body Properties that needed to be created/updated for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProperties(body: Array<Property>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Property>> {
            const localVarFetchArgs = PropertiesApiFetchParamCreator(configuration).setProperties(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PropertiesApi - factory interface
 * @export
 */
export const PropertiesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get configuration properties for user if userId and groupId are present, otherwise properties for authenticated user will be returned
         * @param {string} [userId] User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProperties(userId?: string, options?: any) {
            return PropertiesApiFp(configuration).getProperties(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set configuration properties
         * @param {Array<Property>} body Properties that needed to be created/updated for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProperties(body: Array<Property>, options?: any) {
            return PropertiesApiFp(configuration).setProperties(body, options)(fetch, basePath);
        },
    };
};

/**
 * PropertiesApi - object-oriented interface
 * @export
 * @class PropertiesApi
 * @extends {BaseAPI}
 */
export class PropertiesApi extends BaseAPI {
    /**
     * 
     * @summary Get configuration properties for user if userId and groupId are present, otherwise properties for authenticated user will be returned
     * @param {string} [userId] User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public getProperties(userId?: string, options?: any) {
        return PropertiesApiFp(this.configuration).getProperties(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set configuration properties
     * @param {Array<Property>} body Properties that needed to be created/updated for the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public setProperties(body: Array<Property>, options?: any) {
        return PropertiesApiFp(this.configuration).setProperties(body, options)(this.fetch, this.basePath);
    }

}

/**
 * RegistrationApi - fetch parameter creator
 * @export
 */
export const RegistrationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register Portfolio User
         * @param {RegisterUserRequest} registerUserRequest Register user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPortfolioUser(registerUserRequest: RegisterUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'registerUserRequest' is not null or undefined
            if (registerUserRequest === null || registerUserRequest === undefined) {
                throw new RequiredError('registerUserRequest','Required parameter registerUserRequest was null or undefined when calling registerPortfolioUser.');
            }
            const localVarPath = `/registerPortfolioUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegisterUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(registerUserRequest || {}) : (registerUserRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register User
         * @param {RegisterUserRequest} registerUserRequest Register user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(registerUserRequest: RegisterUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'registerUserRequest' is not null or undefined
            if (registerUserRequest === null || registerUserRequest === undefined) {
                throw new RequiredError('registerUserRequest','Required parameter registerUserRequest was null or undefined when calling registerUser.');
            }
            const localVarPath = `/registerUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegisterUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(registerUserRequest || {}) : (registerUserRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistrationApi - functional programming interface
 * @export
 */
export const RegistrationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register Portfolio User
         * @param {RegisterUserRequest} registerUserRequest Register user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPortfolioUser(registerUserRequest: RegisterUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortfolioPlanUser> {
            const localVarFetchArgs = RegistrationApiFetchParamCreator(configuration).registerPortfolioUser(registerUserRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Register User
         * @param {RegisterUserRequest} registerUserRequest Register user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(registerUserRequest: RegisterUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = RegistrationApiFetchParamCreator(configuration).registerUser(registerUserRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RegistrationApi - factory interface
 * @export
 */
export const RegistrationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Register Portfolio User
         * @param {RegisterUserRequest} registerUserRequest Register user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPortfolioUser(registerUserRequest: RegisterUserRequest, options?: any) {
            return RegistrationApiFp(configuration).registerPortfolioUser(registerUserRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Register User
         * @param {RegisterUserRequest} registerUserRequest Register user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(registerUserRequest: RegisterUserRequest, options?: any) {
            return RegistrationApiFp(configuration).registerUser(registerUserRequest, options)(fetch, basePath);
        },
    };
};

/**
 * RegistrationApi - object-oriented interface
 * @export
 * @class RegistrationApi
 * @extends {BaseAPI}
 */
export class RegistrationApi extends BaseAPI {
    /**
     * 
     * @summary Register Portfolio User
     * @param {RegisterUserRequest} registerUserRequest Register user request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    public registerPortfolioUser(registerUserRequest: RegisterUserRequest, options?: any) {
        return RegistrationApiFp(this.configuration).registerPortfolioUser(registerUserRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Register User
     * @param {RegisterUserRequest} registerUserRequest Register user request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    public registerUser(registerUserRequest: RegisterUserRequest, options?: any) {
        return RegistrationApiFp(this.configuration).registerUser(registerUserRequest, options)(this.fetch, this.basePath);
    }

}

/**
 * ReportsApi - fetch parameter creator
 * @export
 */
export const ReportsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Downloads the grades report for a portfolio plan
         * @param {string} id Portfolio Plan id
         * @param {number} [startDate] Start time period for which the grades are computed for.
         * @param {number} [endDate] End time period for which the grades are computed for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlanGradesReport(id: string, startDate?: number, endDate?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPortfolioPlanGradesReport.');
            }
            const localVarPath = `/portfolioPlans/{id}/grades/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Downloads the grades report for a portfolio plan
         * @param {string} id Portfolio Plan id
         * @param {number} [startDate] Start time period for which the grades are computed for.
         * @param {number} [endDate] End time period for which the grades are computed for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlanGradesReport(id: string, startDate?: number, endDate?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ReportsApiFetchParamCreator(configuration).getPortfolioPlanGradesReport(id, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Downloads the grades report for a portfolio plan
         * @param {string} id Portfolio Plan id
         * @param {number} [startDate] Start time period for which the grades are computed for.
         * @param {number} [endDate] End time period for which the grades are computed for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPlanGradesReport(id: string, startDate?: number, endDate?: number, options?: any) {
            return ReportsApiFp(configuration).getPortfolioPlanGradesReport(id, startDate, endDate, options)(fetch, basePath);
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * 
     * @summary Downloads the grades report for a portfolio plan
     * @param {string} id Portfolio Plan id
     * @param {number} [startDate] Start time period for which the grades are computed for.
     * @param {number} [endDate] End time period for which the grades are computed for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getPortfolioPlanGradesReport(id: string, startDate?: number, endDate?: number, options?: any) {
        return ReportsApiFp(this.configuration).getPortfolioPlanGradesReport(id, startDate, endDate, options)(this.fetch, this.basePath);
    }

}

/**
 * ResourcePoolsApi - fetch parameter creator
 * @export
 */
export const ResourcePoolsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves a resource pool.
         * @param {string} id Resource Pool id
         * @param {string} [portfolioPlanId] Portfolio Plan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePool(id: string, portfolioPlanId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getResourcePool.');
            }
            const localVarPath = `/resourcePools/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioPlanId !== undefined) {
                localVarQueryParameter['portfolioPlanId'] = portfolioPlanId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch resource pools for portfolio plan
         * @param {string} portfolioPlanId Portfolio Plan id
         * @param {boolean} [planOverridesOnly] Returns only plan overrides. default is false.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePoolsForPortfolioPlan(portfolioPlanId: string, planOverridesOnly?: boolean, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioPlanId' is not null or undefined
            if (portfolioPlanId === null || portfolioPlanId === undefined) {
                throw new RequiredError('portfolioPlanId','Required parameter portfolioPlanId was null or undefined when calling getResourcePoolsForPortfolioPlan.');
            }
            const localVarPath = `/resourcePools`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioPlanId !== undefined) {
                localVarQueryParameter['portfolioPlanId'] = portfolioPlanId;
            }

            if (planOverridesOnly !== undefined) {
                localVarQueryParameter['planOverridesOnly'] = planOverridesOnly;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update resource pool budget amounts in a portfolio plan
         * @param {string} portfolioPlanId Portfolio Plan id
         * @param {Array<ResourcePoolBudgetAmountPatchItem>} body JSON Patch Operations to update multiple resource pool budget amounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourcePoolBudgetAmountsForPortfolioPlan(portfolioPlanId: string, body: Array<ResourcePoolBudgetAmountPatchItem>, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioPlanId' is not null or undefined
            if (portfolioPlanId === null || portfolioPlanId === undefined) {
                throw new RequiredError('portfolioPlanId','Required parameter portfolioPlanId was null or undefined when calling updateResourcePoolBudgetAmountsForPortfolioPlan.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateResourcePoolBudgetAmountsForPortfolioPlan.');
            }
            const localVarPath = `/resourcePools`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioPlanId !== undefined) {
                localVarQueryParameter['portfolioPlanId'] = portfolioPlanId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ResourcePoolBudgetAmountPatchItem&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourcePoolsApi - functional programming interface
 * @export
 */
export const ResourcePoolsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves a resource pool.
         * @param {string} id Resource Pool id
         * @param {string} [portfolioPlanId] Portfolio Plan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePool(id: string, portfolioPlanId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResourcePool> {
            const localVarFetchArgs = ResourcePoolsApiFetchParamCreator(configuration).getResourcePool(id, portfolioPlanId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Fetch resource pools for portfolio plan
         * @param {string} portfolioPlanId Portfolio Plan id
         * @param {boolean} [planOverridesOnly] Returns only plan overrides. default is false.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePoolsForPortfolioPlan(portfolioPlanId: string, planOverridesOnly?: boolean, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResourcePools> {
            const localVarFetchArgs = ResourcePoolsApiFetchParamCreator(configuration).getResourcePoolsForPortfolioPlan(portfolioPlanId, planOverridesOnly, expand, limit, offset, orderBy, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update resource pool budget amounts in a portfolio plan
         * @param {string} portfolioPlanId Portfolio Plan id
         * @param {Array<ResourcePoolBudgetAmountPatchItem>} body JSON Patch Operations to update multiple resource pool budget amounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourcePoolBudgetAmountsForPortfolioPlan(portfolioPlanId: string, body: Array<ResourcePoolBudgetAmountPatchItem>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ResourcePool>> {
            const localVarFetchArgs = ResourcePoolsApiFetchParamCreator(configuration).updateResourcePoolBudgetAmountsForPortfolioPlan(portfolioPlanId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ResourcePoolsApi - factory interface
 * @export
 */
export const ResourcePoolsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Retrieves a resource pool.
         * @param {string} id Resource Pool id
         * @param {string} [portfolioPlanId] Portfolio Plan id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePool(id: string, portfolioPlanId?: string, options?: any) {
            return ResourcePoolsApiFp(configuration).getResourcePool(id, portfolioPlanId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetch resource pools for portfolio plan
         * @param {string} portfolioPlanId Portfolio Plan id
         * @param {boolean} [planOverridesOnly] Returns only plan overrides. default is false.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePoolsForPortfolioPlan(portfolioPlanId: string, planOverridesOnly?: boolean, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
            return ResourcePoolsApiFp(configuration).getResourcePoolsForPortfolioPlan(portfolioPlanId, planOverridesOnly, expand, limit, offset, orderBy, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update resource pool budget amounts in a portfolio plan
         * @param {string} portfolioPlanId Portfolio Plan id
         * @param {Array<ResourcePoolBudgetAmountPatchItem>} body JSON Patch Operations to update multiple resource pool budget amounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourcePoolBudgetAmountsForPortfolioPlan(portfolioPlanId: string, body: Array<ResourcePoolBudgetAmountPatchItem>, options?: any) {
            return ResourcePoolsApiFp(configuration).updateResourcePoolBudgetAmountsForPortfolioPlan(portfolioPlanId, body, options)(fetch, basePath);
        },
    };
};

/**
 * ResourcePoolsApi - object-oriented interface
 * @export
 * @class ResourcePoolsApi
 * @extends {BaseAPI}
 */
export class ResourcePoolsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieves a resource pool.
     * @param {string} id Resource Pool id
     * @param {string} [portfolioPlanId] Portfolio Plan id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcePoolsApi
     */
    public getResourcePool(id: string, portfolioPlanId?: string, options?: any) {
        return ResourcePoolsApiFp(this.configuration).getResourcePool(id, portfolioPlanId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Fetch resource pools for portfolio plan
     * @param {string} portfolioPlanId Portfolio Plan id
     * @param {boolean} [planOverridesOnly] Returns only plan overrides. default is false.
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcePoolsApi
     */
    public getResourcePoolsForPortfolioPlan(portfolioPlanId: string, planOverridesOnly?: boolean, expand?: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
        return ResourcePoolsApiFp(this.configuration).getResourcePoolsForPortfolioPlan(portfolioPlanId, planOverridesOnly, expand, limit, offset, orderBy, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update resource pool budget amounts in a portfolio plan
     * @param {string} portfolioPlanId Portfolio Plan id
     * @param {Array<ResourcePoolBudgetAmountPatchItem>} body JSON Patch Operations to update multiple resource pool budget amounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcePoolsApi
     */
    public updateResourcePoolBudgetAmountsForPortfolioPlan(portfolioPlanId: string, body: Array<ResourcePoolBudgetAmountPatchItem>, options?: any) {
        return ResourcePoolsApiFp(this.configuration).updateResourcePoolBudgetAmountsForPortfolioPlan(portfolioPlanId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ScoreWeightsApi - fetch parameter creator
 * @export
 */
export const ScoreWeightsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch score weights for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreWeightsForPortfolio(portfolioId: string, limit?: number, offset?: number, orderBy?: string, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getScoreWeightsForPortfolio.');
            }
            const localVarPath = `/scoreWeights`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates Score Weights for portfolio
         * @param {Array<ScoreWeight>} scoreWeights Score Weights
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScoreWeightsForPortfolio(scoreWeights: Array<ScoreWeight>, options: any = {}): FetchArgs {
            // verify required parameter 'scoreWeights' is not null or undefined
            if (scoreWeights === null || scoreWeights === undefined) {
                throw new RequiredError('scoreWeights','Required parameter scoreWeights was null or undefined when calling updateScoreWeightsForPortfolio.');
            }
            const localVarPath = `/scoreWeights`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/merge-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ScoreWeight&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(scoreWeights || {}) : (scoreWeights || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScoreWeightsApi - functional programming interface
 * @export
 */
export const ScoreWeightsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch score weights for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreWeightsForPortfolio(portfolioId: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScoreWeights> {
            const localVarFetchArgs = ScoreWeightsApiFetchParamCreator(configuration).getScoreWeightsForPortfolio(portfolioId, limit, offset, orderBy, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates Score Weights for portfolio
         * @param {Array<ScoreWeight>} scoreWeights Score Weights
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScoreWeightsForPortfolio(scoreWeights: Array<ScoreWeight>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ScoreWeight>> {
            const localVarFetchArgs = ScoreWeightsApiFetchParamCreator(configuration).updateScoreWeightsForPortfolio(scoreWeights, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ScoreWeightsApi - factory interface
 * @export
 */
export const ScoreWeightsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Fetch score weights for portfolio
         * @param {string} portfolioId Portfolio id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScoreWeightsForPortfolio(portfolioId: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
            return ScoreWeightsApiFp(configuration).getScoreWeightsForPortfolio(portfolioId, limit, offset, orderBy, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates Score Weights for portfolio
         * @param {Array<ScoreWeight>} scoreWeights Score Weights
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScoreWeightsForPortfolio(scoreWeights: Array<ScoreWeight>, options?: any) {
            return ScoreWeightsApiFp(configuration).updateScoreWeightsForPortfolio(scoreWeights, options)(fetch, basePath);
        },
    };
};

/**
 * ScoreWeightsApi - object-oriented interface
 * @export
 * @class ScoreWeightsApi
 * @extends {BaseAPI}
 */
export class ScoreWeightsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch score weights for portfolio
     * @param {string} portfolioId Portfolio id
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [orderBy] Comma delimited list of order by expressions. Use &#39;-&#39; in front of expression for reverse order.
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreWeightsApi
     */
    public getScoreWeightsForPortfolio(portfolioId: string, limit?: number, offset?: number, orderBy?: string, match?: string, options?: any) {
        return ScoreWeightsApiFp(this.configuration).getScoreWeightsForPortfolio(portfolioId, limit, offset, orderBy, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates Score Weights for portfolio
     * @param {Array<ScoreWeight>} scoreWeights Score Weights
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoreWeightsApi
     */
    public updateScoreWeightsForPortfolio(scoreWeights: Array<ScoreWeight>, options?: any) {
        return ScoreWeightsApiFp(this.configuration).updateScoreWeightsForPortfolio(scoreWeights, options)(this.fetch, this.basePath);
    }

}

/**
 * SourcesApi - fetch parameter creator
 * @export
 */
export const SourcesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch data for source.
         * @param {string} id Source id
         * @param {string} [priorityScenario] Priority Scenario name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchDataForSource(id: string, priorityScenario?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fetchDataForSource.');
            }
            const localVarPath = `/sources/{id}/fetchData`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (priorityScenario !== undefined) {
                localVarQueryParameter['priorityScenario'] = priorityScenario;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send data for source.
         * @param {string} id Source id
         * @param {Array<string>} statuses Statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDataForSource(id: string, statuses: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sendDataForSource.');
            }
            // verify required parameter 'statuses' is not null or undefined
            if (statuses === null || statuses === undefined) {
                throw new RequiredError('statuses','Required parameter statuses was null or undefined when calling sendDataForSource.');
            }
            const localVarPath = `/sources/{id}/sendData`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(statuses || {}) : (statuses || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesApi - functional programming interface
 * @export
 */
export const SourcesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch data for source.
         * @param {string} id Source id
         * @param {string} [priorityScenario] Priority Scenario name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchDataForSource(id: string, priorityScenario?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Source> {
            const localVarFetchArgs = SourcesApiFetchParamCreator(configuration).fetchDataForSource(id, priorityScenario, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Send data for source.
         * @param {string} id Source id
         * @param {Array<string>} statuses Statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDataForSource(id: string, statuses: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Source> {
            const localVarFetchArgs = SourcesApiFetchParamCreator(configuration).sendDataForSource(id, statuses, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SourcesApi - factory interface
 * @export
 */
export const SourcesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Fetch data for source.
         * @param {string} id Source id
         * @param {string} [priorityScenario] Priority Scenario name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchDataForSource(id: string, priorityScenario?: string, options?: any) {
            return SourcesApiFp(configuration).fetchDataForSource(id, priorityScenario, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send data for source.
         * @param {string} id Source id
         * @param {Array<string>} statuses Statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDataForSource(id: string, statuses: Array<string>, options?: any) {
            return SourcesApiFp(configuration).sendDataForSource(id, statuses, options)(fetch, basePath);
        },
    };
};

/**
 * SourcesApi - object-oriented interface
 * @export
 * @class SourcesApi
 * @extends {BaseAPI}
 */
export class SourcesApi extends BaseAPI {
    /**
     * 
     * @summary Fetch data for source.
     * @param {string} id Source id
     * @param {string} [priorityScenario] Priority Scenario name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public fetchDataForSource(id: string, priorityScenario?: string, options?: any) {
        return SourcesApiFp(this.configuration).fetchDataForSource(id, priorityScenario, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Send data for source.
     * @param {string} id Source id
     * @param {Array<string>} statuses Statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public sendDataForSource(id: string, statuses: Array<string>, options?: any) {
        return SourcesApiFp(this.configuration).sendDataForSource(id, statuses, options)(this.fetch, this.basePath);
    }

}

/**
 * SpreadsheetApi - fetch parameter creator
 * @export
 */
export const SpreadsheetApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates spreadsheet from file upload.
         * @param {any} file xls or xlsx file upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpreadsheet(file: any, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling createSpreadsheet.');
            }
            const localVarPath = `/spreadsheet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates spreadsheet from kloudless file
         * @param {KloudlessFile} kloudlessFile kloudless file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpreadsheetForKloudlessFile(kloudlessFile: KloudlessFile, options: any = {}): FetchArgs {
            // verify required parameter 'kloudlessFile' is not null or undefined
            if (kloudlessFile === null || kloudlessFile === undefined) {
                throw new RequiredError('kloudlessFile','Required parameter kloudlessFile was null or undefined when calling createSpreadsheetForKloudlessFile.');
            }
            const localVarPath = `/spreadsheet/kloudless`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KloudlessFile" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(kloudlessFile || {}) : (kloudlessFile || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete spreadsheet and mappings
         * @param {string} id spreadsheet id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpreadsheet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSpreadsheet.');
            }
            const localVarPath = `/spreadsheet/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get mappings for spreadsheet
         * @param {string} id spreadsheet id
         * @param {string} [sheetName] 
         * @param {any} [importType] Whether import PROJECT or COST data. Defaults to PROJECT
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {boolean} [columnsOnly] return columns only the case for cost import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMappingsForSpreadsheet(id: string, sheetName?: string, importType?: any, expand?: string, columnsOnly?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getMappingsForSpreadsheet.');
            }
            const localVarPath = `/spreadsheet/{id}/mappings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sheetName !== undefined) {
                localVarQueryParameter['sheetName'] = sheetName;
            }

            if (importType !== undefined) {
                localVarQueryParameter['importType'] = importType;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (columnsOnly !== undefined) {
                localVarQueryParameter['columnsOnly'] = columnsOnly;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get spreadsheet
         * @param {string} id spreadsheet id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpreadsheet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSpreadsheet.');
            }
            const localVarPath = `/spreadsheet/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpreadsheetApi - functional programming interface
 * @export
 */
export const SpreadsheetApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates spreadsheet from file upload.
         * @param {any} file xls or xlsx file upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpreadsheet(file: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Spreadsheet> {
            const localVarFetchArgs = SpreadsheetApiFetchParamCreator(configuration).createSpreadsheet(file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates spreadsheet from kloudless file
         * @param {KloudlessFile} kloudlessFile kloudless file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpreadsheetForKloudlessFile(kloudlessFile: KloudlessFile, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Spreadsheet> {
            const localVarFetchArgs = SpreadsheetApiFetchParamCreator(configuration).createSpreadsheetForKloudlessFile(kloudlessFile, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete spreadsheet and mappings
         * @param {string} id spreadsheet id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpreadsheet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SpreadsheetApiFetchParamCreator(configuration).deleteSpreadsheet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get mappings for spreadsheet
         * @param {string} id spreadsheet id
         * @param {string} [sheetName] 
         * @param {any} [importType] Whether import PROJECT or COST data. Defaults to PROJECT
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {boolean} [columnsOnly] return columns only the case for cost import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMappingsForSpreadsheet(id: string, sheetName?: string, importType?: any, expand?: string, columnsOnly?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Mappings> {
            const localVarFetchArgs = SpreadsheetApiFetchParamCreator(configuration).getMappingsForSpreadsheet(id, sheetName, importType, expand, columnsOnly, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get spreadsheet
         * @param {string} id spreadsheet id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpreadsheet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Spreadsheet> {
            const localVarFetchArgs = SpreadsheetApiFetchParamCreator(configuration).getSpreadsheet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SpreadsheetApi - factory interface
 * @export
 */
export const SpreadsheetApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates spreadsheet from file upload.
         * @param {any} file xls or xlsx file upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpreadsheet(file: any, options?: any) {
            return SpreadsheetApiFp(configuration).createSpreadsheet(file, options)(fetch, basePath);
        },
        /**
         * Creates spreadsheet from kloudless file
         * @param {KloudlessFile} kloudlessFile kloudless file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpreadsheetForKloudlessFile(kloudlessFile: KloudlessFile, options?: any) {
            return SpreadsheetApiFp(configuration).createSpreadsheetForKloudlessFile(kloudlessFile, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete spreadsheet and mappings
         * @param {string} id spreadsheet id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpreadsheet(id: string, options?: any) {
            return SpreadsheetApiFp(configuration).deleteSpreadsheet(id, options)(fetch, basePath);
        },
        /**
         * Get mappings for spreadsheet
         * @param {string} id spreadsheet id
         * @param {string} [sheetName] 
         * @param {any} [importType] Whether import PROJECT or COST data. Defaults to PROJECT
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {boolean} [columnsOnly] return columns only the case for cost import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMappingsForSpreadsheet(id: string, sheetName?: string, importType?: any, expand?: string, columnsOnly?: boolean, options?: any) {
            return SpreadsheetApiFp(configuration).getMappingsForSpreadsheet(id, sheetName, importType, expand, columnsOnly, options)(fetch, basePath);
        },
        /**
         * Get spreadsheet
         * @param {string} id spreadsheet id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpreadsheet(id: string, options?: any) {
            return SpreadsheetApiFp(configuration).getSpreadsheet(id, options)(fetch, basePath);
        },
    };
};

/**
 * SpreadsheetApi - object-oriented interface
 * @export
 * @class SpreadsheetApi
 * @extends {BaseAPI}
 */
export class SpreadsheetApi extends BaseAPI {
    /**
     * Creates spreadsheet from file upload.
     * @param {any} file xls or xlsx file upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpreadsheetApi
     */
    public createSpreadsheet(file: any, options?: any) {
        return SpreadsheetApiFp(this.configuration).createSpreadsheet(file, options)(this.fetch, this.basePath);
    }

    /**
     * Creates spreadsheet from kloudless file
     * @param {KloudlessFile} kloudlessFile kloudless file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpreadsheetApi
     */
    public createSpreadsheetForKloudlessFile(kloudlessFile: KloudlessFile, options?: any) {
        return SpreadsheetApiFp(this.configuration).createSpreadsheetForKloudlessFile(kloudlessFile, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete spreadsheet and mappings
     * @param {string} id spreadsheet id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpreadsheetApi
     */
    public deleteSpreadsheet(id: string, options?: any) {
        return SpreadsheetApiFp(this.configuration).deleteSpreadsheet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get mappings for spreadsheet
     * @param {string} id spreadsheet id
     * @param {string} [sheetName] 
     * @param {any} [importType] Whether import PROJECT or COST data. Defaults to PROJECT
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {boolean} [columnsOnly] return columns only the case for cost import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpreadsheetApi
     */
    public getMappingsForSpreadsheet(id: string, sheetName?: string, importType?: any, expand?: string, columnsOnly?: boolean, options?: any) {
        return SpreadsheetApiFp(this.configuration).getMappingsForSpreadsheet(id, sheetName, importType, expand, columnsOnly, options)(this.fetch, this.basePath);
    }

    /**
     * Get spreadsheet
     * @param {string} id spreadsheet id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpreadsheetApi
     */
    public getSpreadsheet(id: string, options?: any) {
        return SpreadsheetApiFp(this.configuration).getSpreadsheet(id, options)(this.fetch, this.basePath);
    }

}

/**
 * TagsApi - fetch parameter creator
 * @export
 */
export const TagsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new tag
         * @param {Tag} body Tag to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(body: Tag, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTag.');
            }
            const localVarPath = `/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Tag" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single tag
         * @param {string} id Tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTag.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a tag
         * @param {string} id Tag id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTag.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves tags for a portfolio
         * @param {string} portfolioId Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsForPortfolio(portfolioId: string, options: any = {}): FetchArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling getTagsForPortfolio.');
            }
            const localVarPath = `/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (portfolioId !== undefined) {
                localVarQueryParameter['portfolioId'] = portfolioId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single tag
         * @param {string} id Tag ID
         * @param {Operations} body JSON Patch operations to update value field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(id: string, body: Operations, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTag.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateTag.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Operations" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new tag
         * @param {Tag} body Tag to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(body: Tag, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).createTag(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a single tag
         * @param {string} id Tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).deleteTag(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves a tag
         * @param {string} id Tag id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).getTag(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieves tags for a portfolio
         * @param {string} portfolioId Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsForPortfolio(portfolioId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tags> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).getTagsForPortfolio(portfolioId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a single tag
         * @param {string} id Tag ID
         * @param {Operations} body JSON Patch operations to update value field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(id: string, body: Operations, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).updateTag(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Creates a new tag
         * @param {Tag} body Tag to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(body: Tag, options?: any) {
            return TagsApiFp(configuration).createTag(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a single tag
         * @param {string} id Tag ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(id: string, options?: any) {
            return TagsApiFp(configuration).deleteTag(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves a tag
         * @param {string} id Tag id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(id: string, options?: any) {
            return TagsApiFp(configuration).getTag(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves tags for a portfolio
         * @param {string} portfolioId Portfolio id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsForPortfolio(portfolioId: string, options?: any) {
            return TagsApiFp(configuration).getTagsForPortfolio(portfolioId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a single tag
         * @param {string} id Tag ID
         * @param {Operations} body JSON Patch operations to update value field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(id: string, body: Operations, options?: any) {
            return TagsApiFp(configuration).updateTag(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new tag
     * @param {Tag} body Tag to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public createTag(body: Tag, options?: any) {
        return TagsApiFp(this.configuration).createTag(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a single tag
     * @param {string} id Tag ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(id: string, options?: any) {
        return TagsApiFp(this.configuration).deleteTag(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves a tag
     * @param {string} id Tag id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTag(id: string, options?: any) {
        return TagsApiFp(this.configuration).getTag(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieves tags for a portfolio
     * @param {string} portfolioId Portfolio id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTagsForPortfolio(portfolioId: string, options?: any) {
        return TagsApiFp(this.configuration).getTagsForPortfolio(portfolioId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a single tag
     * @param {string} id Tag ID
     * @param {Operations} body JSON Patch operations to update value field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTag(id: string, body: Operations, options?: any) {
        return TagsApiFp(this.configuration).updateTag(id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUser.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user activities
         * @param {string} id User id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserActivities(id: string, limit?: number, offset?: number, match?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUserActivities.');
            }
            const localVarPath = `/users/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user activities for group
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserActivitiesForGroup(limit?: number, offset?: number, match?: string, options: any = {}): FetchArgs {
            const localVarPath = `/users/activities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).deleteUser(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUser(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get user activities
         * @param {string} id User id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserActivities(id: string, limit?: number, offset?: number, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Activities> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUserActivities(id, limit, offset, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get user activities for group
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserActivitiesForGroup(limit?: number, offset?: number, match?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Activities> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUserActivitiesForGroup(limit, offset, match, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Delete user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any) {
            return UserApiFp(configuration).deleteUser(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user
         * @param {string} id User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any) {
            return UserApiFp(configuration).getUser(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user activities
         * @param {string} id User id
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserActivities(id: string, limit?: number, offset?: number, match?: string, options?: any) {
            return UserApiFp(configuration).getUserActivities(id, limit, offset, match, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user activities for group
         * @param {number} [limit] Pagination limit
         * @param {number} [offset] Pagination offset
         * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserActivitiesForGroup(limit?: number, offset?: number, match?: string, options?: any) {
            return UserApiFp(configuration).getUserActivitiesForGroup(limit, offset, match, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Delete user
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(id: string, options?: any) {
        return UserApiFp(this.configuration).deleteUser(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get user
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(id: string, options?: any) {
        return UserApiFp(this.configuration).getUser(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get user activities
     * @param {string} id User id
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserActivities(id: string, limit?: number, offset?: number, match?: string, options?: any) {
        return UserApiFp(this.configuration).getUserActivities(id, limit, offset, match, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get user activities for group
     * @param {number} [limit] Pagination limit
     * @param {number} [offset] Pagination offset
     * @param {string} [match] Semi-colon delimited list of expressions to include in the response only the items in a collections that satisfy the expression(s). All other items should be exluded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserActivitiesForGroup(limit?: number, offset?: number, match?: string, options?: any) {
        return UserApiFp(this.configuration).getUserActivitiesForGroup(limit, offset, match, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new user.
         * @param {AddUserRequest} user User to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: AddUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling createUser.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get users.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the status of user
         * @param {string} id User id
         * @param {User} user Updated user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, user: User, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateUser.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling updateUser.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/merge-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new user.
         * @param {AddUserRequest} user User to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: AddUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).createUser(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get users.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Users> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUsers(expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the status of user
         * @param {string} id User id
         * @param {User} user Updated user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, user: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUser(id, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Creates a new user.
         * @param {AddUserRequest} user User to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: AddUserRequest, options?: any) {
            return UsersApiFp(configuration).createUser(user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get users.
         * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(expand?: string, options?: any) {
            return UsersApiFp(configuration).getUsers(expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the status of user
         * @param {string} id User id
         * @param {User} user Updated user request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, user: User, options?: any) {
            return UsersApiFp(configuration).updateUser(id, user, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new user.
     * @param {AddUserRequest} user User to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(user: AddUserRequest, options?: any) {
        return UsersApiFp(this.configuration).createUser(user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get users.
     * @param {string} [expand] JSON string containing an array expand specifications for fields.  An expand specification must have a path and includes optional properties match, unique, allPossible, limit, offset, orderBy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(expand?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsers(expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the status of user
     * @param {string} id User id
     * @param {User} user Updated user request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: string, user: User, options?: any) {
        return UsersApiFp(this.configuration).updateUser(id, user, options)(this.fetch, this.basePath);
    }

}

